// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: flow/access/access.proto
#ifndef GRPC_flow_2faccess_2faccess_2eproto__INCLUDED
#define GRPC_flow_2faccess_2faccess_2eproto__INCLUDED

#include "flow/access/access.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace flow {
namespace access {

// AccessAPI is the public-facing API provided by access nodes.
class AccessAPI final {
 public:
  static constexpr char const* service_full_name() {
    return "flow.access.AccessAPI";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Ping is used to check if the access node is alive and healthy.
    virtual ::grpc::Status Ping(::grpc::ClientContext* context, const ::flow::access::PingRequest& request, ::flow::access::PingResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::PingResponse>> AsyncPing(::grpc::ClientContext* context, const ::flow::access::PingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::PingResponse>>(AsyncPingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::PingResponse>> PrepareAsyncPing(::grpc::ClientContext* context, const ::flow::access::PingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::PingResponse>>(PrepareAsyncPingRaw(context, request, cq));
    }
    // Block Headers
    //
    // GetLatestBlockHeader gets the latest sealed or unsealed block header.
    virtual ::grpc::Status GetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest& request, ::flow::access::BlockHeaderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>> AsyncGetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>>(AsyncGetLatestBlockHeaderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>> PrepareAsyncGetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>>(PrepareAsyncGetLatestBlockHeaderRaw(context, request, cq));
    }
    // GetBlockHeaderByID gets a block header by ID.
    virtual ::grpc::Status GetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIDRequest& request, ::flow::access::BlockHeaderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>> AsyncGetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>>(AsyncGetBlockHeaderByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>> PrepareAsyncGetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>>(PrepareAsyncGetBlockHeaderByIDRaw(context, request, cq));
    }
    // GetBlockHeaderByHeight gets a block header by height.
    virtual ::grpc::Status GetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest& request, ::flow::access::BlockHeaderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>> AsyncGetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>>(AsyncGetBlockHeaderByHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>> PrepareAsyncGetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>>(PrepareAsyncGetBlockHeaderByHeightRaw(context, request, cq));
    }
    // Blocks
    //
    // GetLatestBlock gets the full payload of the latest sealed or unsealed
    // block.
    virtual ::grpc::Status GetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest& request, ::flow::access::BlockResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>> AsyncGetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>>(AsyncGetLatestBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>> PrepareAsyncGetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>>(PrepareAsyncGetLatestBlockRaw(context, request, cq));
    }
    // GetBlockByID gets a full block by ID.
    virtual ::grpc::Status GetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIDRequest& request, ::flow::access::BlockResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>> AsyncGetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>>(AsyncGetBlockByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>> PrepareAsyncGetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>>(PrepareAsyncGetBlockByIDRaw(context, request, cq));
    }
    // GetBlockByHeight gets a full block by height.
    virtual ::grpc::Status GetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest& request, ::flow::access::BlockResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>> AsyncGetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>>(AsyncGetBlockByHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>> PrepareAsyncGetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>>(PrepareAsyncGetBlockByHeightRaw(context, request, cq));
    }
    // Collections
    //
    // GetCollectionByID gets a collection by ID.
    virtual ::grpc::Status GetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIDRequest& request, ::flow::access::CollectionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::CollectionResponse>> AsyncGetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::CollectionResponse>>(AsyncGetCollectionByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::CollectionResponse>> PrepareAsyncGetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::CollectionResponse>>(PrepareAsyncGetCollectionByIDRaw(context, request, cq));
    }
    // Transactions
    //
    // SendTransaction submits a transaction to the network.
    virtual ::grpc::Status SendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest& request, ::flow::access::SendTransactionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::SendTransactionResponse>> AsyncSendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::SendTransactionResponse>>(AsyncSendTransactionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::SendTransactionResponse>> PrepareAsyncSendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::SendTransactionResponse>>(PrepareAsyncSendTransactionRaw(context, request, cq));
    }
    // GetTransaction gets a transaction by ID.
    virtual ::grpc::Status GetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::flow::access::TransactionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResponse>> AsyncGetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResponse>>(AsyncGetTransactionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResponse>> PrepareAsyncGetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResponse>>(PrepareAsyncGetTransactionRaw(context, request, cq));
    }
    // GetTransactionResult gets the result of a transaction.
    virtual ::grpc::Status GetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::flow::access::TransactionResultResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResultResponse>> AsyncGetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResultResponse>>(AsyncGetTransactionResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResultResponse>> PrepareAsyncGetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResultResponse>>(PrepareAsyncGetTransactionResultRaw(context, request, cq));
    }
    // Accounts
    //
    // GetAccount is an alias for GetAccountAtLatestBlock.
    //
    // Warning: this function is deprecated. It behaves identically to
    // GetAccountAtLatestBlock and will be removed in a future version.
    virtual ::grpc::Status GetAccount(::grpc::ClientContext* context, const ::flow::access::GetAccountRequest& request, ::flow::access::GetAccountResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::GetAccountResponse>> AsyncGetAccount(::grpc::ClientContext* context, const ::flow::access::GetAccountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::GetAccountResponse>>(AsyncGetAccountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::GetAccountResponse>> PrepareAsyncGetAccount(::grpc::ClientContext* context, const ::flow::access::GetAccountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::GetAccountResponse>>(PrepareAsyncGetAccountRaw(context, request, cq));
    }
    // GetAccountAtLatestBlock gets an account by address from the latest sealed
    // execution state.
    virtual ::grpc::Status GetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest& request, ::flow::access::AccountResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>> AsyncGetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>>(AsyncGetAccountAtLatestBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>> PrepareAsyncGetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>>(PrepareAsyncGetAccountAtLatestBlockRaw(context, request, cq));
    }
    // GetAccountAtBlockHeight gets an account by address at the given block
    // height
    virtual ::grpc::Status GetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest& request, ::flow::access::AccountResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>> AsyncGetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>>(AsyncGetAccountAtBlockHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>> PrepareAsyncGetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>>(PrepareAsyncGetAccountAtBlockHeightRaw(context, request, cq));
    }
    // Scripts
    //
    // ExecuteScriptAtLatestBlock executes a read-only Cadence script against the
    // latest sealed execution state.
    virtual ::grpc::Status ExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest& request, ::flow::access::ExecuteScriptResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>> AsyncExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>>(AsyncExecuteScriptAtLatestBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>> PrepareAsyncExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>>(PrepareAsyncExecuteScriptAtLatestBlockRaw(context, request, cq));
    }
    // ExecuteScriptAtBlockID executes a ready-only Cadence script against the
    // execution state at the block with the given ID.
    virtual ::grpc::Status ExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIDRequest& request, ::flow::access::ExecuteScriptResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>> AsyncExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>>(AsyncExecuteScriptAtBlockIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>> PrepareAsyncExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>>(PrepareAsyncExecuteScriptAtBlockIDRaw(context, request, cq));
    }
    // ExecuteScriptAtBlockHeight executes a ready-only Cadence script against the
    // execution state at the given block height.
    virtual ::grpc::Status ExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest& request, ::flow::access::ExecuteScriptResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>> AsyncExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>>(AsyncExecuteScriptAtBlockHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>> PrepareAsyncExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>>(PrepareAsyncExecuteScriptAtBlockHeightRaw(context, request, cq));
    }
    // Events
    //
    // GetEventsForHeightRange retrieves events emitted within the specified block
    // range.
    virtual ::grpc::Status GetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest& request, ::flow::access::EventsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>> AsyncGetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>>(AsyncGetEventsForHeightRangeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>> PrepareAsyncGetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>>(PrepareAsyncGetEventsForHeightRangeRaw(context, request, cq));
    }
    // GetEventsForBlockIDs retrieves events for the specified block IDs and event
    // type.
    virtual ::grpc::Status GetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIDsRequest& request, ::flow::access::EventsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>> AsyncGetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIDsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>>(AsyncGetEventsForBlockIDsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>> PrepareAsyncGetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIDsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>>(PrepareAsyncGetEventsForBlockIDsRaw(context, request, cq));
    }
    // NetworkParameters
    //
    // GetNetworkParameters retrieves the Flow network details
    virtual ::grpc::Status GetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest& request, ::flow::access::GetNetworkParametersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::GetNetworkParametersResponse>> AsyncGetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::GetNetworkParametersResponse>>(AsyncGetNetworkParametersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::GetNetworkParametersResponse>> PrepareAsyncGetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::GetNetworkParametersResponse>>(PrepareAsyncGetNetworkParametersRaw(context, request, cq));
    }
    // ProtocolState
    //
    // GetLatestProtocolStateSnapshot retrieves the latest sealed protocol state
    // snapshot. Used by Flow nodes joining the network to bootstrap a
    // space-efficient local state.
    virtual ::grpc::Status GetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest& request, ::flow::access::ProtocolStateSnapshotResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ProtocolStateSnapshotResponse>> AsyncGetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ProtocolStateSnapshotResponse>>(AsyncGetLatestProtocolStateSnapshotRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ProtocolStateSnapshotResponse>> PrepareAsyncGetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ProtocolStateSnapshotResponse>>(PrepareAsyncGetLatestProtocolStateSnapshotRaw(context, request, cq));
    }
    // GetExecutionResultForBlockID returns Execution Result for a given block.
    // At present, Access Node might not have execution results for every block
    // and as usual, until sealed, this data can change
    virtual ::grpc::Status GetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIDRequest& request, ::flow::access::ExecutionResultForBlockIDResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecutionResultForBlockIDResponse>> AsyncGetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecutionResultForBlockIDResponse>>(AsyncGetExecutionResultForBlockIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecutionResultForBlockIDResponse>> PrepareAsyncGetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecutionResultForBlockIDResponse>>(PrepareAsyncGetExecutionResultForBlockIDRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Ping is used to check if the access node is alive and healthy.
      virtual void Ping(::grpc::ClientContext* context, const ::flow::access::PingRequest* request, ::flow::access::PingResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Ping(::grpc::ClientContext* context, const ::flow::access::PingRequest* request, ::flow::access::PingResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Block Headers
      //
      // GetLatestBlockHeader gets the latest sealed or unsealed block header.
      virtual void GetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest* request, ::flow::access::BlockHeaderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest* request, ::flow::access::BlockHeaderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // GetBlockHeaderByID gets a block header by ID.
      virtual void GetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIDRequest* request, ::flow::access::BlockHeaderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIDRequest* request, ::flow::access::BlockHeaderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // GetBlockHeaderByHeight gets a block header by height.
      virtual void GetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest* request, ::flow::access::BlockHeaderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest* request, ::flow::access::BlockHeaderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Blocks
      //
      // GetLatestBlock gets the full payload of the latest sealed or unsealed
      // block.
      virtual void GetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest* request, ::flow::access::BlockResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest* request, ::flow::access::BlockResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // GetBlockByID gets a full block by ID.
      virtual void GetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIDRequest* request, ::flow::access::BlockResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIDRequest* request, ::flow::access::BlockResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // GetBlockByHeight gets a full block by height.
      virtual void GetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest* request, ::flow::access::BlockResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest* request, ::flow::access::BlockResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Collections
      //
      // GetCollectionByID gets a collection by ID.
      virtual void GetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIDRequest* request, ::flow::access::CollectionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIDRequest* request, ::flow::access::CollectionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Transactions
      //
      // SendTransaction submits a transaction to the network.
      virtual void SendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest* request, ::flow::access::SendTransactionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest* request, ::flow::access::SendTransactionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // GetTransaction gets a transaction by ID.
      virtual void GetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // GetTransactionResult gets the result of a transaction.
      virtual void GetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResultResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResultResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Accounts
      //
      // GetAccount is an alias for GetAccountAtLatestBlock.
      //
      // Warning: this function is deprecated. It behaves identically to
      // GetAccountAtLatestBlock and will be removed in a future version.
      virtual void GetAccount(::grpc::ClientContext* context, const ::flow::access::GetAccountRequest* request, ::flow::access::GetAccountResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAccount(::grpc::ClientContext* context, const ::flow::access::GetAccountRequest* request, ::flow::access::GetAccountResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // GetAccountAtLatestBlock gets an account by address from the latest sealed
      // execution state.
      virtual void GetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest* request, ::flow::access::AccountResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest* request, ::flow::access::AccountResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // GetAccountAtBlockHeight gets an account by address at the given block
      // height
      virtual void GetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest* request, ::flow::access::AccountResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest* request, ::flow::access::AccountResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Scripts
      //
      // ExecuteScriptAtLatestBlock executes a read-only Cadence script against the
      // latest sealed execution state.
      virtual void ExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest* request, ::flow::access::ExecuteScriptResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest* request, ::flow::access::ExecuteScriptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ExecuteScriptAtBlockID executes a ready-only Cadence script against the
      // execution state at the block with the given ID.
      virtual void ExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIDRequest* request, ::flow::access::ExecuteScriptResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIDRequest* request, ::flow::access::ExecuteScriptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ExecuteScriptAtBlockHeight executes a ready-only Cadence script against the
      // execution state at the given block height.
      virtual void ExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest* request, ::flow::access::ExecuteScriptResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest* request, ::flow::access::ExecuteScriptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Events
      //
      // GetEventsForHeightRange retrieves events emitted within the specified block
      // range.
      virtual void GetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest* request, ::flow::access::EventsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest* request, ::flow::access::EventsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // GetEventsForBlockIDs retrieves events for the specified block IDs and event
      // type.
      virtual void GetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIDsRequest* request, ::flow::access::EventsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIDsRequest* request, ::flow::access::EventsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // NetworkParameters
      //
      // GetNetworkParameters retrieves the Flow network details
      virtual void GetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest* request, ::flow::access::GetNetworkParametersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest* request, ::flow::access::GetNetworkParametersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ProtocolState
      //
      // GetLatestProtocolStateSnapshot retrieves the latest sealed protocol state
      // snapshot. Used by Flow nodes joining the network to bootstrap a
      // space-efficient local state.
      virtual void GetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest* request, ::flow::access::ProtocolStateSnapshotResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest* request, ::flow::access::ProtocolStateSnapshotResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // GetExecutionResultForBlockID returns Execution Result for a given block.
      // At present, Access Node might not have execution results for every block
      // and as usual, until sealed, this data can change
      virtual void GetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIDRequest* request, ::flow::access::ExecutionResultForBlockIDResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIDRequest* request, ::flow::access::ExecutionResultForBlockIDResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::PingResponse>* AsyncPingRaw(::grpc::ClientContext* context, const ::flow::access::PingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::PingResponse>* PrepareAsyncPingRaw(::grpc::ClientContext* context, const ::flow::access::PingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>* AsyncGetLatestBlockHeaderRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>* PrepareAsyncGetLatestBlockHeaderRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>* AsyncGetBlockHeaderByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>* PrepareAsyncGetBlockHeaderByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>* AsyncGetBlockHeaderByHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>* PrepareAsyncGetBlockHeaderByHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>* AsyncGetLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>* PrepareAsyncGetLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>* AsyncGetBlockByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>* PrepareAsyncGetBlockByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>* AsyncGetBlockByHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>* PrepareAsyncGetBlockByHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::CollectionResponse>* AsyncGetCollectionByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::CollectionResponse>* PrepareAsyncGetCollectionByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::SendTransactionResponse>* AsyncSendTransactionRaw(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::SendTransactionResponse>* PrepareAsyncSendTransactionRaw(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResponse>* AsyncGetTransactionRaw(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResponse>* PrepareAsyncGetTransactionRaw(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResultResponse>* AsyncGetTransactionResultRaw(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResultResponse>* PrepareAsyncGetTransactionResultRaw(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::GetAccountResponse>* AsyncGetAccountRaw(::grpc::ClientContext* context, const ::flow::access::GetAccountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::GetAccountResponse>* PrepareAsyncGetAccountRaw(::grpc::ClientContext* context, const ::flow::access::GetAccountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>* AsyncGetAccountAtLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>* PrepareAsyncGetAccountAtLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>* AsyncGetAccountAtBlockHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>* PrepareAsyncGetAccountAtBlockHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>* AsyncExecuteScriptAtLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>* PrepareAsyncExecuteScriptAtLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>* AsyncExecuteScriptAtBlockIDRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>* PrepareAsyncExecuteScriptAtBlockIDRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>* AsyncExecuteScriptAtBlockHeightRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>* PrepareAsyncExecuteScriptAtBlockHeightRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>* AsyncGetEventsForHeightRangeRaw(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>* PrepareAsyncGetEventsForHeightRangeRaw(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>* AsyncGetEventsForBlockIDsRaw(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIDsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>* PrepareAsyncGetEventsForBlockIDsRaw(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIDsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::GetNetworkParametersResponse>* AsyncGetNetworkParametersRaw(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::GetNetworkParametersResponse>* PrepareAsyncGetNetworkParametersRaw(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ProtocolStateSnapshotResponse>* AsyncGetLatestProtocolStateSnapshotRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ProtocolStateSnapshotResponse>* PrepareAsyncGetLatestProtocolStateSnapshotRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecutionResultForBlockIDResponse>* AsyncGetExecutionResultForBlockIDRaw(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecutionResultForBlockIDResponse>* PrepareAsyncGetExecutionResultForBlockIDRaw(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Ping(::grpc::ClientContext* context, const ::flow::access::PingRequest& request, ::flow::access::PingResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::PingResponse>> AsyncPing(::grpc::ClientContext* context, const ::flow::access::PingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::PingResponse>>(AsyncPingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::PingResponse>> PrepareAsyncPing(::grpc::ClientContext* context, const ::flow::access::PingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::PingResponse>>(PrepareAsyncPingRaw(context, request, cq));
    }
    ::grpc::Status GetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest& request, ::flow::access::BlockHeaderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>> AsyncGetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>>(AsyncGetLatestBlockHeaderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>> PrepareAsyncGetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>>(PrepareAsyncGetLatestBlockHeaderRaw(context, request, cq));
    }
    ::grpc::Status GetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIDRequest& request, ::flow::access::BlockHeaderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>> AsyncGetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>>(AsyncGetBlockHeaderByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>> PrepareAsyncGetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>>(PrepareAsyncGetBlockHeaderByIDRaw(context, request, cq));
    }
    ::grpc::Status GetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest& request, ::flow::access::BlockHeaderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>> AsyncGetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>>(AsyncGetBlockHeaderByHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>> PrepareAsyncGetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>>(PrepareAsyncGetBlockHeaderByHeightRaw(context, request, cq));
    }
    ::grpc::Status GetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest& request, ::flow::access::BlockResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>> AsyncGetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>>(AsyncGetLatestBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>> PrepareAsyncGetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>>(PrepareAsyncGetLatestBlockRaw(context, request, cq));
    }
    ::grpc::Status GetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIDRequest& request, ::flow::access::BlockResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>> AsyncGetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>>(AsyncGetBlockByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>> PrepareAsyncGetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>>(PrepareAsyncGetBlockByIDRaw(context, request, cq));
    }
    ::grpc::Status GetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest& request, ::flow::access::BlockResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>> AsyncGetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>>(AsyncGetBlockByHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>> PrepareAsyncGetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>>(PrepareAsyncGetBlockByHeightRaw(context, request, cq));
    }
    ::grpc::Status GetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIDRequest& request, ::flow::access::CollectionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::CollectionResponse>> AsyncGetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::CollectionResponse>>(AsyncGetCollectionByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::CollectionResponse>> PrepareAsyncGetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::CollectionResponse>>(PrepareAsyncGetCollectionByIDRaw(context, request, cq));
    }
    ::grpc::Status SendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest& request, ::flow::access::SendTransactionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::SendTransactionResponse>> AsyncSendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::SendTransactionResponse>>(AsyncSendTransactionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::SendTransactionResponse>> PrepareAsyncSendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::SendTransactionResponse>>(PrepareAsyncSendTransactionRaw(context, request, cq));
    }
    ::grpc::Status GetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::flow::access::TransactionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResponse>> AsyncGetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResponse>>(AsyncGetTransactionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResponse>> PrepareAsyncGetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResponse>>(PrepareAsyncGetTransactionRaw(context, request, cq));
    }
    ::grpc::Status GetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::flow::access::TransactionResultResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResultResponse>> AsyncGetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResultResponse>>(AsyncGetTransactionResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResultResponse>> PrepareAsyncGetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResultResponse>>(PrepareAsyncGetTransactionResultRaw(context, request, cq));
    }
    ::grpc::Status GetAccount(::grpc::ClientContext* context, const ::flow::access::GetAccountRequest& request, ::flow::access::GetAccountResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::GetAccountResponse>> AsyncGetAccount(::grpc::ClientContext* context, const ::flow::access::GetAccountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::GetAccountResponse>>(AsyncGetAccountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::GetAccountResponse>> PrepareAsyncGetAccount(::grpc::ClientContext* context, const ::flow::access::GetAccountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::GetAccountResponse>>(PrepareAsyncGetAccountRaw(context, request, cq));
    }
    ::grpc::Status GetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest& request, ::flow::access::AccountResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>> AsyncGetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>>(AsyncGetAccountAtLatestBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>> PrepareAsyncGetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>>(PrepareAsyncGetAccountAtLatestBlockRaw(context, request, cq));
    }
    ::grpc::Status GetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest& request, ::flow::access::AccountResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>> AsyncGetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>>(AsyncGetAccountAtBlockHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>> PrepareAsyncGetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>>(PrepareAsyncGetAccountAtBlockHeightRaw(context, request, cq));
    }
    ::grpc::Status ExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest& request, ::flow::access::ExecuteScriptResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>> AsyncExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>>(AsyncExecuteScriptAtLatestBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>> PrepareAsyncExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>>(PrepareAsyncExecuteScriptAtLatestBlockRaw(context, request, cq));
    }
    ::grpc::Status ExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIDRequest& request, ::flow::access::ExecuteScriptResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>> AsyncExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>>(AsyncExecuteScriptAtBlockIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>> PrepareAsyncExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>>(PrepareAsyncExecuteScriptAtBlockIDRaw(context, request, cq));
    }
    ::grpc::Status ExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest& request, ::flow::access::ExecuteScriptResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>> AsyncExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>>(AsyncExecuteScriptAtBlockHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>> PrepareAsyncExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>>(PrepareAsyncExecuteScriptAtBlockHeightRaw(context, request, cq));
    }
    ::grpc::Status GetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest& request, ::flow::access::EventsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>> AsyncGetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>>(AsyncGetEventsForHeightRangeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>> PrepareAsyncGetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>>(PrepareAsyncGetEventsForHeightRangeRaw(context, request, cq));
    }
    ::grpc::Status GetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIDsRequest& request, ::flow::access::EventsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>> AsyncGetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIDsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>>(AsyncGetEventsForBlockIDsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>> PrepareAsyncGetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIDsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>>(PrepareAsyncGetEventsForBlockIDsRaw(context, request, cq));
    }
    ::grpc::Status GetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest& request, ::flow::access::GetNetworkParametersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::GetNetworkParametersResponse>> AsyncGetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::GetNetworkParametersResponse>>(AsyncGetNetworkParametersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::GetNetworkParametersResponse>> PrepareAsyncGetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::GetNetworkParametersResponse>>(PrepareAsyncGetNetworkParametersRaw(context, request, cq));
    }
    ::grpc::Status GetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest& request, ::flow::access::ProtocolStateSnapshotResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ProtocolStateSnapshotResponse>> AsyncGetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ProtocolStateSnapshotResponse>>(AsyncGetLatestProtocolStateSnapshotRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ProtocolStateSnapshotResponse>> PrepareAsyncGetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ProtocolStateSnapshotResponse>>(PrepareAsyncGetLatestProtocolStateSnapshotRaw(context, request, cq));
    }
    ::grpc::Status GetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIDRequest& request, ::flow::access::ExecutionResultForBlockIDResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecutionResultForBlockIDResponse>> AsyncGetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecutionResultForBlockIDResponse>>(AsyncGetExecutionResultForBlockIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecutionResultForBlockIDResponse>> PrepareAsyncGetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecutionResultForBlockIDResponse>>(PrepareAsyncGetExecutionResultForBlockIDRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Ping(::grpc::ClientContext* context, const ::flow::access::PingRequest* request, ::flow::access::PingResponse* response, std::function<void(::grpc::Status)>) override;
      void Ping(::grpc::ClientContext* context, const ::flow::access::PingRequest* request, ::flow::access::PingResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest* request, ::flow::access::BlockHeaderResponse* response, std::function<void(::grpc::Status)>) override;
      void GetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest* request, ::flow::access::BlockHeaderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIDRequest* request, ::flow::access::BlockHeaderResponse* response, std::function<void(::grpc::Status)>) override;
      void GetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIDRequest* request, ::flow::access::BlockHeaderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest* request, ::flow::access::BlockHeaderResponse* response, std::function<void(::grpc::Status)>) override;
      void GetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest* request, ::flow::access::BlockHeaderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest* request, ::flow::access::BlockResponse* response, std::function<void(::grpc::Status)>) override;
      void GetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest* request, ::flow::access::BlockResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIDRequest* request, ::flow::access::BlockResponse* response, std::function<void(::grpc::Status)>) override;
      void GetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIDRequest* request, ::flow::access::BlockResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest* request, ::flow::access::BlockResponse* response, std::function<void(::grpc::Status)>) override;
      void GetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest* request, ::flow::access::BlockResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIDRequest* request, ::flow::access::CollectionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIDRequest* request, ::flow::access::CollectionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest* request, ::flow::access::SendTransactionResponse* response, std::function<void(::grpc::Status)>) override;
      void SendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest* request, ::flow::access::SendTransactionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResultResponse* response, std::function<void(::grpc::Status)>) override;
      void GetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResultResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetAccount(::grpc::ClientContext* context, const ::flow::access::GetAccountRequest* request, ::flow::access::GetAccountResponse* response, std::function<void(::grpc::Status)>) override;
      void GetAccount(::grpc::ClientContext* context, const ::flow::access::GetAccountRequest* request, ::flow::access::GetAccountResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest* request, ::flow::access::AccountResponse* response, std::function<void(::grpc::Status)>) override;
      void GetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest* request, ::flow::access::AccountResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest* request, ::flow::access::AccountResponse* response, std::function<void(::grpc::Status)>) override;
      void GetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest* request, ::flow::access::AccountResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest* request, ::flow::access::ExecuteScriptResponse* response, std::function<void(::grpc::Status)>) override;
      void ExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest* request, ::flow::access::ExecuteScriptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIDRequest* request, ::flow::access::ExecuteScriptResponse* response, std::function<void(::grpc::Status)>) override;
      void ExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIDRequest* request, ::flow::access::ExecuteScriptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest* request, ::flow::access::ExecuteScriptResponse* response, std::function<void(::grpc::Status)>) override;
      void ExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest* request, ::flow::access::ExecuteScriptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest* request, ::flow::access::EventsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest* request, ::flow::access::EventsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIDsRequest* request, ::flow::access::EventsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIDsRequest* request, ::flow::access::EventsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest* request, ::flow::access::GetNetworkParametersResponse* response, std::function<void(::grpc::Status)>) override;
      void GetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest* request, ::flow::access::GetNetworkParametersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest* request, ::flow::access::ProtocolStateSnapshotResponse* response, std::function<void(::grpc::Status)>) override;
      void GetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest* request, ::flow::access::ProtocolStateSnapshotResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIDRequest* request, ::flow::access::ExecutionResultForBlockIDResponse* response, std::function<void(::grpc::Status)>) override;
      void GetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIDRequest* request, ::flow::access::ExecutionResultForBlockIDResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::flow::access::PingResponse>* AsyncPingRaw(::grpc::ClientContext* context, const ::flow::access::PingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::PingResponse>* PrepareAsyncPingRaw(::grpc::ClientContext* context, const ::flow::access::PingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>* AsyncGetLatestBlockHeaderRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>* PrepareAsyncGetLatestBlockHeaderRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>* AsyncGetBlockHeaderByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>* PrepareAsyncGetBlockHeaderByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>* AsyncGetBlockHeaderByHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>* PrepareAsyncGetBlockHeaderByHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>* AsyncGetLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>* PrepareAsyncGetLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>* AsyncGetBlockByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>* PrepareAsyncGetBlockByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>* AsyncGetBlockByHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>* PrepareAsyncGetBlockByHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::CollectionResponse>* AsyncGetCollectionByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::CollectionResponse>* PrepareAsyncGetCollectionByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::SendTransactionResponse>* AsyncSendTransactionRaw(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::SendTransactionResponse>* PrepareAsyncSendTransactionRaw(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResponse>* AsyncGetTransactionRaw(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResponse>* PrepareAsyncGetTransactionRaw(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResultResponse>* AsyncGetTransactionResultRaw(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResultResponse>* PrepareAsyncGetTransactionResultRaw(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::GetAccountResponse>* AsyncGetAccountRaw(::grpc::ClientContext* context, const ::flow::access::GetAccountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::GetAccountResponse>* PrepareAsyncGetAccountRaw(::grpc::ClientContext* context, const ::flow::access::GetAccountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>* AsyncGetAccountAtLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>* PrepareAsyncGetAccountAtLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>* AsyncGetAccountAtBlockHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>* PrepareAsyncGetAccountAtBlockHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>* AsyncExecuteScriptAtLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>* PrepareAsyncExecuteScriptAtLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>* AsyncExecuteScriptAtBlockIDRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>* PrepareAsyncExecuteScriptAtBlockIDRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>* AsyncExecuteScriptAtBlockHeightRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>* PrepareAsyncExecuteScriptAtBlockHeightRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>* AsyncGetEventsForHeightRangeRaw(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>* PrepareAsyncGetEventsForHeightRangeRaw(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>* AsyncGetEventsForBlockIDsRaw(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIDsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>* PrepareAsyncGetEventsForBlockIDsRaw(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIDsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::GetNetworkParametersResponse>* AsyncGetNetworkParametersRaw(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::GetNetworkParametersResponse>* PrepareAsyncGetNetworkParametersRaw(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::ProtocolStateSnapshotResponse>* AsyncGetLatestProtocolStateSnapshotRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::ProtocolStateSnapshotResponse>* PrepareAsyncGetLatestProtocolStateSnapshotRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::ExecutionResultForBlockIDResponse>* AsyncGetExecutionResultForBlockIDRaw(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::ExecutionResultForBlockIDResponse>* PrepareAsyncGetExecutionResultForBlockIDRaw(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIDRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Ping_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLatestBlockHeader_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlockHeaderByID_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlockHeaderByHeight_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLatestBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlockByID_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlockByHeight_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCollectionByID_;
    const ::grpc::internal::RpcMethod rpcmethod_SendTransaction_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTransaction_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTransactionResult_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAccount_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAccountAtLatestBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAccountAtBlockHeight_;
    const ::grpc::internal::RpcMethod rpcmethod_ExecuteScriptAtLatestBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_ExecuteScriptAtBlockID_;
    const ::grpc::internal::RpcMethod rpcmethod_ExecuteScriptAtBlockHeight_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEventsForHeightRange_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEventsForBlockIDs_;
    const ::grpc::internal::RpcMethod rpcmethod_GetNetworkParameters_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLatestProtocolStateSnapshot_;
    const ::grpc::internal::RpcMethod rpcmethod_GetExecutionResultForBlockID_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Ping is used to check if the access node is alive and healthy.
    virtual ::grpc::Status Ping(::grpc::ServerContext* context, const ::flow::access::PingRequest* request, ::flow::access::PingResponse* response);
    // Block Headers
    //
    // GetLatestBlockHeader gets the latest sealed or unsealed block header.
    virtual ::grpc::Status GetLatestBlockHeader(::grpc::ServerContext* context, const ::flow::access::GetLatestBlockHeaderRequest* request, ::flow::access::BlockHeaderResponse* response);
    // GetBlockHeaderByID gets a block header by ID.
    virtual ::grpc::Status GetBlockHeaderByID(::grpc::ServerContext* context, const ::flow::access::GetBlockHeaderByIDRequest* request, ::flow::access::BlockHeaderResponse* response);
    // GetBlockHeaderByHeight gets a block header by height.
    virtual ::grpc::Status GetBlockHeaderByHeight(::grpc::ServerContext* context, const ::flow::access::GetBlockHeaderByHeightRequest* request, ::flow::access::BlockHeaderResponse* response);
    // Blocks
    //
    // GetLatestBlock gets the full payload of the latest sealed or unsealed
    // block.
    virtual ::grpc::Status GetLatestBlock(::grpc::ServerContext* context, const ::flow::access::GetLatestBlockRequest* request, ::flow::access::BlockResponse* response);
    // GetBlockByID gets a full block by ID.
    virtual ::grpc::Status GetBlockByID(::grpc::ServerContext* context, const ::flow::access::GetBlockByIDRequest* request, ::flow::access::BlockResponse* response);
    // GetBlockByHeight gets a full block by height.
    virtual ::grpc::Status GetBlockByHeight(::grpc::ServerContext* context, const ::flow::access::GetBlockByHeightRequest* request, ::flow::access::BlockResponse* response);
    // Collections
    //
    // GetCollectionByID gets a collection by ID.
    virtual ::grpc::Status GetCollectionByID(::grpc::ServerContext* context, const ::flow::access::GetCollectionByIDRequest* request, ::flow::access::CollectionResponse* response);
    // Transactions
    //
    // SendTransaction submits a transaction to the network.
    virtual ::grpc::Status SendTransaction(::grpc::ServerContext* context, const ::flow::access::SendTransactionRequest* request, ::flow::access::SendTransactionResponse* response);
    // GetTransaction gets a transaction by ID.
    virtual ::grpc::Status GetTransaction(::grpc::ServerContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResponse* response);
    // GetTransactionResult gets the result of a transaction.
    virtual ::grpc::Status GetTransactionResult(::grpc::ServerContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResultResponse* response);
    // Accounts
    //
    // GetAccount is an alias for GetAccountAtLatestBlock.
    //
    // Warning: this function is deprecated. It behaves identically to
    // GetAccountAtLatestBlock and will be removed in a future version.
    virtual ::grpc::Status GetAccount(::grpc::ServerContext* context, const ::flow::access::GetAccountRequest* request, ::flow::access::GetAccountResponse* response);
    // GetAccountAtLatestBlock gets an account by address from the latest sealed
    // execution state.
    virtual ::grpc::Status GetAccountAtLatestBlock(::grpc::ServerContext* context, const ::flow::access::GetAccountAtLatestBlockRequest* request, ::flow::access::AccountResponse* response);
    // GetAccountAtBlockHeight gets an account by address at the given block
    // height
    virtual ::grpc::Status GetAccountAtBlockHeight(::grpc::ServerContext* context, const ::flow::access::GetAccountAtBlockHeightRequest* request, ::flow::access::AccountResponse* response);
    // Scripts
    //
    // ExecuteScriptAtLatestBlock executes a read-only Cadence script against the
    // latest sealed execution state.
    virtual ::grpc::Status ExecuteScriptAtLatestBlock(::grpc::ServerContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest* request, ::flow::access::ExecuteScriptResponse* response);
    // ExecuteScriptAtBlockID executes a ready-only Cadence script against the
    // execution state at the block with the given ID.
    virtual ::grpc::Status ExecuteScriptAtBlockID(::grpc::ServerContext* context, const ::flow::access::ExecuteScriptAtBlockIDRequest* request, ::flow::access::ExecuteScriptResponse* response);
    // ExecuteScriptAtBlockHeight executes a ready-only Cadence script against the
    // execution state at the given block height.
    virtual ::grpc::Status ExecuteScriptAtBlockHeight(::grpc::ServerContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest* request, ::flow::access::ExecuteScriptResponse* response);
    // Events
    //
    // GetEventsForHeightRange retrieves events emitted within the specified block
    // range.
    virtual ::grpc::Status GetEventsForHeightRange(::grpc::ServerContext* context, const ::flow::access::GetEventsForHeightRangeRequest* request, ::flow::access::EventsResponse* response);
    // GetEventsForBlockIDs retrieves events for the specified block IDs and event
    // type.
    virtual ::grpc::Status GetEventsForBlockIDs(::grpc::ServerContext* context, const ::flow::access::GetEventsForBlockIDsRequest* request, ::flow::access::EventsResponse* response);
    // NetworkParameters
    //
    // GetNetworkParameters retrieves the Flow network details
    virtual ::grpc::Status GetNetworkParameters(::grpc::ServerContext* context, const ::flow::access::GetNetworkParametersRequest* request, ::flow::access::GetNetworkParametersResponse* response);
    // ProtocolState
    //
    // GetLatestProtocolStateSnapshot retrieves the latest sealed protocol state
    // snapshot. Used by Flow nodes joining the network to bootstrap a
    // space-efficient local state.
    virtual ::grpc::Status GetLatestProtocolStateSnapshot(::grpc::ServerContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest* request, ::flow::access::ProtocolStateSnapshotResponse* response);
    // GetExecutionResultForBlockID returns Execution Result for a given block.
    // At present, Access Node might not have execution results for every block
    // and as usual, until sealed, this data can change
    virtual ::grpc::Status GetExecutionResultForBlockID(::grpc::ServerContext* context, const ::flow::access::GetExecutionResultForBlockIDRequest* request, ::flow::access::ExecutionResultForBlockIDResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Ping() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::flow::access::PingRequest* /*request*/, ::flow::access::PingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPing(::grpc::ServerContext* context, ::flow::access::PingRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::PingResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLatestBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLatestBlockHeader() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetLatestBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlockHeader(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockHeaderRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLatestBlockHeader(::grpc::ServerContext* context, ::flow::access::GetLatestBlockHeaderRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::BlockHeaderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlockHeaderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBlockHeaderByID() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetBlockHeaderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByIDRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHeaderByID(::grpc::ServerContext* context, ::flow::access::GetBlockHeaderByIDRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::BlockHeaderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlockHeaderByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBlockHeaderByHeight() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetBlockHeaderByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByHeightRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHeaderByHeight(::grpc::ServerContext* context, ::flow::access::GetBlockHeaderByHeightRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::BlockHeaderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLatestBlock() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLatestBlock(::grpc::ServerContext* context, ::flow::access::GetLatestBlockRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::BlockResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlockByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBlockByID() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetBlockByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByIDRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockByID(::grpc::ServerContext* context, ::flow::access::GetBlockByIDRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::BlockResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlockByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBlockByHeight() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetBlockByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByHeightRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockByHeight(::grpc::ServerContext* context, ::flow::access::GetBlockByHeightRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::BlockResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCollectionByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCollectionByID() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetCollectionByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollectionByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetCollectionByIDRequest* /*request*/, ::flow::access::CollectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCollectionByID(::grpc::ServerContext* context, ::flow::access::GetCollectionByIDRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::CollectionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendTransaction() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_SendTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::SendTransactionRequest* /*request*/, ::flow::access::SendTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendTransaction(::grpc::ServerContext* context, ::flow::access::SendTransactionRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::SendTransactionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTransaction() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTransaction(::grpc::ServerContext* context, ::flow::access::GetTransactionRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::TransactionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTransactionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTransactionResult() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetTransactionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransactionResult(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTransactionResult(::grpc::ServerContext* context, ::flow::access::GetTransactionRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::TransactionResultResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAccount() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccount(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountRequest* /*request*/, ::flow::access::GetAccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAccount(::grpc::ServerContext* context, ::flow::access::GetAccountRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::GetAccountResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAccountAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAccountAtLatestBlock() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_GetAccountAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtLatestBlockRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAccountAtLatestBlock(::grpc::ServerContext* context, ::flow::access::GetAccountAtLatestBlockRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::AccountResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAccountAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAccountAtBlockHeight() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_GetAccountAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtBlockHeightRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAccountAtBlockHeight(::grpc::ServerContext* context, ::flow::access::GetAccountAtBlockHeightRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::AccountResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExecuteScriptAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExecuteScriptAtLatestBlock() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_ExecuteScriptAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtLatestBlockRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteScriptAtLatestBlock(::grpc::ServerContext* context, ::flow::access::ExecuteScriptAtLatestBlockRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::ExecuteScriptResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExecuteScriptAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExecuteScriptAtBlockID() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_ExecuteScriptAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockIDRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteScriptAtBlockID(::grpc::ServerContext* context, ::flow::access::ExecuteScriptAtBlockIDRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::ExecuteScriptResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExecuteScriptAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExecuteScriptAtBlockHeight() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_ExecuteScriptAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockHeightRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteScriptAtBlockHeight(::grpc::ServerContext* context, ::flow::access::ExecuteScriptAtBlockHeightRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::ExecuteScriptResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEventsForHeightRange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEventsForHeightRange() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_GetEventsForHeightRange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForHeightRange(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForHeightRangeRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEventsForHeightRange(::grpc::ServerContext* context, ::flow::access::GetEventsForHeightRangeRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::EventsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEventsForBlockIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEventsForBlockIDs() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_GetEventsForBlockIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForBlockIDs(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForBlockIDsRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEventsForBlockIDs(::grpc::ServerContext* context, ::flow::access::GetEventsForBlockIDsRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::EventsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetNetworkParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetNetworkParameters() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_GetNetworkParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkParameters(::grpc::ServerContext* /*context*/, const ::flow::access::GetNetworkParametersRequest* /*request*/, ::flow::access::GetNetworkParametersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNetworkParameters(::grpc::ServerContext* context, ::flow::access::GetNetworkParametersRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::GetNetworkParametersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLatestProtocolStateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLatestProtocolStateSnapshot() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_GetLatestProtocolStateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestProtocolStateSnapshot(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestProtocolStateSnapshotRequest* /*request*/, ::flow::access::ProtocolStateSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLatestProtocolStateSnapshot(::grpc::ServerContext* context, ::flow::access::GetLatestProtocolStateSnapshotRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::ProtocolStateSnapshotResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetExecutionResultForBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetExecutionResultForBlockID() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_GetExecutionResultForBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecutionResultForBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::GetExecutionResultForBlockIDRequest* /*request*/, ::flow::access::ExecutionResultForBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExecutionResultForBlockID(::grpc::ServerContext* context, ::flow::access::GetExecutionResultForBlockIDRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::ExecutionResultForBlockIDResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Ping<WithAsyncMethod_GetLatestBlockHeader<WithAsyncMethod_GetBlockHeaderByID<WithAsyncMethod_GetBlockHeaderByHeight<WithAsyncMethod_GetLatestBlock<WithAsyncMethod_GetBlockByID<WithAsyncMethod_GetBlockByHeight<WithAsyncMethod_GetCollectionByID<WithAsyncMethod_SendTransaction<WithAsyncMethod_GetTransaction<WithAsyncMethod_GetTransactionResult<WithAsyncMethod_GetAccount<WithAsyncMethod_GetAccountAtLatestBlock<WithAsyncMethod_GetAccountAtBlockHeight<WithAsyncMethod_ExecuteScriptAtLatestBlock<WithAsyncMethod_ExecuteScriptAtBlockID<WithAsyncMethod_ExecuteScriptAtBlockHeight<WithAsyncMethod_GetEventsForHeightRange<WithAsyncMethod_GetEventsForBlockIDs<WithAsyncMethod_GetNetworkParameters<WithAsyncMethod_GetLatestProtocolStateSnapshot<WithAsyncMethod_GetExecutionResultForBlockID<Service > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Ping() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::PingRequest, ::flow::access::PingResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::PingRequest* request, ::flow::access::PingResponse* response) { return this->Ping(context, request, response); }));}
    void SetMessageAllocatorFor_Ping(
        ::grpc::MessageAllocator< ::flow::access::PingRequest, ::flow::access::PingResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::PingRequest, ::flow::access::PingResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::flow::access::PingRequest* /*request*/, ::flow::access::PingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Ping(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::PingRequest* /*request*/, ::flow::access::PingResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetLatestBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetLatestBlockHeader() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetLatestBlockHeaderRequest, ::flow::access::BlockHeaderResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::GetLatestBlockHeaderRequest* request, ::flow::access::BlockHeaderResponse* response) { return this->GetLatestBlockHeader(context, request, response); }));}
    void SetMessageAllocatorFor_GetLatestBlockHeader(
        ::grpc::MessageAllocator< ::flow::access::GetLatestBlockHeaderRequest, ::flow::access::BlockHeaderResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetLatestBlockHeaderRequest, ::flow::access::BlockHeaderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetLatestBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlockHeader(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockHeaderRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLatestBlockHeader(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetLatestBlockHeaderRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetBlockHeaderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetBlockHeaderByID() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetBlockHeaderByIDRequest, ::flow::access::BlockHeaderResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::GetBlockHeaderByIDRequest* request, ::flow::access::BlockHeaderResponse* response) { return this->GetBlockHeaderByID(context, request, response); }));}
    void SetMessageAllocatorFor_GetBlockHeaderByID(
        ::grpc::MessageAllocator< ::flow::access::GetBlockHeaderByIDRequest, ::flow::access::BlockHeaderResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetBlockHeaderByIDRequest, ::flow::access::BlockHeaderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetBlockHeaderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByIDRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBlockHeaderByID(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetBlockHeaderByIDRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetBlockHeaderByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetBlockHeaderByHeight() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetBlockHeaderByHeightRequest, ::flow::access::BlockHeaderResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::GetBlockHeaderByHeightRequest* request, ::flow::access::BlockHeaderResponse* response) { return this->GetBlockHeaderByHeight(context, request, response); }));}
    void SetMessageAllocatorFor_GetBlockHeaderByHeight(
        ::grpc::MessageAllocator< ::flow::access::GetBlockHeaderByHeightRequest, ::flow::access::BlockHeaderResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetBlockHeaderByHeightRequest, ::flow::access::BlockHeaderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetBlockHeaderByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByHeightRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBlockHeaderByHeight(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetBlockHeaderByHeightRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetLatestBlock() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetLatestBlockRequest, ::flow::access::BlockResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::GetLatestBlockRequest* request, ::flow::access::BlockResponse* response) { return this->GetLatestBlock(context, request, response); }));}
    void SetMessageAllocatorFor_GetLatestBlock(
        ::grpc::MessageAllocator< ::flow::access::GetLatestBlockRequest, ::flow::access::BlockResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetLatestBlockRequest, ::flow::access::BlockResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLatestBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetLatestBlockRequest* /*request*/, ::flow::access::BlockResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetBlockByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetBlockByID() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetBlockByIDRequest, ::flow::access::BlockResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::GetBlockByIDRequest* request, ::flow::access::BlockResponse* response) { return this->GetBlockByID(context, request, response); }));}
    void SetMessageAllocatorFor_GetBlockByID(
        ::grpc::MessageAllocator< ::flow::access::GetBlockByIDRequest, ::flow::access::BlockResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetBlockByIDRequest, ::flow::access::BlockResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetBlockByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByIDRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBlockByID(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetBlockByIDRequest* /*request*/, ::flow::access::BlockResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetBlockByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetBlockByHeight() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetBlockByHeightRequest, ::flow::access::BlockResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::GetBlockByHeightRequest* request, ::flow::access::BlockResponse* response) { return this->GetBlockByHeight(context, request, response); }));}
    void SetMessageAllocatorFor_GetBlockByHeight(
        ::grpc::MessageAllocator< ::flow::access::GetBlockByHeightRequest, ::flow::access::BlockResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetBlockByHeightRequest, ::flow::access::BlockResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetBlockByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByHeightRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBlockByHeight(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetBlockByHeightRequest* /*request*/, ::flow::access::BlockResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCollectionByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCollectionByID() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetCollectionByIDRequest, ::flow::access::CollectionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::GetCollectionByIDRequest* request, ::flow::access::CollectionResponse* response) { return this->GetCollectionByID(context, request, response); }));}
    void SetMessageAllocatorFor_GetCollectionByID(
        ::grpc::MessageAllocator< ::flow::access::GetCollectionByIDRequest, ::flow::access::CollectionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetCollectionByIDRequest, ::flow::access::CollectionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCollectionByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollectionByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetCollectionByIDRequest* /*request*/, ::flow::access::CollectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCollectionByID(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetCollectionByIDRequest* /*request*/, ::flow::access::CollectionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SendTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SendTransaction() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::SendTransactionRequest, ::flow::access::SendTransactionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::SendTransactionRequest* request, ::flow::access::SendTransactionResponse* response) { return this->SendTransaction(context, request, response); }));}
    void SetMessageAllocatorFor_SendTransaction(
        ::grpc::MessageAllocator< ::flow::access::SendTransactionRequest, ::flow::access::SendTransactionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::SendTransactionRequest, ::flow::access::SendTransactionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SendTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::SendTransactionRequest* /*request*/, ::flow::access::SendTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendTransaction(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::SendTransactionRequest* /*request*/, ::flow::access::SendTransactionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTransaction() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetTransactionRequest, ::flow::access::TransactionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResponse* response) { return this->GetTransaction(context, request, response); }));}
    void SetMessageAllocatorFor_GetTransaction(
        ::grpc::MessageAllocator< ::flow::access::GetTransactionRequest, ::flow::access::TransactionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetTransactionRequest, ::flow::access::TransactionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTransaction(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTransactionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTransactionResult() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetTransactionRequest, ::flow::access::TransactionResultResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResultResponse* response) { return this->GetTransactionResult(context, request, response); }));}
    void SetMessageAllocatorFor_GetTransactionResult(
        ::grpc::MessageAllocator< ::flow::access::GetTransactionRequest, ::flow::access::TransactionResultResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetTransactionRequest, ::flow::access::TransactionResultResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTransactionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransactionResult(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTransactionResult(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResultResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetAccount() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetAccountRequest, ::flow::access::GetAccountResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::GetAccountRequest* request, ::flow::access::GetAccountResponse* response) { return this->GetAccount(context, request, response); }));}
    void SetMessageAllocatorFor_GetAccount(
        ::grpc::MessageAllocator< ::flow::access::GetAccountRequest, ::flow::access::GetAccountResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetAccountRequest, ::flow::access::GetAccountResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccount(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountRequest* /*request*/, ::flow::access::GetAccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAccount(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetAccountRequest* /*request*/, ::flow::access::GetAccountResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetAccountAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetAccountAtLatestBlock() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetAccountAtLatestBlockRequest, ::flow::access::AccountResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::GetAccountAtLatestBlockRequest* request, ::flow::access::AccountResponse* response) { return this->GetAccountAtLatestBlock(context, request, response); }));}
    void SetMessageAllocatorFor_GetAccountAtLatestBlock(
        ::grpc::MessageAllocator< ::flow::access::GetAccountAtLatestBlockRequest, ::flow::access::AccountResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetAccountAtLatestBlockRequest, ::flow::access::AccountResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetAccountAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtLatestBlockRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAccountAtLatestBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetAccountAtLatestBlockRequest* /*request*/, ::flow::access::AccountResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetAccountAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetAccountAtBlockHeight() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetAccountAtBlockHeightRequest, ::flow::access::AccountResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::GetAccountAtBlockHeightRequest* request, ::flow::access::AccountResponse* response) { return this->GetAccountAtBlockHeight(context, request, response); }));}
    void SetMessageAllocatorFor_GetAccountAtBlockHeight(
        ::grpc::MessageAllocator< ::flow::access::GetAccountAtBlockHeightRequest, ::flow::access::AccountResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetAccountAtBlockHeightRequest, ::flow::access::AccountResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetAccountAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtBlockHeightRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAccountAtBlockHeight(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetAccountAtBlockHeightRequest* /*request*/, ::flow::access::AccountResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ExecuteScriptAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ExecuteScriptAtLatestBlock() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::ExecuteScriptAtLatestBlockRequest, ::flow::access::ExecuteScriptResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest* request, ::flow::access::ExecuteScriptResponse* response) { return this->ExecuteScriptAtLatestBlock(context, request, response); }));}
    void SetMessageAllocatorFor_ExecuteScriptAtLatestBlock(
        ::grpc::MessageAllocator< ::flow::access::ExecuteScriptAtLatestBlockRequest, ::flow::access::ExecuteScriptResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::ExecuteScriptAtLatestBlockRequest, ::flow::access::ExecuteScriptResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ExecuteScriptAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtLatestBlockRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExecuteScriptAtLatestBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::ExecuteScriptAtLatestBlockRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ExecuteScriptAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ExecuteScriptAtBlockID() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::ExecuteScriptAtBlockIDRequest, ::flow::access::ExecuteScriptResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::ExecuteScriptAtBlockIDRequest* request, ::flow::access::ExecuteScriptResponse* response) { return this->ExecuteScriptAtBlockID(context, request, response); }));}
    void SetMessageAllocatorFor_ExecuteScriptAtBlockID(
        ::grpc::MessageAllocator< ::flow::access::ExecuteScriptAtBlockIDRequest, ::flow::access::ExecuteScriptResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::ExecuteScriptAtBlockIDRequest, ::flow::access::ExecuteScriptResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ExecuteScriptAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockIDRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExecuteScriptAtBlockID(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockIDRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ExecuteScriptAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ExecuteScriptAtBlockHeight() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::ExecuteScriptAtBlockHeightRequest, ::flow::access::ExecuteScriptResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest* request, ::flow::access::ExecuteScriptResponse* response) { return this->ExecuteScriptAtBlockHeight(context, request, response); }));}
    void SetMessageAllocatorFor_ExecuteScriptAtBlockHeight(
        ::grpc::MessageAllocator< ::flow::access::ExecuteScriptAtBlockHeightRequest, ::flow::access::ExecuteScriptResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::ExecuteScriptAtBlockHeightRequest, ::flow::access::ExecuteScriptResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ExecuteScriptAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockHeightRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExecuteScriptAtBlockHeight(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockHeightRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetEventsForHeightRange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetEventsForHeightRange() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetEventsForHeightRangeRequest, ::flow::access::EventsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::GetEventsForHeightRangeRequest* request, ::flow::access::EventsResponse* response) { return this->GetEventsForHeightRange(context, request, response); }));}
    void SetMessageAllocatorFor_GetEventsForHeightRange(
        ::grpc::MessageAllocator< ::flow::access::GetEventsForHeightRangeRequest, ::flow::access::EventsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetEventsForHeightRangeRequest, ::flow::access::EventsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetEventsForHeightRange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForHeightRange(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForHeightRangeRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEventsForHeightRange(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetEventsForHeightRangeRequest* /*request*/, ::flow::access::EventsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetEventsForBlockIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetEventsForBlockIDs() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetEventsForBlockIDsRequest, ::flow::access::EventsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::GetEventsForBlockIDsRequest* request, ::flow::access::EventsResponse* response) { return this->GetEventsForBlockIDs(context, request, response); }));}
    void SetMessageAllocatorFor_GetEventsForBlockIDs(
        ::grpc::MessageAllocator< ::flow::access::GetEventsForBlockIDsRequest, ::flow::access::EventsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetEventsForBlockIDsRequest, ::flow::access::EventsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetEventsForBlockIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForBlockIDs(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForBlockIDsRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEventsForBlockIDs(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetEventsForBlockIDsRequest* /*request*/, ::flow::access::EventsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetNetworkParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetNetworkParameters() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetNetworkParametersRequest, ::flow::access::GetNetworkParametersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::GetNetworkParametersRequest* request, ::flow::access::GetNetworkParametersResponse* response) { return this->GetNetworkParameters(context, request, response); }));}
    void SetMessageAllocatorFor_GetNetworkParameters(
        ::grpc::MessageAllocator< ::flow::access::GetNetworkParametersRequest, ::flow::access::GetNetworkParametersResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetNetworkParametersRequest, ::flow::access::GetNetworkParametersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetNetworkParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkParameters(::grpc::ServerContext* /*context*/, const ::flow::access::GetNetworkParametersRequest* /*request*/, ::flow::access::GetNetworkParametersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetNetworkParameters(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetNetworkParametersRequest* /*request*/, ::flow::access::GetNetworkParametersResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetLatestProtocolStateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetLatestProtocolStateSnapshot() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetLatestProtocolStateSnapshotRequest, ::flow::access::ProtocolStateSnapshotResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest* request, ::flow::access::ProtocolStateSnapshotResponse* response) { return this->GetLatestProtocolStateSnapshot(context, request, response); }));}
    void SetMessageAllocatorFor_GetLatestProtocolStateSnapshot(
        ::grpc::MessageAllocator< ::flow::access::GetLatestProtocolStateSnapshotRequest, ::flow::access::ProtocolStateSnapshotResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetLatestProtocolStateSnapshotRequest, ::flow::access::ProtocolStateSnapshotResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetLatestProtocolStateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestProtocolStateSnapshot(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestProtocolStateSnapshotRequest* /*request*/, ::flow::access::ProtocolStateSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLatestProtocolStateSnapshot(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetLatestProtocolStateSnapshotRequest* /*request*/, ::flow::access::ProtocolStateSnapshotResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetExecutionResultForBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetExecutionResultForBlockID() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetExecutionResultForBlockIDRequest, ::flow::access::ExecutionResultForBlockIDResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::access::GetExecutionResultForBlockIDRequest* request, ::flow::access::ExecutionResultForBlockIDResponse* response) { return this->GetExecutionResultForBlockID(context, request, response); }));}
    void SetMessageAllocatorFor_GetExecutionResultForBlockID(
        ::grpc::MessageAllocator< ::flow::access::GetExecutionResultForBlockIDRequest, ::flow::access::ExecutionResultForBlockIDResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetExecutionResultForBlockIDRequest, ::flow::access::ExecutionResultForBlockIDResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetExecutionResultForBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecutionResultForBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::GetExecutionResultForBlockIDRequest* /*request*/, ::flow::access::ExecutionResultForBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetExecutionResultForBlockID(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetExecutionResultForBlockIDRequest* /*request*/, ::flow::access::ExecutionResultForBlockIDResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Ping<WithCallbackMethod_GetLatestBlockHeader<WithCallbackMethod_GetBlockHeaderByID<WithCallbackMethod_GetBlockHeaderByHeight<WithCallbackMethod_GetLatestBlock<WithCallbackMethod_GetBlockByID<WithCallbackMethod_GetBlockByHeight<WithCallbackMethod_GetCollectionByID<WithCallbackMethod_SendTransaction<WithCallbackMethod_GetTransaction<WithCallbackMethod_GetTransactionResult<WithCallbackMethod_GetAccount<WithCallbackMethod_GetAccountAtLatestBlock<WithCallbackMethod_GetAccountAtBlockHeight<WithCallbackMethod_ExecuteScriptAtLatestBlock<WithCallbackMethod_ExecuteScriptAtBlockID<WithCallbackMethod_ExecuteScriptAtBlockHeight<WithCallbackMethod_GetEventsForHeightRange<WithCallbackMethod_GetEventsForBlockIDs<WithCallbackMethod_GetNetworkParameters<WithCallbackMethod_GetLatestProtocolStateSnapshot<WithCallbackMethod_GetExecutionResultForBlockID<Service > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Ping() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::flow::access::PingRequest* /*request*/, ::flow::access::PingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLatestBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLatestBlockHeader() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetLatestBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlockHeader(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockHeaderRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBlockHeaderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBlockHeaderByID() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetBlockHeaderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByIDRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBlockHeaderByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBlockHeaderByHeight() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetBlockHeaderByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByHeightRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLatestBlock() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBlockByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBlockByID() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetBlockByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByIDRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBlockByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBlockByHeight() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetBlockByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByHeightRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCollectionByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCollectionByID() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetCollectionByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollectionByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetCollectionByIDRequest* /*request*/, ::flow::access::CollectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendTransaction() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_SendTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::SendTransactionRequest* /*request*/, ::flow::access::SendTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTransaction() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTransactionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTransactionResult() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetTransactionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransactionResult(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAccount() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccount(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountRequest* /*request*/, ::flow::access::GetAccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAccountAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAccountAtLatestBlock() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_GetAccountAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtLatestBlockRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAccountAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAccountAtBlockHeight() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_GetAccountAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtBlockHeightRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExecuteScriptAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExecuteScriptAtLatestBlock() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_ExecuteScriptAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtLatestBlockRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExecuteScriptAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExecuteScriptAtBlockID() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_ExecuteScriptAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockIDRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExecuteScriptAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExecuteScriptAtBlockHeight() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_ExecuteScriptAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockHeightRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEventsForHeightRange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEventsForHeightRange() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_GetEventsForHeightRange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForHeightRange(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForHeightRangeRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEventsForBlockIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEventsForBlockIDs() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_GetEventsForBlockIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForBlockIDs(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForBlockIDsRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetNetworkParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetNetworkParameters() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_GetNetworkParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkParameters(::grpc::ServerContext* /*context*/, const ::flow::access::GetNetworkParametersRequest* /*request*/, ::flow::access::GetNetworkParametersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLatestProtocolStateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLatestProtocolStateSnapshot() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_GetLatestProtocolStateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestProtocolStateSnapshot(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestProtocolStateSnapshotRequest* /*request*/, ::flow::access::ProtocolStateSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetExecutionResultForBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetExecutionResultForBlockID() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_GetExecutionResultForBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecutionResultForBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::GetExecutionResultForBlockIDRequest* /*request*/, ::flow::access::ExecutionResultForBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Ping() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::flow::access::PingRequest* /*request*/, ::flow::access::PingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPing(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLatestBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLatestBlockHeader() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetLatestBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlockHeader(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockHeaderRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLatestBlockHeader(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlockHeaderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBlockHeaderByID() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetBlockHeaderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByIDRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHeaderByID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlockHeaderByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBlockHeaderByHeight() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetBlockHeaderByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByHeightRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHeaderByHeight(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLatestBlock() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLatestBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlockByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBlockByID() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetBlockByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByIDRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockByID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlockByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBlockByHeight() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetBlockByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByHeightRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockByHeight(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCollectionByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCollectionByID() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetCollectionByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollectionByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetCollectionByIDRequest* /*request*/, ::flow::access::CollectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCollectionByID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendTransaction() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_SendTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::SendTransactionRequest* /*request*/, ::flow::access::SendTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendTransaction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTransaction() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTransaction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTransactionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTransactionResult() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetTransactionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransactionResult(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTransactionResult(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAccount() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccount(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountRequest* /*request*/, ::flow::access::GetAccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAccount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAccountAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAccountAtLatestBlock() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_GetAccountAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtLatestBlockRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAccountAtLatestBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAccountAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAccountAtBlockHeight() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_GetAccountAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtBlockHeightRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAccountAtBlockHeight(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExecuteScriptAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExecuteScriptAtLatestBlock() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_ExecuteScriptAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtLatestBlockRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteScriptAtLatestBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExecuteScriptAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExecuteScriptAtBlockID() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_ExecuteScriptAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockIDRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteScriptAtBlockID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExecuteScriptAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExecuteScriptAtBlockHeight() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_ExecuteScriptAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockHeightRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteScriptAtBlockHeight(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEventsForHeightRange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEventsForHeightRange() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_GetEventsForHeightRange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForHeightRange(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForHeightRangeRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEventsForHeightRange(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEventsForBlockIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEventsForBlockIDs() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_GetEventsForBlockIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForBlockIDs(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForBlockIDsRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEventsForBlockIDs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetNetworkParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetNetworkParameters() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_GetNetworkParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkParameters(::grpc::ServerContext* /*context*/, const ::flow::access::GetNetworkParametersRequest* /*request*/, ::flow::access::GetNetworkParametersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNetworkParameters(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLatestProtocolStateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLatestProtocolStateSnapshot() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_GetLatestProtocolStateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestProtocolStateSnapshot(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestProtocolStateSnapshotRequest* /*request*/, ::flow::access::ProtocolStateSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLatestProtocolStateSnapshot(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetExecutionResultForBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetExecutionResultForBlockID() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_GetExecutionResultForBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecutionResultForBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::GetExecutionResultForBlockIDRequest* /*request*/, ::flow::access::ExecutionResultForBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExecutionResultForBlockID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Ping() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Ping(context, request, response); }));
    }
    ~WithRawCallbackMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::flow::access::PingRequest* /*request*/, ::flow::access::PingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Ping(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetLatestBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetLatestBlockHeader() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLatestBlockHeader(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetLatestBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlockHeader(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockHeaderRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLatestBlockHeader(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetBlockHeaderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetBlockHeaderByID() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBlockHeaderByID(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetBlockHeaderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByIDRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBlockHeaderByID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetBlockHeaderByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetBlockHeaderByHeight() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBlockHeaderByHeight(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetBlockHeaderByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByHeightRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBlockHeaderByHeight(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetLatestBlock() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLatestBlock(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLatestBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetBlockByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetBlockByID() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBlockByID(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetBlockByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByIDRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBlockByID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetBlockByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetBlockByHeight() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBlockByHeight(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetBlockByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByHeightRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBlockByHeight(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCollectionByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCollectionByID() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCollectionByID(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCollectionByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollectionByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetCollectionByIDRequest* /*request*/, ::flow::access::CollectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCollectionByID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SendTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SendTransaction() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendTransaction(context, request, response); }));
    }
    ~WithRawCallbackMethod_SendTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::SendTransactionRequest* /*request*/, ::flow::access::SendTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendTransaction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTransaction() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTransaction(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTransaction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTransactionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTransactionResult() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTransactionResult(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTransactionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransactionResult(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTransactionResult(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetAccount() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAccount(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccount(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountRequest* /*request*/, ::flow::access::GetAccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAccount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetAccountAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetAccountAtLatestBlock() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAccountAtLatestBlock(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetAccountAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtLatestBlockRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAccountAtLatestBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetAccountAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetAccountAtBlockHeight() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAccountAtBlockHeight(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetAccountAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtBlockHeightRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAccountAtBlockHeight(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ExecuteScriptAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ExecuteScriptAtLatestBlock() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExecuteScriptAtLatestBlock(context, request, response); }));
    }
    ~WithRawCallbackMethod_ExecuteScriptAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtLatestBlockRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExecuteScriptAtLatestBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ExecuteScriptAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ExecuteScriptAtBlockID() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExecuteScriptAtBlockID(context, request, response); }));
    }
    ~WithRawCallbackMethod_ExecuteScriptAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockIDRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExecuteScriptAtBlockID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ExecuteScriptAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ExecuteScriptAtBlockHeight() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExecuteScriptAtBlockHeight(context, request, response); }));
    }
    ~WithRawCallbackMethod_ExecuteScriptAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockHeightRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExecuteScriptAtBlockHeight(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetEventsForHeightRange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetEventsForHeightRange() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEventsForHeightRange(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetEventsForHeightRange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForHeightRange(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForHeightRangeRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEventsForHeightRange(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetEventsForBlockIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetEventsForBlockIDs() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEventsForBlockIDs(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetEventsForBlockIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForBlockIDs(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForBlockIDsRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEventsForBlockIDs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetNetworkParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetNetworkParameters() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetNetworkParameters(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetNetworkParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkParameters(::grpc::ServerContext* /*context*/, const ::flow::access::GetNetworkParametersRequest* /*request*/, ::flow::access::GetNetworkParametersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetNetworkParameters(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetLatestProtocolStateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetLatestProtocolStateSnapshot() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLatestProtocolStateSnapshot(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetLatestProtocolStateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestProtocolStateSnapshot(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestProtocolStateSnapshotRequest* /*request*/, ::flow::access::ProtocolStateSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLatestProtocolStateSnapshot(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetExecutionResultForBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetExecutionResultForBlockID() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetExecutionResultForBlockID(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetExecutionResultForBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecutionResultForBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::GetExecutionResultForBlockIDRequest* /*request*/, ::flow::access::ExecutionResultForBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetExecutionResultForBlockID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Ping() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::PingRequest, ::flow::access::PingResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::PingRequest, ::flow::access::PingResponse>* streamer) {
                       return this->StreamedPing(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::flow::access::PingRequest* /*request*/, ::flow::access::PingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPing(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::PingRequest,::flow::access::PingResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLatestBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLatestBlockHeader() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetLatestBlockHeaderRequest, ::flow::access::BlockHeaderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetLatestBlockHeaderRequest, ::flow::access::BlockHeaderResponse>* streamer) {
                       return this->StreamedGetLatestBlockHeader(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetLatestBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLatestBlockHeader(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockHeaderRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLatestBlockHeader(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetLatestBlockHeaderRequest,::flow::access::BlockHeaderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlockHeaderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBlockHeaderByID() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetBlockHeaderByIDRequest, ::flow::access::BlockHeaderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetBlockHeaderByIDRequest, ::flow::access::BlockHeaderResponse>* streamer) {
                       return this->StreamedGetBlockHeaderByID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBlockHeaderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlockHeaderByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByIDRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlockHeaderByID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetBlockHeaderByIDRequest,::flow::access::BlockHeaderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlockHeaderByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBlockHeaderByHeight() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetBlockHeaderByHeightRequest, ::flow::access::BlockHeaderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetBlockHeaderByHeightRequest, ::flow::access::BlockHeaderResponse>* streamer) {
                       return this->StreamedGetBlockHeaderByHeight(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBlockHeaderByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlockHeaderByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByHeightRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlockHeaderByHeight(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetBlockHeaderByHeightRequest,::flow::access::BlockHeaderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLatestBlock() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetLatestBlockRequest, ::flow::access::BlockResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetLatestBlockRequest, ::flow::access::BlockResponse>* streamer) {
                       return this->StreamedGetLatestBlock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLatestBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetLatestBlockRequest,::flow::access::BlockResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlockByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBlockByID() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetBlockByIDRequest, ::flow::access::BlockResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetBlockByIDRequest, ::flow::access::BlockResponse>* streamer) {
                       return this->StreamedGetBlockByID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBlockByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlockByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByIDRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlockByID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetBlockByIDRequest,::flow::access::BlockResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlockByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBlockByHeight() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetBlockByHeightRequest, ::flow::access::BlockResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetBlockByHeightRequest, ::flow::access::BlockResponse>* streamer) {
                       return this->StreamedGetBlockByHeight(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBlockByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlockByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByHeightRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlockByHeight(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetBlockByHeightRequest,::flow::access::BlockResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCollectionByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCollectionByID() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetCollectionByIDRequest, ::flow::access::CollectionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetCollectionByIDRequest, ::flow::access::CollectionResponse>* streamer) {
                       return this->StreamedGetCollectionByID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCollectionByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCollectionByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetCollectionByIDRequest* /*request*/, ::flow::access::CollectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCollectionByID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetCollectionByIDRequest,::flow::access::CollectionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendTransaction() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::SendTransactionRequest, ::flow::access::SendTransactionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::SendTransactionRequest, ::flow::access::SendTransactionResponse>* streamer) {
                       return this->StreamedSendTransaction(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::SendTransactionRequest* /*request*/, ::flow::access::SendTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendTransaction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::SendTransactionRequest,::flow::access::SendTransactionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTransaction() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetTransactionRequest, ::flow::access::TransactionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetTransactionRequest, ::flow::access::TransactionResponse>* streamer) {
                       return this->StreamedGetTransaction(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTransaction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetTransactionRequest,::flow::access::TransactionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTransactionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTransactionResult() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetTransactionRequest, ::flow::access::TransactionResultResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetTransactionRequest, ::flow::access::TransactionResultResponse>* streamer) {
                       return this->StreamedGetTransactionResult(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTransactionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTransactionResult(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTransactionResult(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetTransactionRequest,::flow::access::TransactionResultResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAccount() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetAccountRequest, ::flow::access::GetAccountResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetAccountRequest, ::flow::access::GetAccountResponse>* streamer) {
                       return this->StreamedGetAccount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAccount(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountRequest* /*request*/, ::flow::access::GetAccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAccount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetAccountRequest,::flow::access::GetAccountResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAccountAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAccountAtLatestBlock() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetAccountAtLatestBlockRequest, ::flow::access::AccountResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetAccountAtLatestBlockRequest, ::flow::access::AccountResponse>* streamer) {
                       return this->StreamedGetAccountAtLatestBlock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAccountAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAccountAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtLatestBlockRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAccountAtLatestBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetAccountAtLatestBlockRequest,::flow::access::AccountResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAccountAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAccountAtBlockHeight() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetAccountAtBlockHeightRequest, ::flow::access::AccountResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetAccountAtBlockHeightRequest, ::flow::access::AccountResponse>* streamer) {
                       return this->StreamedGetAccountAtBlockHeight(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAccountAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAccountAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtBlockHeightRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAccountAtBlockHeight(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetAccountAtBlockHeightRequest,::flow::access::AccountResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExecuteScriptAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ExecuteScriptAtLatestBlock() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::ExecuteScriptAtLatestBlockRequest, ::flow::access::ExecuteScriptResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::ExecuteScriptAtLatestBlockRequest, ::flow::access::ExecuteScriptResponse>* streamer) {
                       return this->StreamedExecuteScriptAtLatestBlock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ExecuteScriptAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExecuteScriptAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtLatestBlockRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExecuteScriptAtLatestBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::ExecuteScriptAtLatestBlockRequest,::flow::access::ExecuteScriptResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExecuteScriptAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ExecuteScriptAtBlockID() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::ExecuteScriptAtBlockIDRequest, ::flow::access::ExecuteScriptResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::ExecuteScriptAtBlockIDRequest, ::flow::access::ExecuteScriptResponse>* streamer) {
                       return this->StreamedExecuteScriptAtBlockID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ExecuteScriptAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExecuteScriptAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockIDRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExecuteScriptAtBlockID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::ExecuteScriptAtBlockIDRequest,::flow::access::ExecuteScriptResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExecuteScriptAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ExecuteScriptAtBlockHeight() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::ExecuteScriptAtBlockHeightRequest, ::flow::access::ExecuteScriptResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::ExecuteScriptAtBlockHeightRequest, ::flow::access::ExecuteScriptResponse>* streamer) {
                       return this->StreamedExecuteScriptAtBlockHeight(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ExecuteScriptAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExecuteScriptAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockHeightRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExecuteScriptAtBlockHeight(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::ExecuteScriptAtBlockHeightRequest,::flow::access::ExecuteScriptResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEventsForHeightRange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEventsForHeightRange() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetEventsForHeightRangeRequest, ::flow::access::EventsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetEventsForHeightRangeRequest, ::flow::access::EventsResponse>* streamer) {
                       return this->StreamedGetEventsForHeightRange(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetEventsForHeightRange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEventsForHeightRange(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForHeightRangeRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEventsForHeightRange(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetEventsForHeightRangeRequest,::flow::access::EventsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEventsForBlockIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEventsForBlockIDs() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetEventsForBlockIDsRequest, ::flow::access::EventsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetEventsForBlockIDsRequest, ::flow::access::EventsResponse>* streamer) {
                       return this->StreamedGetEventsForBlockIDs(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetEventsForBlockIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEventsForBlockIDs(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForBlockIDsRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEventsForBlockIDs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetEventsForBlockIDsRequest,::flow::access::EventsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetNetworkParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetNetworkParameters() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetNetworkParametersRequest, ::flow::access::GetNetworkParametersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetNetworkParametersRequest, ::flow::access::GetNetworkParametersResponse>* streamer) {
                       return this->StreamedGetNetworkParameters(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetNetworkParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetNetworkParameters(::grpc::ServerContext* /*context*/, const ::flow::access::GetNetworkParametersRequest* /*request*/, ::flow::access::GetNetworkParametersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetNetworkParameters(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetNetworkParametersRequest,::flow::access::GetNetworkParametersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLatestProtocolStateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLatestProtocolStateSnapshot() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetLatestProtocolStateSnapshotRequest, ::flow::access::ProtocolStateSnapshotResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetLatestProtocolStateSnapshotRequest, ::flow::access::ProtocolStateSnapshotResponse>* streamer) {
                       return this->StreamedGetLatestProtocolStateSnapshot(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetLatestProtocolStateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLatestProtocolStateSnapshot(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestProtocolStateSnapshotRequest* /*request*/, ::flow::access::ProtocolStateSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLatestProtocolStateSnapshot(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetLatestProtocolStateSnapshotRequest,::flow::access::ProtocolStateSnapshotResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetExecutionResultForBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetExecutionResultForBlockID() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetExecutionResultForBlockIDRequest, ::flow::access::ExecutionResultForBlockIDResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetExecutionResultForBlockIDRequest, ::flow::access::ExecutionResultForBlockIDResponse>* streamer) {
                       return this->StreamedGetExecutionResultForBlockID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetExecutionResultForBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetExecutionResultForBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::GetExecutionResultForBlockIDRequest* /*request*/, ::flow::access::ExecutionResultForBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetExecutionResultForBlockID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetExecutionResultForBlockIDRequest,::flow::access::ExecutionResultForBlockIDResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Ping<WithStreamedUnaryMethod_GetLatestBlockHeader<WithStreamedUnaryMethod_GetBlockHeaderByID<WithStreamedUnaryMethod_GetBlockHeaderByHeight<WithStreamedUnaryMethod_GetLatestBlock<WithStreamedUnaryMethod_GetBlockByID<WithStreamedUnaryMethod_GetBlockByHeight<WithStreamedUnaryMethod_GetCollectionByID<WithStreamedUnaryMethod_SendTransaction<WithStreamedUnaryMethod_GetTransaction<WithStreamedUnaryMethod_GetTransactionResult<WithStreamedUnaryMethod_GetAccount<WithStreamedUnaryMethod_GetAccountAtLatestBlock<WithStreamedUnaryMethod_GetAccountAtBlockHeight<WithStreamedUnaryMethod_ExecuteScriptAtLatestBlock<WithStreamedUnaryMethod_ExecuteScriptAtBlockID<WithStreamedUnaryMethod_ExecuteScriptAtBlockHeight<WithStreamedUnaryMethod_GetEventsForHeightRange<WithStreamedUnaryMethod_GetEventsForBlockIDs<WithStreamedUnaryMethod_GetNetworkParameters<WithStreamedUnaryMethod_GetLatestProtocolStateSnapshot<WithStreamedUnaryMethod_GetExecutionResultForBlockID<Service > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Ping<WithStreamedUnaryMethod_GetLatestBlockHeader<WithStreamedUnaryMethod_GetBlockHeaderByID<WithStreamedUnaryMethod_GetBlockHeaderByHeight<WithStreamedUnaryMethod_GetLatestBlock<WithStreamedUnaryMethod_GetBlockByID<WithStreamedUnaryMethod_GetBlockByHeight<WithStreamedUnaryMethod_GetCollectionByID<WithStreamedUnaryMethod_SendTransaction<WithStreamedUnaryMethod_GetTransaction<WithStreamedUnaryMethod_GetTransactionResult<WithStreamedUnaryMethod_GetAccount<WithStreamedUnaryMethod_GetAccountAtLatestBlock<WithStreamedUnaryMethod_GetAccountAtBlockHeight<WithStreamedUnaryMethod_ExecuteScriptAtLatestBlock<WithStreamedUnaryMethod_ExecuteScriptAtBlockID<WithStreamedUnaryMethod_ExecuteScriptAtBlockHeight<WithStreamedUnaryMethod_GetEventsForHeightRange<WithStreamedUnaryMethod_GetEventsForBlockIDs<WithStreamedUnaryMethod_GetNetworkParameters<WithStreamedUnaryMethod_GetLatestProtocolStateSnapshot<WithStreamedUnaryMethod_GetExecutionResultForBlockID<Service > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace access
}  // namespace flow


#endif  // GRPC_flow_2faccess_2faccess_2eproto__INCLUDED
