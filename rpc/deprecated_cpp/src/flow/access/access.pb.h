// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flow/access/access.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_flow_2faccess_2faccess_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_flow_2faccess_2faccess_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "flow/entities/account.pb.h"
#include "flow/entities/block_header.pb.h"
#include "flow/entities/block.pb.h"
#include "flow/entities/collection.pb.h"
#include "flow/entities/event.pb.h"
#include "flow/entities/execution_result.pb.h"
#include "flow/entities/transaction.pb.h"
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flow_2faccess_2faccess_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_flow_2faccess_2faccess_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[36]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_flow_2faccess_2faccess_2eproto;
namespace flow {
namespace access {
class AccountResponse;
struct AccountResponseDefaultTypeInternal;
extern AccountResponseDefaultTypeInternal _AccountResponse_default_instance_;
class BlockHeaderResponse;
struct BlockHeaderResponseDefaultTypeInternal;
extern BlockHeaderResponseDefaultTypeInternal _BlockHeaderResponse_default_instance_;
class BlockResponse;
struct BlockResponseDefaultTypeInternal;
extern BlockResponseDefaultTypeInternal _BlockResponse_default_instance_;
class CollectionResponse;
struct CollectionResponseDefaultTypeInternal;
extern CollectionResponseDefaultTypeInternal _CollectionResponse_default_instance_;
class EventsResponse;
struct EventsResponseDefaultTypeInternal;
extern EventsResponseDefaultTypeInternal _EventsResponse_default_instance_;
class EventsResponse_Result;
struct EventsResponse_ResultDefaultTypeInternal;
extern EventsResponse_ResultDefaultTypeInternal _EventsResponse_Result_default_instance_;
class ExecuteScriptAtBlockHeightRequest;
struct ExecuteScriptAtBlockHeightRequestDefaultTypeInternal;
extern ExecuteScriptAtBlockHeightRequestDefaultTypeInternal _ExecuteScriptAtBlockHeightRequest_default_instance_;
class ExecuteScriptAtBlockIDRequest;
struct ExecuteScriptAtBlockIDRequestDefaultTypeInternal;
extern ExecuteScriptAtBlockIDRequestDefaultTypeInternal _ExecuteScriptAtBlockIDRequest_default_instance_;
class ExecuteScriptAtLatestBlockRequest;
struct ExecuteScriptAtLatestBlockRequestDefaultTypeInternal;
extern ExecuteScriptAtLatestBlockRequestDefaultTypeInternal _ExecuteScriptAtLatestBlockRequest_default_instance_;
class ExecuteScriptResponse;
struct ExecuteScriptResponseDefaultTypeInternal;
extern ExecuteScriptResponseDefaultTypeInternal _ExecuteScriptResponse_default_instance_;
class ExecutionResultForBlockIDResponse;
struct ExecutionResultForBlockIDResponseDefaultTypeInternal;
extern ExecutionResultForBlockIDResponseDefaultTypeInternal _ExecutionResultForBlockIDResponse_default_instance_;
class GetAccountAtBlockHeightRequest;
struct GetAccountAtBlockHeightRequestDefaultTypeInternal;
extern GetAccountAtBlockHeightRequestDefaultTypeInternal _GetAccountAtBlockHeightRequest_default_instance_;
class GetAccountAtLatestBlockRequest;
struct GetAccountAtLatestBlockRequestDefaultTypeInternal;
extern GetAccountAtLatestBlockRequestDefaultTypeInternal _GetAccountAtLatestBlockRequest_default_instance_;
class GetAccountRequest;
struct GetAccountRequestDefaultTypeInternal;
extern GetAccountRequestDefaultTypeInternal _GetAccountRequest_default_instance_;
class GetAccountResponse;
struct GetAccountResponseDefaultTypeInternal;
extern GetAccountResponseDefaultTypeInternal _GetAccountResponse_default_instance_;
class GetBlockByHeightRequest;
struct GetBlockByHeightRequestDefaultTypeInternal;
extern GetBlockByHeightRequestDefaultTypeInternal _GetBlockByHeightRequest_default_instance_;
class GetBlockByIDRequest;
struct GetBlockByIDRequestDefaultTypeInternal;
extern GetBlockByIDRequestDefaultTypeInternal _GetBlockByIDRequest_default_instance_;
class GetBlockHeaderByHeightRequest;
struct GetBlockHeaderByHeightRequestDefaultTypeInternal;
extern GetBlockHeaderByHeightRequestDefaultTypeInternal _GetBlockHeaderByHeightRequest_default_instance_;
class GetBlockHeaderByIDRequest;
struct GetBlockHeaderByIDRequestDefaultTypeInternal;
extern GetBlockHeaderByIDRequestDefaultTypeInternal _GetBlockHeaderByIDRequest_default_instance_;
class GetCollectionByIDRequest;
struct GetCollectionByIDRequestDefaultTypeInternal;
extern GetCollectionByIDRequestDefaultTypeInternal _GetCollectionByIDRequest_default_instance_;
class GetEventsForBlockIDsRequest;
struct GetEventsForBlockIDsRequestDefaultTypeInternal;
extern GetEventsForBlockIDsRequestDefaultTypeInternal _GetEventsForBlockIDsRequest_default_instance_;
class GetEventsForHeightRangeRequest;
struct GetEventsForHeightRangeRequestDefaultTypeInternal;
extern GetEventsForHeightRangeRequestDefaultTypeInternal _GetEventsForHeightRangeRequest_default_instance_;
class GetExecutionResultForBlockIDRequest;
struct GetExecutionResultForBlockIDRequestDefaultTypeInternal;
extern GetExecutionResultForBlockIDRequestDefaultTypeInternal _GetExecutionResultForBlockIDRequest_default_instance_;
class GetLatestBlockHeaderRequest;
struct GetLatestBlockHeaderRequestDefaultTypeInternal;
extern GetLatestBlockHeaderRequestDefaultTypeInternal _GetLatestBlockHeaderRequest_default_instance_;
class GetLatestBlockRequest;
struct GetLatestBlockRequestDefaultTypeInternal;
extern GetLatestBlockRequestDefaultTypeInternal _GetLatestBlockRequest_default_instance_;
class GetLatestProtocolStateSnapshotRequest;
struct GetLatestProtocolStateSnapshotRequestDefaultTypeInternal;
extern GetLatestProtocolStateSnapshotRequestDefaultTypeInternal _GetLatestProtocolStateSnapshotRequest_default_instance_;
class GetNetworkParametersRequest;
struct GetNetworkParametersRequestDefaultTypeInternal;
extern GetNetworkParametersRequestDefaultTypeInternal _GetNetworkParametersRequest_default_instance_;
class GetNetworkParametersResponse;
struct GetNetworkParametersResponseDefaultTypeInternal;
extern GetNetworkParametersResponseDefaultTypeInternal _GetNetworkParametersResponse_default_instance_;
class GetTransactionRequest;
struct GetTransactionRequestDefaultTypeInternal;
extern GetTransactionRequestDefaultTypeInternal _GetTransactionRequest_default_instance_;
class PingRequest;
struct PingRequestDefaultTypeInternal;
extern PingRequestDefaultTypeInternal _PingRequest_default_instance_;
class PingResponse;
struct PingResponseDefaultTypeInternal;
extern PingResponseDefaultTypeInternal _PingResponse_default_instance_;
class ProtocolStateSnapshotResponse;
struct ProtocolStateSnapshotResponseDefaultTypeInternal;
extern ProtocolStateSnapshotResponseDefaultTypeInternal _ProtocolStateSnapshotResponse_default_instance_;
class SendTransactionRequest;
struct SendTransactionRequestDefaultTypeInternal;
extern SendTransactionRequestDefaultTypeInternal _SendTransactionRequest_default_instance_;
class SendTransactionResponse;
struct SendTransactionResponseDefaultTypeInternal;
extern SendTransactionResponseDefaultTypeInternal _SendTransactionResponse_default_instance_;
class TransactionResponse;
struct TransactionResponseDefaultTypeInternal;
extern TransactionResponseDefaultTypeInternal _TransactionResponse_default_instance_;
class TransactionResultResponse;
struct TransactionResultResponseDefaultTypeInternal;
extern TransactionResultResponseDefaultTypeInternal _TransactionResultResponse_default_instance_;
}  // namespace access
}  // namespace flow
PROTOBUF_NAMESPACE_OPEN
template<> ::flow::access::AccountResponse* Arena::CreateMaybeMessage<::flow::access::AccountResponse>(Arena*);
template<> ::flow::access::BlockHeaderResponse* Arena::CreateMaybeMessage<::flow::access::BlockHeaderResponse>(Arena*);
template<> ::flow::access::BlockResponse* Arena::CreateMaybeMessage<::flow::access::BlockResponse>(Arena*);
template<> ::flow::access::CollectionResponse* Arena::CreateMaybeMessage<::flow::access::CollectionResponse>(Arena*);
template<> ::flow::access::EventsResponse* Arena::CreateMaybeMessage<::flow::access::EventsResponse>(Arena*);
template<> ::flow::access::EventsResponse_Result* Arena::CreateMaybeMessage<::flow::access::EventsResponse_Result>(Arena*);
template<> ::flow::access::ExecuteScriptAtBlockHeightRequest* Arena::CreateMaybeMessage<::flow::access::ExecuteScriptAtBlockHeightRequest>(Arena*);
template<> ::flow::access::ExecuteScriptAtBlockIDRequest* Arena::CreateMaybeMessage<::flow::access::ExecuteScriptAtBlockIDRequest>(Arena*);
template<> ::flow::access::ExecuteScriptAtLatestBlockRequest* Arena::CreateMaybeMessage<::flow::access::ExecuteScriptAtLatestBlockRequest>(Arena*);
template<> ::flow::access::ExecuteScriptResponse* Arena::CreateMaybeMessage<::flow::access::ExecuteScriptResponse>(Arena*);
template<> ::flow::access::ExecutionResultForBlockIDResponse* Arena::CreateMaybeMessage<::flow::access::ExecutionResultForBlockIDResponse>(Arena*);
template<> ::flow::access::GetAccountAtBlockHeightRequest* Arena::CreateMaybeMessage<::flow::access::GetAccountAtBlockHeightRequest>(Arena*);
template<> ::flow::access::GetAccountAtLatestBlockRequest* Arena::CreateMaybeMessage<::flow::access::GetAccountAtLatestBlockRequest>(Arena*);
template<> ::flow::access::GetAccountRequest* Arena::CreateMaybeMessage<::flow::access::GetAccountRequest>(Arena*);
template<> ::flow::access::GetAccountResponse* Arena::CreateMaybeMessage<::flow::access::GetAccountResponse>(Arena*);
template<> ::flow::access::GetBlockByHeightRequest* Arena::CreateMaybeMessage<::flow::access::GetBlockByHeightRequest>(Arena*);
template<> ::flow::access::GetBlockByIDRequest* Arena::CreateMaybeMessage<::flow::access::GetBlockByIDRequest>(Arena*);
template<> ::flow::access::GetBlockHeaderByHeightRequest* Arena::CreateMaybeMessage<::flow::access::GetBlockHeaderByHeightRequest>(Arena*);
template<> ::flow::access::GetBlockHeaderByIDRequest* Arena::CreateMaybeMessage<::flow::access::GetBlockHeaderByIDRequest>(Arena*);
template<> ::flow::access::GetCollectionByIDRequest* Arena::CreateMaybeMessage<::flow::access::GetCollectionByIDRequest>(Arena*);
template<> ::flow::access::GetEventsForBlockIDsRequest* Arena::CreateMaybeMessage<::flow::access::GetEventsForBlockIDsRequest>(Arena*);
template<> ::flow::access::GetEventsForHeightRangeRequest* Arena::CreateMaybeMessage<::flow::access::GetEventsForHeightRangeRequest>(Arena*);
template<> ::flow::access::GetExecutionResultForBlockIDRequest* Arena::CreateMaybeMessage<::flow::access::GetExecutionResultForBlockIDRequest>(Arena*);
template<> ::flow::access::GetLatestBlockHeaderRequest* Arena::CreateMaybeMessage<::flow::access::GetLatestBlockHeaderRequest>(Arena*);
template<> ::flow::access::GetLatestBlockRequest* Arena::CreateMaybeMessage<::flow::access::GetLatestBlockRequest>(Arena*);
template<> ::flow::access::GetLatestProtocolStateSnapshotRequest* Arena::CreateMaybeMessage<::flow::access::GetLatestProtocolStateSnapshotRequest>(Arena*);
template<> ::flow::access::GetNetworkParametersRequest* Arena::CreateMaybeMessage<::flow::access::GetNetworkParametersRequest>(Arena*);
template<> ::flow::access::GetNetworkParametersResponse* Arena::CreateMaybeMessage<::flow::access::GetNetworkParametersResponse>(Arena*);
template<> ::flow::access::GetTransactionRequest* Arena::CreateMaybeMessage<::flow::access::GetTransactionRequest>(Arena*);
template<> ::flow::access::PingRequest* Arena::CreateMaybeMessage<::flow::access::PingRequest>(Arena*);
template<> ::flow::access::PingResponse* Arena::CreateMaybeMessage<::flow::access::PingResponse>(Arena*);
template<> ::flow::access::ProtocolStateSnapshotResponse* Arena::CreateMaybeMessage<::flow::access::ProtocolStateSnapshotResponse>(Arena*);
template<> ::flow::access::SendTransactionRequest* Arena::CreateMaybeMessage<::flow::access::SendTransactionRequest>(Arena*);
template<> ::flow::access::SendTransactionResponse* Arena::CreateMaybeMessage<::flow::access::SendTransactionResponse>(Arena*);
template<> ::flow::access::TransactionResponse* Arena::CreateMaybeMessage<::flow::access::TransactionResponse>(Arena*);
template<> ::flow::access::TransactionResultResponse* Arena::CreateMaybeMessage<::flow::access::TransactionResultResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace flow {
namespace access {

// ===================================================================

class PingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:flow.access.PingRequest) */ {
 public:
  inline PingRequest() : PingRequest(nullptr) {}
  explicit constexpr PingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingRequest(const PingRequest& from);
  PingRequest(PingRequest&& from) noexcept
    : PingRequest() {
    *this = ::std::move(from);
  }

  inline PingRequest& operator=(const PingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingRequest& operator=(PingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingRequest* internal_default_instance() {
    return reinterpret_cast<const PingRequest*>(
               &_PingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PingRequest& a, PingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PingRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PingRequest* New() const final {
    return new PingRequest();
  }

  PingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PingRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PingRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.PingRequest";
  }
  protected:
  explicit PingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flow.access.PingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class PingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:flow.access.PingResponse) */ {
 public:
  inline PingResponse() : PingResponse(nullptr) {}
  explicit constexpr PingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingResponse(const PingResponse& from);
  PingResponse(PingResponse&& from) noexcept
    : PingResponse() {
    *this = ::std::move(from);
  }

  inline PingResponse& operator=(const PingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingResponse& operator=(PingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingResponse* internal_default_instance() {
    return reinterpret_cast<const PingResponse*>(
               &_PingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PingResponse& a, PingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PingResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PingResponse* New() const final {
    return new PingResponse();
  }

  PingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PingResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PingResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.PingResponse";
  }
  protected:
  explicit PingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flow.access.PingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class GetLatestBlockHeaderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetLatestBlockHeaderRequest) */ {
 public:
  inline GetLatestBlockHeaderRequest() : GetLatestBlockHeaderRequest(nullptr) {}
  ~GetLatestBlockHeaderRequest() override;
  explicit constexpr GetLatestBlockHeaderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLatestBlockHeaderRequest(const GetLatestBlockHeaderRequest& from);
  GetLatestBlockHeaderRequest(GetLatestBlockHeaderRequest&& from) noexcept
    : GetLatestBlockHeaderRequest() {
    *this = ::std::move(from);
  }

  inline GetLatestBlockHeaderRequest& operator=(const GetLatestBlockHeaderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLatestBlockHeaderRequest& operator=(GetLatestBlockHeaderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLatestBlockHeaderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLatestBlockHeaderRequest* internal_default_instance() {
    return reinterpret_cast<const GetLatestBlockHeaderRequest*>(
               &_GetLatestBlockHeaderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetLatestBlockHeaderRequest& a, GetLatestBlockHeaderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLatestBlockHeaderRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLatestBlockHeaderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetLatestBlockHeaderRequest* New() const final {
    return new GetLatestBlockHeaderRequest();
  }

  GetLatestBlockHeaderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetLatestBlockHeaderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLatestBlockHeaderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetLatestBlockHeaderRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLatestBlockHeaderRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetLatestBlockHeaderRequest";
  }
  protected:
  explicit GetLatestBlockHeaderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsSealedFieldNumber = 1,
  };
  // bool is_sealed = 1;
  void clear_is_sealed();
  bool is_sealed() const;
  void set_is_sealed(bool value);
  private:
  bool _internal_is_sealed() const;
  void _internal_set_is_sealed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetLatestBlockHeaderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_sealed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class GetBlockHeaderByIDRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetBlockHeaderByIDRequest) */ {
 public:
  inline GetBlockHeaderByIDRequest() : GetBlockHeaderByIDRequest(nullptr) {}
  ~GetBlockHeaderByIDRequest() override;
  explicit constexpr GetBlockHeaderByIDRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlockHeaderByIDRequest(const GetBlockHeaderByIDRequest& from);
  GetBlockHeaderByIDRequest(GetBlockHeaderByIDRequest&& from) noexcept
    : GetBlockHeaderByIDRequest() {
    *this = ::std::move(from);
  }

  inline GetBlockHeaderByIDRequest& operator=(const GetBlockHeaderByIDRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlockHeaderByIDRequest& operator=(GetBlockHeaderByIDRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlockHeaderByIDRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlockHeaderByIDRequest* internal_default_instance() {
    return reinterpret_cast<const GetBlockHeaderByIDRequest*>(
               &_GetBlockHeaderByIDRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetBlockHeaderByIDRequest& a, GetBlockHeaderByIDRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlockHeaderByIDRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlockHeaderByIDRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetBlockHeaderByIDRequest* New() const final {
    return new GetBlockHeaderByIDRequest();
  }

  GetBlockHeaderByIDRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetBlockHeaderByIDRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlockHeaderByIDRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBlockHeaderByIDRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockHeaderByIDRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetBlockHeaderByIDRequest";
  }
  protected:
  explicit GetBlockHeaderByIDRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetBlockHeaderByIDRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class GetBlockHeaderByHeightRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetBlockHeaderByHeightRequest) */ {
 public:
  inline GetBlockHeaderByHeightRequest() : GetBlockHeaderByHeightRequest(nullptr) {}
  ~GetBlockHeaderByHeightRequest() override;
  explicit constexpr GetBlockHeaderByHeightRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlockHeaderByHeightRequest(const GetBlockHeaderByHeightRequest& from);
  GetBlockHeaderByHeightRequest(GetBlockHeaderByHeightRequest&& from) noexcept
    : GetBlockHeaderByHeightRequest() {
    *this = ::std::move(from);
  }

  inline GetBlockHeaderByHeightRequest& operator=(const GetBlockHeaderByHeightRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlockHeaderByHeightRequest& operator=(GetBlockHeaderByHeightRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlockHeaderByHeightRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlockHeaderByHeightRequest* internal_default_instance() {
    return reinterpret_cast<const GetBlockHeaderByHeightRequest*>(
               &_GetBlockHeaderByHeightRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetBlockHeaderByHeightRequest& a, GetBlockHeaderByHeightRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlockHeaderByHeightRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlockHeaderByHeightRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetBlockHeaderByHeightRequest* New() const final {
    return new GetBlockHeaderByHeightRequest();
  }

  GetBlockHeaderByHeightRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetBlockHeaderByHeightRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlockHeaderByHeightRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBlockHeaderByHeightRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockHeaderByHeightRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetBlockHeaderByHeightRequest";
  }
  protected:
  explicit GetBlockHeaderByHeightRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeightFieldNumber = 1,
  };
  // uint64 height = 1;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetBlockHeaderByHeightRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class BlockHeaderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.BlockHeaderResponse) */ {
 public:
  inline BlockHeaderResponse() : BlockHeaderResponse(nullptr) {}
  ~BlockHeaderResponse() override;
  explicit constexpr BlockHeaderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockHeaderResponse(const BlockHeaderResponse& from);
  BlockHeaderResponse(BlockHeaderResponse&& from) noexcept
    : BlockHeaderResponse() {
    *this = ::std::move(from);
  }

  inline BlockHeaderResponse& operator=(const BlockHeaderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockHeaderResponse& operator=(BlockHeaderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockHeaderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockHeaderResponse* internal_default_instance() {
    return reinterpret_cast<const BlockHeaderResponse*>(
               &_BlockHeaderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BlockHeaderResponse& a, BlockHeaderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockHeaderResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockHeaderResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockHeaderResponse* New() const final {
    return new BlockHeaderResponse();
  }

  BlockHeaderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockHeaderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockHeaderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockHeaderResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockHeaderResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.BlockHeaderResponse";
  }
  protected:
  explicit BlockHeaderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockFieldNumber = 1,
  };
  // .flow.entities.BlockHeader block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::flow::entities::BlockHeader& block() const;
  PROTOBUF_MUST_USE_RESULT ::flow::entities::BlockHeader* release_block();
  ::flow::entities::BlockHeader* mutable_block();
  void set_allocated_block(::flow::entities::BlockHeader* block);
  private:
  const ::flow::entities::BlockHeader& _internal_block() const;
  ::flow::entities::BlockHeader* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::flow::entities::BlockHeader* block);
  ::flow::entities::BlockHeader* unsafe_arena_release_block();

  // @@protoc_insertion_point(class_scope:flow.access.BlockHeaderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flow::entities::BlockHeader* block_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class GetLatestBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetLatestBlockRequest) */ {
 public:
  inline GetLatestBlockRequest() : GetLatestBlockRequest(nullptr) {}
  ~GetLatestBlockRequest() override;
  explicit constexpr GetLatestBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLatestBlockRequest(const GetLatestBlockRequest& from);
  GetLatestBlockRequest(GetLatestBlockRequest&& from) noexcept
    : GetLatestBlockRequest() {
    *this = ::std::move(from);
  }

  inline GetLatestBlockRequest& operator=(const GetLatestBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLatestBlockRequest& operator=(GetLatestBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLatestBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLatestBlockRequest* internal_default_instance() {
    return reinterpret_cast<const GetLatestBlockRequest*>(
               &_GetLatestBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetLatestBlockRequest& a, GetLatestBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLatestBlockRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLatestBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetLatestBlockRequest* New() const final {
    return new GetLatestBlockRequest();
  }

  GetLatestBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetLatestBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLatestBlockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetLatestBlockRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLatestBlockRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetLatestBlockRequest";
  }
  protected:
  explicit GetLatestBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsSealedFieldNumber = 1,
  };
  // bool is_sealed = 1;
  void clear_is_sealed();
  bool is_sealed() const;
  void set_is_sealed(bool value);
  private:
  bool _internal_is_sealed() const;
  void _internal_set_is_sealed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetLatestBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_sealed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class GetBlockByIDRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetBlockByIDRequest) */ {
 public:
  inline GetBlockByIDRequest() : GetBlockByIDRequest(nullptr) {}
  ~GetBlockByIDRequest() override;
  explicit constexpr GetBlockByIDRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlockByIDRequest(const GetBlockByIDRequest& from);
  GetBlockByIDRequest(GetBlockByIDRequest&& from) noexcept
    : GetBlockByIDRequest() {
    *this = ::std::move(from);
  }

  inline GetBlockByIDRequest& operator=(const GetBlockByIDRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlockByIDRequest& operator=(GetBlockByIDRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlockByIDRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlockByIDRequest* internal_default_instance() {
    return reinterpret_cast<const GetBlockByIDRequest*>(
               &_GetBlockByIDRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetBlockByIDRequest& a, GetBlockByIDRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlockByIDRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlockByIDRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetBlockByIDRequest* New() const final {
    return new GetBlockByIDRequest();
  }

  GetBlockByIDRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetBlockByIDRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlockByIDRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBlockByIDRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockByIDRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetBlockByIDRequest";
  }
  protected:
  explicit GetBlockByIDRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetBlockByIDRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class GetBlockByHeightRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetBlockByHeightRequest) */ {
 public:
  inline GetBlockByHeightRequest() : GetBlockByHeightRequest(nullptr) {}
  ~GetBlockByHeightRequest() override;
  explicit constexpr GetBlockByHeightRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlockByHeightRequest(const GetBlockByHeightRequest& from);
  GetBlockByHeightRequest(GetBlockByHeightRequest&& from) noexcept
    : GetBlockByHeightRequest() {
    *this = ::std::move(from);
  }

  inline GetBlockByHeightRequest& operator=(const GetBlockByHeightRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlockByHeightRequest& operator=(GetBlockByHeightRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlockByHeightRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlockByHeightRequest* internal_default_instance() {
    return reinterpret_cast<const GetBlockByHeightRequest*>(
               &_GetBlockByHeightRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetBlockByHeightRequest& a, GetBlockByHeightRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlockByHeightRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlockByHeightRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetBlockByHeightRequest* New() const final {
    return new GetBlockByHeightRequest();
  }

  GetBlockByHeightRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetBlockByHeightRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlockByHeightRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBlockByHeightRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockByHeightRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetBlockByHeightRequest";
  }
  protected:
  explicit GetBlockByHeightRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeightFieldNumber = 1,
  };
  // uint64 height = 1;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetBlockByHeightRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class BlockResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.BlockResponse) */ {
 public:
  inline BlockResponse() : BlockResponse(nullptr) {}
  ~BlockResponse() override;
  explicit constexpr BlockResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockResponse(const BlockResponse& from);
  BlockResponse(BlockResponse&& from) noexcept
    : BlockResponse() {
    *this = ::std::move(from);
  }

  inline BlockResponse& operator=(const BlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockResponse& operator=(BlockResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockResponse* internal_default_instance() {
    return reinterpret_cast<const BlockResponse*>(
               &_BlockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BlockResponse& a, BlockResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockResponse* New() const final {
    return new BlockResponse();
  }

  BlockResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.BlockResponse";
  }
  protected:
  explicit BlockResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockFieldNumber = 1,
  };
  // .flow.entities.Block block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::flow::entities::Block& block() const;
  PROTOBUF_MUST_USE_RESULT ::flow::entities::Block* release_block();
  ::flow::entities::Block* mutable_block();
  void set_allocated_block(::flow::entities::Block* block);
  private:
  const ::flow::entities::Block& _internal_block() const;
  ::flow::entities::Block* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::flow::entities::Block* block);
  ::flow::entities::Block* unsafe_arena_release_block();

  // @@protoc_insertion_point(class_scope:flow.access.BlockResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flow::entities::Block* block_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class GetCollectionByIDRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetCollectionByIDRequest) */ {
 public:
  inline GetCollectionByIDRequest() : GetCollectionByIDRequest(nullptr) {}
  ~GetCollectionByIDRequest() override;
  explicit constexpr GetCollectionByIDRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCollectionByIDRequest(const GetCollectionByIDRequest& from);
  GetCollectionByIDRequest(GetCollectionByIDRequest&& from) noexcept
    : GetCollectionByIDRequest() {
    *this = ::std::move(from);
  }

  inline GetCollectionByIDRequest& operator=(const GetCollectionByIDRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCollectionByIDRequest& operator=(GetCollectionByIDRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCollectionByIDRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCollectionByIDRequest* internal_default_instance() {
    return reinterpret_cast<const GetCollectionByIDRequest*>(
               &_GetCollectionByIDRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetCollectionByIDRequest& a, GetCollectionByIDRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCollectionByIDRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCollectionByIDRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetCollectionByIDRequest* New() const final {
    return new GetCollectionByIDRequest();
  }

  GetCollectionByIDRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetCollectionByIDRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCollectionByIDRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetCollectionByIDRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCollectionByIDRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetCollectionByIDRequest";
  }
  protected:
  explicit GetCollectionByIDRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetCollectionByIDRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class CollectionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.CollectionResponse) */ {
 public:
  inline CollectionResponse() : CollectionResponse(nullptr) {}
  ~CollectionResponse() override;
  explicit constexpr CollectionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CollectionResponse(const CollectionResponse& from);
  CollectionResponse(CollectionResponse&& from) noexcept
    : CollectionResponse() {
    *this = ::std::move(from);
  }

  inline CollectionResponse& operator=(const CollectionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionResponse& operator=(CollectionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollectionResponse* internal_default_instance() {
    return reinterpret_cast<const CollectionResponse*>(
               &_CollectionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CollectionResponse& a, CollectionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CollectionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CollectionResponse* New() const final {
    return new CollectionResponse();
  }

  CollectionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CollectionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CollectionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CollectionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CollectionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.CollectionResponse";
  }
  protected:
  explicit CollectionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollectionFieldNumber = 1,
  };
  // .flow.entities.Collection collection = 1;
  bool has_collection() const;
  private:
  bool _internal_has_collection() const;
  public:
  void clear_collection();
  const ::flow::entities::Collection& collection() const;
  PROTOBUF_MUST_USE_RESULT ::flow::entities::Collection* release_collection();
  ::flow::entities::Collection* mutable_collection();
  void set_allocated_collection(::flow::entities::Collection* collection);
  private:
  const ::flow::entities::Collection& _internal_collection() const;
  ::flow::entities::Collection* _internal_mutable_collection();
  public:
  void unsafe_arena_set_allocated_collection(
      ::flow::entities::Collection* collection);
  ::flow::entities::Collection* unsafe_arena_release_collection();

  // @@protoc_insertion_point(class_scope:flow.access.CollectionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flow::entities::Collection* collection_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class SendTransactionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.SendTransactionRequest) */ {
 public:
  inline SendTransactionRequest() : SendTransactionRequest(nullptr) {}
  ~SendTransactionRequest() override;
  explicit constexpr SendTransactionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendTransactionRequest(const SendTransactionRequest& from);
  SendTransactionRequest(SendTransactionRequest&& from) noexcept
    : SendTransactionRequest() {
    *this = ::std::move(from);
  }

  inline SendTransactionRequest& operator=(const SendTransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendTransactionRequest& operator=(SendTransactionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendTransactionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendTransactionRequest* internal_default_instance() {
    return reinterpret_cast<const SendTransactionRequest*>(
               &_SendTransactionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SendTransactionRequest& a, SendTransactionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendTransactionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendTransactionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SendTransactionRequest* New() const final {
    return new SendTransactionRequest();
  }

  SendTransactionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SendTransactionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendTransactionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SendTransactionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendTransactionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.SendTransactionRequest";
  }
  protected:
  explicit SendTransactionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionFieldNumber = 1,
  };
  // .flow.entities.Transaction transaction = 1;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::flow::entities::Transaction& transaction() const;
  PROTOBUF_MUST_USE_RESULT ::flow::entities::Transaction* release_transaction();
  ::flow::entities::Transaction* mutable_transaction();
  void set_allocated_transaction(::flow::entities::Transaction* transaction);
  private:
  const ::flow::entities::Transaction& _internal_transaction() const;
  ::flow::entities::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::flow::entities::Transaction* transaction);
  ::flow::entities::Transaction* unsafe_arena_release_transaction();

  // @@protoc_insertion_point(class_scope:flow.access.SendTransactionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flow::entities::Transaction* transaction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class SendTransactionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.SendTransactionResponse) */ {
 public:
  inline SendTransactionResponse() : SendTransactionResponse(nullptr) {}
  ~SendTransactionResponse() override;
  explicit constexpr SendTransactionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendTransactionResponse(const SendTransactionResponse& from);
  SendTransactionResponse(SendTransactionResponse&& from) noexcept
    : SendTransactionResponse() {
    *this = ::std::move(from);
  }

  inline SendTransactionResponse& operator=(const SendTransactionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendTransactionResponse& operator=(SendTransactionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendTransactionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendTransactionResponse* internal_default_instance() {
    return reinterpret_cast<const SendTransactionResponse*>(
               &_SendTransactionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SendTransactionResponse& a, SendTransactionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendTransactionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendTransactionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SendTransactionResponse* New() const final {
    return new SendTransactionResponse();
  }

  SendTransactionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SendTransactionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendTransactionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SendTransactionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendTransactionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.SendTransactionResponse";
  }
  protected:
  explicit SendTransactionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.SendTransactionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class GetTransactionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetTransactionRequest) */ {
 public:
  inline GetTransactionRequest() : GetTransactionRequest(nullptr) {}
  ~GetTransactionRequest() override;
  explicit constexpr GetTransactionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTransactionRequest(const GetTransactionRequest& from);
  GetTransactionRequest(GetTransactionRequest&& from) noexcept
    : GetTransactionRequest() {
    *this = ::std::move(from);
  }

  inline GetTransactionRequest& operator=(const GetTransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTransactionRequest& operator=(GetTransactionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTransactionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTransactionRequest* internal_default_instance() {
    return reinterpret_cast<const GetTransactionRequest*>(
               &_GetTransactionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetTransactionRequest& a, GetTransactionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTransactionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTransactionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTransactionRequest* New() const final {
    return new GetTransactionRequest();
  }

  GetTransactionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTransactionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTransactionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTransactionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTransactionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetTransactionRequest";
  }
  protected:
  explicit GetTransactionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetTransactionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class TransactionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.TransactionResponse) */ {
 public:
  inline TransactionResponse() : TransactionResponse(nullptr) {}
  ~TransactionResponse() override;
  explicit constexpr TransactionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionResponse(const TransactionResponse& from);
  TransactionResponse(TransactionResponse&& from) noexcept
    : TransactionResponse() {
    *this = ::std::move(from);
  }

  inline TransactionResponse& operator=(const TransactionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionResponse& operator=(TransactionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionResponse* internal_default_instance() {
    return reinterpret_cast<const TransactionResponse*>(
               &_TransactionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TransactionResponse& a, TransactionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransactionResponse* New() const final {
    return new TransactionResponse();
  }

  TransactionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.TransactionResponse";
  }
  protected:
  explicit TransactionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionFieldNumber = 1,
  };
  // .flow.entities.Transaction transaction = 1;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::flow::entities::Transaction& transaction() const;
  PROTOBUF_MUST_USE_RESULT ::flow::entities::Transaction* release_transaction();
  ::flow::entities::Transaction* mutable_transaction();
  void set_allocated_transaction(::flow::entities::Transaction* transaction);
  private:
  const ::flow::entities::Transaction& _internal_transaction() const;
  ::flow::entities::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::flow::entities::Transaction* transaction);
  ::flow::entities::Transaction* unsafe_arena_release_transaction();

  // @@protoc_insertion_point(class_scope:flow.access.TransactionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flow::entities::Transaction* transaction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class TransactionResultResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.TransactionResultResponse) */ {
 public:
  inline TransactionResultResponse() : TransactionResultResponse(nullptr) {}
  ~TransactionResultResponse() override;
  explicit constexpr TransactionResultResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionResultResponse(const TransactionResultResponse& from);
  TransactionResultResponse(TransactionResultResponse&& from) noexcept
    : TransactionResultResponse() {
    *this = ::std::move(from);
  }

  inline TransactionResultResponse& operator=(const TransactionResultResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionResultResponse& operator=(TransactionResultResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionResultResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionResultResponse* internal_default_instance() {
    return reinterpret_cast<const TransactionResultResponse*>(
               &_TransactionResultResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TransactionResultResponse& a, TransactionResultResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionResultResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionResultResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransactionResultResponse* New() const final {
    return new TransactionResultResponse();
  }

  TransactionResultResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionResultResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionResultResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionResultResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionResultResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.TransactionResultResponse";
  }
  protected:
  explicit TransactionResultResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 4,
    kErrorMessageFieldNumber = 3,
    kBlockIdFieldNumber = 5,
    kStatusFieldNumber = 1,
    kStatusCodeFieldNumber = 2,
  };
  // repeated .flow.entities.Event events = 4;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::flow::entities::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::entities::Event >*
      mutable_events();
  private:
  const ::flow::entities::Event& _internal_events(int index) const;
  ::flow::entities::Event* _internal_add_events();
  public:
  const ::flow::entities::Event& events(int index) const;
  ::flow::entities::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::entities::Event >&
      events() const;

  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bytes block_id = 5;
  void clear_block_id();
  const std::string& block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_block_id();
  void set_allocated_block_id(std::string* block_id);
  private:
  const std::string& _internal_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_id(const std::string& value);
  std::string* _internal_mutable_block_id();
  public:

  // .flow.entities.TransactionStatus status = 1;
  void clear_status();
  ::flow::entities::TransactionStatus status() const;
  void set_status(::flow::entities::TransactionStatus value);
  private:
  ::flow::entities::TransactionStatus _internal_status() const;
  void _internal_set_status(::flow::entities::TransactionStatus value);
  public:

  // uint32 status_code = 2;
  void clear_status_code();
  ::PROTOBUF_NAMESPACE_ID::uint32 status_code() const;
  void set_status_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_status_code() const;
  void _internal_set_status_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.TransactionResultResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::entities::Event > events_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_id_;
  int status_;
  ::PROTOBUF_NAMESPACE_ID::uint32 status_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class GetAccountRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetAccountRequest) */ {
 public:
  inline GetAccountRequest() : GetAccountRequest(nullptr) {}
  ~GetAccountRequest() override;
  explicit constexpr GetAccountRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAccountRequest(const GetAccountRequest& from);
  GetAccountRequest(GetAccountRequest&& from) noexcept
    : GetAccountRequest() {
    *this = ::std::move(from);
  }

  inline GetAccountRequest& operator=(const GetAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountRequest& operator=(GetAccountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAccountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAccountRequest* internal_default_instance() {
    return reinterpret_cast<const GetAccountRequest*>(
               &_GetAccountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetAccountRequest& a, GetAccountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAccountRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAccountRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetAccountRequest* New() const final {
    return new GetAccountRequest();
  }

  GetAccountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetAccountRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAccountRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetAccountRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccountRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetAccountRequest";
  }
  protected:
  explicit GetAccountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetAccountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class GetAccountResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetAccountResponse) */ {
 public:
  inline GetAccountResponse() : GetAccountResponse(nullptr) {}
  ~GetAccountResponse() override;
  explicit constexpr GetAccountResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAccountResponse(const GetAccountResponse& from);
  GetAccountResponse(GetAccountResponse&& from) noexcept
    : GetAccountResponse() {
    *this = ::std::move(from);
  }

  inline GetAccountResponse& operator=(const GetAccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountResponse& operator=(GetAccountResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAccountResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAccountResponse* internal_default_instance() {
    return reinterpret_cast<const GetAccountResponse*>(
               &_GetAccountResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetAccountResponse& a, GetAccountResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAccountResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAccountResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetAccountResponse* New() const final {
    return new GetAccountResponse();
  }

  GetAccountResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetAccountResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAccountResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetAccountResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccountResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetAccountResponse";
  }
  protected:
  explicit GetAccountResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
  };
  // .flow.entities.Account account = 1;
  bool has_account() const;
  private:
  bool _internal_has_account() const;
  public:
  void clear_account();
  const ::flow::entities::Account& account() const;
  PROTOBUF_MUST_USE_RESULT ::flow::entities::Account* release_account();
  ::flow::entities::Account* mutable_account();
  void set_allocated_account(::flow::entities::Account* account);
  private:
  const ::flow::entities::Account& _internal_account() const;
  ::flow::entities::Account* _internal_mutable_account();
  public:
  void unsafe_arena_set_allocated_account(
      ::flow::entities::Account* account);
  ::flow::entities::Account* unsafe_arena_release_account();

  // @@protoc_insertion_point(class_scope:flow.access.GetAccountResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flow::entities::Account* account_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class GetAccountAtLatestBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetAccountAtLatestBlockRequest) */ {
 public:
  inline GetAccountAtLatestBlockRequest() : GetAccountAtLatestBlockRequest(nullptr) {}
  ~GetAccountAtLatestBlockRequest() override;
  explicit constexpr GetAccountAtLatestBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAccountAtLatestBlockRequest(const GetAccountAtLatestBlockRequest& from);
  GetAccountAtLatestBlockRequest(GetAccountAtLatestBlockRequest&& from) noexcept
    : GetAccountAtLatestBlockRequest() {
    *this = ::std::move(from);
  }

  inline GetAccountAtLatestBlockRequest& operator=(const GetAccountAtLatestBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountAtLatestBlockRequest& operator=(GetAccountAtLatestBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAccountAtLatestBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAccountAtLatestBlockRequest* internal_default_instance() {
    return reinterpret_cast<const GetAccountAtLatestBlockRequest*>(
               &_GetAccountAtLatestBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetAccountAtLatestBlockRequest& a, GetAccountAtLatestBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAccountAtLatestBlockRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAccountAtLatestBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetAccountAtLatestBlockRequest* New() const final {
    return new GetAccountAtLatestBlockRequest();
  }

  GetAccountAtLatestBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetAccountAtLatestBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAccountAtLatestBlockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetAccountAtLatestBlockRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccountAtLatestBlockRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetAccountAtLatestBlockRequest";
  }
  protected:
  explicit GetAccountAtLatestBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetAccountAtLatestBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class AccountResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.AccountResponse) */ {
 public:
  inline AccountResponse() : AccountResponse(nullptr) {}
  ~AccountResponse() override;
  explicit constexpr AccountResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountResponse(const AccountResponse& from);
  AccountResponse(AccountResponse&& from) noexcept
    : AccountResponse() {
    *this = ::std::move(from);
  }

  inline AccountResponse& operator=(const AccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountResponse& operator=(AccountResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountResponse* internal_default_instance() {
    return reinterpret_cast<const AccountResponse*>(
               &_AccountResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(AccountResponse& a, AccountResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AccountResponse* New() const final {
    return new AccountResponse();
  }

  AccountResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AccountResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AccountResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.AccountResponse";
  }
  protected:
  explicit AccountResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
  };
  // .flow.entities.Account account = 1;
  bool has_account() const;
  private:
  bool _internal_has_account() const;
  public:
  void clear_account();
  const ::flow::entities::Account& account() const;
  PROTOBUF_MUST_USE_RESULT ::flow::entities::Account* release_account();
  ::flow::entities::Account* mutable_account();
  void set_allocated_account(::flow::entities::Account* account);
  private:
  const ::flow::entities::Account& _internal_account() const;
  ::flow::entities::Account* _internal_mutable_account();
  public:
  void unsafe_arena_set_allocated_account(
      ::flow::entities::Account* account);
  ::flow::entities::Account* unsafe_arena_release_account();

  // @@protoc_insertion_point(class_scope:flow.access.AccountResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flow::entities::Account* account_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class GetAccountAtBlockHeightRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetAccountAtBlockHeightRequest) */ {
 public:
  inline GetAccountAtBlockHeightRequest() : GetAccountAtBlockHeightRequest(nullptr) {}
  ~GetAccountAtBlockHeightRequest() override;
  explicit constexpr GetAccountAtBlockHeightRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAccountAtBlockHeightRequest(const GetAccountAtBlockHeightRequest& from);
  GetAccountAtBlockHeightRequest(GetAccountAtBlockHeightRequest&& from) noexcept
    : GetAccountAtBlockHeightRequest() {
    *this = ::std::move(from);
  }

  inline GetAccountAtBlockHeightRequest& operator=(const GetAccountAtBlockHeightRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountAtBlockHeightRequest& operator=(GetAccountAtBlockHeightRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAccountAtBlockHeightRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAccountAtBlockHeightRequest* internal_default_instance() {
    return reinterpret_cast<const GetAccountAtBlockHeightRequest*>(
               &_GetAccountAtBlockHeightRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GetAccountAtBlockHeightRequest& a, GetAccountAtBlockHeightRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAccountAtBlockHeightRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAccountAtBlockHeightRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetAccountAtBlockHeightRequest* New() const final {
    return new GetAccountAtBlockHeightRequest();
  }

  GetAccountAtBlockHeightRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetAccountAtBlockHeightRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAccountAtBlockHeightRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetAccountAtBlockHeightRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccountAtBlockHeightRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetAccountAtBlockHeightRequest";
  }
  protected:
  explicit GetAccountAtBlockHeightRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kBlockHeightFieldNumber = 2,
  };
  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // uint64 block_height = 2;
  void clear_block_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 block_height() const;
  void set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_block_height() const;
  void _internal_set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetAccountAtBlockHeightRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::uint64 block_height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class ExecuteScriptAtLatestBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.ExecuteScriptAtLatestBlockRequest) */ {
 public:
  inline ExecuteScriptAtLatestBlockRequest() : ExecuteScriptAtLatestBlockRequest(nullptr) {}
  ~ExecuteScriptAtLatestBlockRequest() override;
  explicit constexpr ExecuteScriptAtLatestBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteScriptAtLatestBlockRequest(const ExecuteScriptAtLatestBlockRequest& from);
  ExecuteScriptAtLatestBlockRequest(ExecuteScriptAtLatestBlockRequest&& from) noexcept
    : ExecuteScriptAtLatestBlockRequest() {
    *this = ::std::move(from);
  }

  inline ExecuteScriptAtLatestBlockRequest& operator=(const ExecuteScriptAtLatestBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteScriptAtLatestBlockRequest& operator=(ExecuteScriptAtLatestBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteScriptAtLatestBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteScriptAtLatestBlockRequest* internal_default_instance() {
    return reinterpret_cast<const ExecuteScriptAtLatestBlockRequest*>(
               &_ExecuteScriptAtLatestBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ExecuteScriptAtLatestBlockRequest& a, ExecuteScriptAtLatestBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteScriptAtLatestBlockRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteScriptAtLatestBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExecuteScriptAtLatestBlockRequest* New() const final {
    return new ExecuteScriptAtLatestBlockRequest();
  }

  ExecuteScriptAtLatestBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExecuteScriptAtLatestBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteScriptAtLatestBlockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExecuteScriptAtLatestBlockRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteScriptAtLatestBlockRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.ExecuteScriptAtLatestBlockRequest";
  }
  protected:
  explicit ExecuteScriptAtLatestBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgumentsFieldNumber = 2,
    kScriptFieldNumber = 1,
  };
  // repeated bytes arguments = 2;
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;
  public:
  void clear_arguments();
  const std::string& arguments(int index) const;
  std::string* mutable_arguments(int index);
  void set_arguments(int index, const std::string& value);
  void set_arguments(int index, std::string&& value);
  void set_arguments(int index, const char* value);
  void set_arguments(int index, const void* value, size_t size);
  std::string* add_arguments();
  void add_arguments(const std::string& value);
  void add_arguments(std::string&& value);
  void add_arguments(const char* value);
  void add_arguments(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& arguments() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_arguments();
  private:
  const std::string& _internal_arguments(int index) const;
  std::string* _internal_add_arguments();
  public:

  // bytes script = 1;
  void clear_script();
  const std::string& script() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_script(ArgT0&& arg0, ArgT... args);
  std::string* mutable_script();
  PROTOBUF_MUST_USE_RESULT std::string* release_script();
  void set_allocated_script(std::string* script);
  private:
  const std::string& _internal_script() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_script(const std::string& value);
  std::string* _internal_mutable_script();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.ExecuteScriptAtLatestBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> arguments_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr script_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class ExecuteScriptAtBlockIDRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.ExecuteScriptAtBlockIDRequest) */ {
 public:
  inline ExecuteScriptAtBlockIDRequest() : ExecuteScriptAtBlockIDRequest(nullptr) {}
  ~ExecuteScriptAtBlockIDRequest() override;
  explicit constexpr ExecuteScriptAtBlockIDRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteScriptAtBlockIDRequest(const ExecuteScriptAtBlockIDRequest& from);
  ExecuteScriptAtBlockIDRequest(ExecuteScriptAtBlockIDRequest&& from) noexcept
    : ExecuteScriptAtBlockIDRequest() {
    *this = ::std::move(from);
  }

  inline ExecuteScriptAtBlockIDRequest& operator=(const ExecuteScriptAtBlockIDRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteScriptAtBlockIDRequest& operator=(ExecuteScriptAtBlockIDRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteScriptAtBlockIDRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteScriptAtBlockIDRequest* internal_default_instance() {
    return reinterpret_cast<const ExecuteScriptAtBlockIDRequest*>(
               &_ExecuteScriptAtBlockIDRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ExecuteScriptAtBlockIDRequest& a, ExecuteScriptAtBlockIDRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteScriptAtBlockIDRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteScriptAtBlockIDRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExecuteScriptAtBlockIDRequest* New() const final {
    return new ExecuteScriptAtBlockIDRequest();
  }

  ExecuteScriptAtBlockIDRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExecuteScriptAtBlockIDRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteScriptAtBlockIDRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExecuteScriptAtBlockIDRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteScriptAtBlockIDRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.ExecuteScriptAtBlockIDRequest";
  }
  protected:
  explicit ExecuteScriptAtBlockIDRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgumentsFieldNumber = 3,
    kBlockIdFieldNumber = 1,
    kScriptFieldNumber = 2,
  };
  // repeated bytes arguments = 3;
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;
  public:
  void clear_arguments();
  const std::string& arguments(int index) const;
  std::string* mutable_arguments(int index);
  void set_arguments(int index, const std::string& value);
  void set_arguments(int index, std::string&& value);
  void set_arguments(int index, const char* value);
  void set_arguments(int index, const void* value, size_t size);
  std::string* add_arguments();
  void add_arguments(const std::string& value);
  void add_arguments(std::string&& value);
  void add_arguments(const char* value);
  void add_arguments(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& arguments() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_arguments();
  private:
  const std::string& _internal_arguments(int index) const;
  std::string* _internal_add_arguments();
  public:

  // bytes block_id = 1;
  void clear_block_id();
  const std::string& block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_block_id();
  void set_allocated_block_id(std::string* block_id);
  private:
  const std::string& _internal_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_id(const std::string& value);
  std::string* _internal_mutable_block_id();
  public:

  // bytes script = 2;
  void clear_script();
  const std::string& script() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_script(ArgT0&& arg0, ArgT... args);
  std::string* mutable_script();
  PROTOBUF_MUST_USE_RESULT std::string* release_script();
  void set_allocated_script(std::string* script);
  private:
  const std::string& _internal_script() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_script(const std::string& value);
  std::string* _internal_mutable_script();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.ExecuteScriptAtBlockIDRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> arguments_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr script_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class ExecuteScriptAtBlockHeightRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.ExecuteScriptAtBlockHeightRequest) */ {
 public:
  inline ExecuteScriptAtBlockHeightRequest() : ExecuteScriptAtBlockHeightRequest(nullptr) {}
  ~ExecuteScriptAtBlockHeightRequest() override;
  explicit constexpr ExecuteScriptAtBlockHeightRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteScriptAtBlockHeightRequest(const ExecuteScriptAtBlockHeightRequest& from);
  ExecuteScriptAtBlockHeightRequest(ExecuteScriptAtBlockHeightRequest&& from) noexcept
    : ExecuteScriptAtBlockHeightRequest() {
    *this = ::std::move(from);
  }

  inline ExecuteScriptAtBlockHeightRequest& operator=(const ExecuteScriptAtBlockHeightRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteScriptAtBlockHeightRequest& operator=(ExecuteScriptAtBlockHeightRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteScriptAtBlockHeightRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteScriptAtBlockHeightRequest* internal_default_instance() {
    return reinterpret_cast<const ExecuteScriptAtBlockHeightRequest*>(
               &_ExecuteScriptAtBlockHeightRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ExecuteScriptAtBlockHeightRequest& a, ExecuteScriptAtBlockHeightRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteScriptAtBlockHeightRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteScriptAtBlockHeightRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExecuteScriptAtBlockHeightRequest* New() const final {
    return new ExecuteScriptAtBlockHeightRequest();
  }

  ExecuteScriptAtBlockHeightRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExecuteScriptAtBlockHeightRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteScriptAtBlockHeightRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExecuteScriptAtBlockHeightRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteScriptAtBlockHeightRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.ExecuteScriptAtBlockHeightRequest";
  }
  protected:
  explicit ExecuteScriptAtBlockHeightRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgumentsFieldNumber = 3,
    kScriptFieldNumber = 2,
    kBlockHeightFieldNumber = 1,
  };
  // repeated bytes arguments = 3;
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;
  public:
  void clear_arguments();
  const std::string& arguments(int index) const;
  std::string* mutable_arguments(int index);
  void set_arguments(int index, const std::string& value);
  void set_arguments(int index, std::string&& value);
  void set_arguments(int index, const char* value);
  void set_arguments(int index, const void* value, size_t size);
  std::string* add_arguments();
  void add_arguments(const std::string& value);
  void add_arguments(std::string&& value);
  void add_arguments(const char* value);
  void add_arguments(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& arguments() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_arguments();
  private:
  const std::string& _internal_arguments(int index) const;
  std::string* _internal_add_arguments();
  public:

  // bytes script = 2;
  void clear_script();
  const std::string& script() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_script(ArgT0&& arg0, ArgT... args);
  std::string* mutable_script();
  PROTOBUF_MUST_USE_RESULT std::string* release_script();
  void set_allocated_script(std::string* script);
  private:
  const std::string& _internal_script() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_script(const std::string& value);
  std::string* _internal_mutable_script();
  public:

  // uint64 block_height = 1;
  void clear_block_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 block_height() const;
  void set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_block_height() const;
  void _internal_set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.ExecuteScriptAtBlockHeightRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> arguments_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr script_;
  ::PROTOBUF_NAMESPACE_ID::uint64 block_height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class ExecuteScriptResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.ExecuteScriptResponse) */ {
 public:
  inline ExecuteScriptResponse() : ExecuteScriptResponse(nullptr) {}
  ~ExecuteScriptResponse() override;
  explicit constexpr ExecuteScriptResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteScriptResponse(const ExecuteScriptResponse& from);
  ExecuteScriptResponse(ExecuteScriptResponse&& from) noexcept
    : ExecuteScriptResponse() {
    *this = ::std::move(from);
  }

  inline ExecuteScriptResponse& operator=(const ExecuteScriptResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteScriptResponse& operator=(ExecuteScriptResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteScriptResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteScriptResponse* internal_default_instance() {
    return reinterpret_cast<const ExecuteScriptResponse*>(
               &_ExecuteScriptResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ExecuteScriptResponse& a, ExecuteScriptResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteScriptResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteScriptResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExecuteScriptResponse* New() const final {
    return new ExecuteScriptResponse();
  }

  ExecuteScriptResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExecuteScriptResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteScriptResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExecuteScriptResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteScriptResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.ExecuteScriptResponse";
  }
  protected:
  explicit ExecuteScriptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.ExecuteScriptResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class GetEventsForHeightRangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetEventsForHeightRangeRequest) */ {
 public:
  inline GetEventsForHeightRangeRequest() : GetEventsForHeightRangeRequest(nullptr) {}
  ~GetEventsForHeightRangeRequest() override;
  explicit constexpr GetEventsForHeightRangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEventsForHeightRangeRequest(const GetEventsForHeightRangeRequest& from);
  GetEventsForHeightRangeRequest(GetEventsForHeightRangeRequest&& from) noexcept
    : GetEventsForHeightRangeRequest() {
    *this = ::std::move(from);
  }

  inline GetEventsForHeightRangeRequest& operator=(const GetEventsForHeightRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEventsForHeightRangeRequest& operator=(GetEventsForHeightRangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEventsForHeightRangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEventsForHeightRangeRequest* internal_default_instance() {
    return reinterpret_cast<const GetEventsForHeightRangeRequest*>(
               &_GetEventsForHeightRangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetEventsForHeightRangeRequest& a, GetEventsForHeightRangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEventsForHeightRangeRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEventsForHeightRangeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetEventsForHeightRangeRequest* New() const final {
    return new GetEventsForHeightRangeRequest();
  }

  GetEventsForHeightRangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetEventsForHeightRangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEventsForHeightRangeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetEventsForHeightRangeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEventsForHeightRangeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetEventsForHeightRangeRequest";
  }
  protected:
  explicit GetEventsForHeightRangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kStartHeightFieldNumber = 2,
    kEndHeightFieldNumber = 3,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // uint64 start_height = 2;
  void clear_start_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 start_height() const;
  void set_start_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_start_height() const;
  void _internal_set_start_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 end_height = 3;
  void clear_end_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 end_height() const;
  void set_end_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_end_height() const;
  void _internal_set_end_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetEventsForHeightRangeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::uint64 start_height_;
  ::PROTOBUF_NAMESPACE_ID::uint64 end_height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class GetEventsForBlockIDsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetEventsForBlockIDsRequest) */ {
 public:
  inline GetEventsForBlockIDsRequest() : GetEventsForBlockIDsRequest(nullptr) {}
  ~GetEventsForBlockIDsRequest() override;
  explicit constexpr GetEventsForBlockIDsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEventsForBlockIDsRequest(const GetEventsForBlockIDsRequest& from);
  GetEventsForBlockIDsRequest(GetEventsForBlockIDsRequest&& from) noexcept
    : GetEventsForBlockIDsRequest() {
    *this = ::std::move(from);
  }

  inline GetEventsForBlockIDsRequest& operator=(const GetEventsForBlockIDsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEventsForBlockIDsRequest& operator=(GetEventsForBlockIDsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEventsForBlockIDsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEventsForBlockIDsRequest* internal_default_instance() {
    return reinterpret_cast<const GetEventsForBlockIDsRequest*>(
               &_GetEventsForBlockIDsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(GetEventsForBlockIDsRequest& a, GetEventsForBlockIDsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEventsForBlockIDsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEventsForBlockIDsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetEventsForBlockIDsRequest* New() const final {
    return new GetEventsForBlockIDsRequest();
  }

  GetEventsForBlockIDsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetEventsForBlockIDsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEventsForBlockIDsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetEventsForBlockIDsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEventsForBlockIDsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetEventsForBlockIDsRequest";
  }
  protected:
  explicit GetEventsForBlockIDsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockIdsFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated bytes block_ids = 2;
  int block_ids_size() const;
  private:
  int _internal_block_ids_size() const;
  public:
  void clear_block_ids();
  const std::string& block_ids(int index) const;
  std::string* mutable_block_ids(int index);
  void set_block_ids(int index, const std::string& value);
  void set_block_ids(int index, std::string&& value);
  void set_block_ids(int index, const char* value);
  void set_block_ids(int index, const void* value, size_t size);
  std::string* add_block_ids();
  void add_block_ids(const std::string& value);
  void add_block_ids(std::string&& value);
  void add_block_ids(const char* value);
  void add_block_ids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& block_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_block_ids();
  private:
  const std::string& _internal_block_ids(int index) const;
  std::string* _internal_add_block_ids();
  public:

  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetEventsForBlockIDsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> block_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class EventsResponse_Result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.EventsResponse.Result) */ {
 public:
  inline EventsResponse_Result() : EventsResponse_Result(nullptr) {}
  ~EventsResponse_Result() override;
  explicit constexpr EventsResponse_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventsResponse_Result(const EventsResponse_Result& from);
  EventsResponse_Result(EventsResponse_Result&& from) noexcept
    : EventsResponse_Result() {
    *this = ::std::move(from);
  }

  inline EventsResponse_Result& operator=(const EventsResponse_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventsResponse_Result& operator=(EventsResponse_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventsResponse_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventsResponse_Result* internal_default_instance() {
    return reinterpret_cast<const EventsResponse_Result*>(
               &_EventsResponse_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(EventsResponse_Result& a, EventsResponse_Result& b) {
    a.Swap(&b);
  }
  inline void Swap(EventsResponse_Result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventsResponse_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EventsResponse_Result* New() const final {
    return new EventsResponse_Result();
  }

  EventsResponse_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EventsResponse_Result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventsResponse_Result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EventsResponse_Result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventsResponse_Result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.EventsResponse.Result";
  }
  protected:
  explicit EventsResponse_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 3,
    kBlockIdFieldNumber = 1,
    kBlockTimestampFieldNumber = 4,
    kBlockHeightFieldNumber = 2,
  };
  // repeated .flow.entities.Event events = 3;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::flow::entities::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::entities::Event >*
      mutable_events();
  private:
  const ::flow::entities::Event& _internal_events(int index) const;
  ::flow::entities::Event* _internal_add_events();
  public:
  const ::flow::entities::Event& events(int index) const;
  ::flow::entities::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::entities::Event >&
      events() const;

  // bytes block_id = 1;
  void clear_block_id();
  const std::string& block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_block_id();
  void set_allocated_block_id(std::string* block_id);
  private:
  const std::string& _internal_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_id(const std::string& value);
  std::string* _internal_mutable_block_id();
  public:

  // .google.protobuf.Timestamp block_timestamp = 4;
  bool has_block_timestamp() const;
  private:
  bool _internal_has_block_timestamp() const;
  public:
  void clear_block_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& block_timestamp() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_block_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_block_timestamp();
  void set_allocated_block_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* block_timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_block_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_block_timestamp();
  public:
  void unsafe_arena_set_allocated_block_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* block_timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_block_timestamp();

  // uint64 block_height = 2;
  void clear_block_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 block_height() const;
  void set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_block_height() const;
  void _internal_set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.EventsResponse.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::entities::Event > events_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_id_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* block_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 block_height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class EventsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.EventsResponse) */ {
 public:
  inline EventsResponse() : EventsResponse(nullptr) {}
  ~EventsResponse() override;
  explicit constexpr EventsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventsResponse(const EventsResponse& from);
  EventsResponse(EventsResponse&& from) noexcept
    : EventsResponse() {
    *this = ::std::move(from);
  }

  inline EventsResponse& operator=(const EventsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventsResponse& operator=(EventsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventsResponse* internal_default_instance() {
    return reinterpret_cast<const EventsResponse*>(
               &_EventsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(EventsResponse& a, EventsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EventsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EventsResponse* New() const final {
    return new EventsResponse();
  }

  EventsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EventsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EventsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.EventsResponse";
  }
  protected:
  explicit EventsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EventsResponse_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .flow.access.EventsResponse.Result results = 1;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::flow::access::EventsResponse_Result* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::EventsResponse_Result >*
      mutable_results();
  private:
  const ::flow::access::EventsResponse_Result& _internal_results(int index) const;
  ::flow::access::EventsResponse_Result* _internal_add_results();
  public:
  const ::flow::access::EventsResponse_Result& results(int index) const;
  ::flow::access::EventsResponse_Result* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::EventsResponse_Result >&
      results() const;

  // @@protoc_insertion_point(class_scope:flow.access.EventsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::EventsResponse_Result > results_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class GetNetworkParametersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:flow.access.GetNetworkParametersRequest) */ {
 public:
  inline GetNetworkParametersRequest() : GetNetworkParametersRequest(nullptr) {}
  explicit constexpr GetNetworkParametersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNetworkParametersRequest(const GetNetworkParametersRequest& from);
  GetNetworkParametersRequest(GetNetworkParametersRequest&& from) noexcept
    : GetNetworkParametersRequest() {
    *this = ::std::move(from);
  }

  inline GetNetworkParametersRequest& operator=(const GetNetworkParametersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNetworkParametersRequest& operator=(GetNetworkParametersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNetworkParametersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNetworkParametersRequest* internal_default_instance() {
    return reinterpret_cast<const GetNetworkParametersRequest*>(
               &_GetNetworkParametersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(GetNetworkParametersRequest& a, GetNetworkParametersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNetworkParametersRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNetworkParametersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetNetworkParametersRequest* New() const final {
    return new GetNetworkParametersRequest();
  }

  GetNetworkParametersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetNetworkParametersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetNetworkParametersRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetNetworkParametersRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetNetworkParametersRequest";
  }
  protected:
  explicit GetNetworkParametersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flow.access.GetNetworkParametersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class GetNetworkParametersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetNetworkParametersResponse) */ {
 public:
  inline GetNetworkParametersResponse() : GetNetworkParametersResponse(nullptr) {}
  ~GetNetworkParametersResponse() override;
  explicit constexpr GetNetworkParametersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNetworkParametersResponse(const GetNetworkParametersResponse& from);
  GetNetworkParametersResponse(GetNetworkParametersResponse&& from) noexcept
    : GetNetworkParametersResponse() {
    *this = ::std::move(from);
  }

  inline GetNetworkParametersResponse& operator=(const GetNetworkParametersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNetworkParametersResponse& operator=(GetNetworkParametersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNetworkParametersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNetworkParametersResponse* internal_default_instance() {
    return reinterpret_cast<const GetNetworkParametersResponse*>(
               &_GetNetworkParametersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(GetNetworkParametersResponse& a, GetNetworkParametersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNetworkParametersResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNetworkParametersResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetNetworkParametersResponse* New() const final {
    return new GetNetworkParametersResponse();
  }

  GetNetworkParametersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetNetworkParametersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNetworkParametersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetNetworkParametersResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNetworkParametersResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetNetworkParametersResponse";
  }
  protected:
  explicit GetNetworkParametersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChainIdFieldNumber = 1,
  };
  // string chain_id = 1;
  void clear_chain_id();
  const std::string& chain_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chain_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chain_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_chain_id();
  void set_allocated_chain_id(std::string* chain_id);
  private:
  const std::string& _internal_chain_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chain_id(const std::string& value);
  std::string* _internal_mutable_chain_id();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetNetworkParametersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chain_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class GetLatestProtocolStateSnapshotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:flow.access.GetLatestProtocolStateSnapshotRequest) */ {
 public:
  inline GetLatestProtocolStateSnapshotRequest() : GetLatestProtocolStateSnapshotRequest(nullptr) {}
  explicit constexpr GetLatestProtocolStateSnapshotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLatestProtocolStateSnapshotRequest(const GetLatestProtocolStateSnapshotRequest& from);
  GetLatestProtocolStateSnapshotRequest(GetLatestProtocolStateSnapshotRequest&& from) noexcept
    : GetLatestProtocolStateSnapshotRequest() {
    *this = ::std::move(from);
  }

  inline GetLatestProtocolStateSnapshotRequest& operator=(const GetLatestProtocolStateSnapshotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLatestProtocolStateSnapshotRequest& operator=(GetLatestProtocolStateSnapshotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLatestProtocolStateSnapshotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLatestProtocolStateSnapshotRequest* internal_default_instance() {
    return reinterpret_cast<const GetLatestProtocolStateSnapshotRequest*>(
               &_GetLatestProtocolStateSnapshotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(GetLatestProtocolStateSnapshotRequest& a, GetLatestProtocolStateSnapshotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLatestProtocolStateSnapshotRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLatestProtocolStateSnapshotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetLatestProtocolStateSnapshotRequest* New() const final {
    return new GetLatestProtocolStateSnapshotRequest();
  }

  GetLatestProtocolStateSnapshotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetLatestProtocolStateSnapshotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetLatestProtocolStateSnapshotRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetLatestProtocolStateSnapshotRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetLatestProtocolStateSnapshotRequest";
  }
  protected:
  explicit GetLatestProtocolStateSnapshotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flow.access.GetLatestProtocolStateSnapshotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class ProtocolStateSnapshotResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.ProtocolStateSnapshotResponse) */ {
 public:
  inline ProtocolStateSnapshotResponse() : ProtocolStateSnapshotResponse(nullptr) {}
  ~ProtocolStateSnapshotResponse() override;
  explicit constexpr ProtocolStateSnapshotResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtocolStateSnapshotResponse(const ProtocolStateSnapshotResponse& from);
  ProtocolStateSnapshotResponse(ProtocolStateSnapshotResponse&& from) noexcept
    : ProtocolStateSnapshotResponse() {
    *this = ::std::move(from);
  }

  inline ProtocolStateSnapshotResponse& operator=(const ProtocolStateSnapshotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtocolStateSnapshotResponse& operator=(ProtocolStateSnapshotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtocolStateSnapshotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtocolStateSnapshotResponse* internal_default_instance() {
    return reinterpret_cast<const ProtocolStateSnapshotResponse*>(
               &_ProtocolStateSnapshotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ProtocolStateSnapshotResponse& a, ProtocolStateSnapshotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtocolStateSnapshotResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtocolStateSnapshotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProtocolStateSnapshotResponse* New() const final {
    return new ProtocolStateSnapshotResponse();
  }

  ProtocolStateSnapshotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProtocolStateSnapshotResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtocolStateSnapshotResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProtocolStateSnapshotResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtocolStateSnapshotResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.ProtocolStateSnapshotResponse";
  }
  protected:
  explicit ProtocolStateSnapshotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSerializedSnapshotFieldNumber = 1,
  };
  // bytes serializedSnapshot = 1;
  void clear_serializedsnapshot();
  const std::string& serializedsnapshot() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serializedsnapshot(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serializedsnapshot();
  PROTOBUF_MUST_USE_RESULT std::string* release_serializedsnapshot();
  void set_allocated_serializedsnapshot(std::string* serializedsnapshot);
  private:
  const std::string& _internal_serializedsnapshot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serializedsnapshot(const std::string& value);
  std::string* _internal_mutable_serializedsnapshot();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.ProtocolStateSnapshotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serializedsnapshot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class GetExecutionResultForBlockIDRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetExecutionResultForBlockIDRequest) */ {
 public:
  inline GetExecutionResultForBlockIDRequest() : GetExecutionResultForBlockIDRequest(nullptr) {}
  ~GetExecutionResultForBlockIDRequest() override;
  explicit constexpr GetExecutionResultForBlockIDRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetExecutionResultForBlockIDRequest(const GetExecutionResultForBlockIDRequest& from);
  GetExecutionResultForBlockIDRequest(GetExecutionResultForBlockIDRequest&& from) noexcept
    : GetExecutionResultForBlockIDRequest() {
    *this = ::std::move(from);
  }

  inline GetExecutionResultForBlockIDRequest& operator=(const GetExecutionResultForBlockIDRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetExecutionResultForBlockIDRequest& operator=(GetExecutionResultForBlockIDRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetExecutionResultForBlockIDRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetExecutionResultForBlockIDRequest* internal_default_instance() {
    return reinterpret_cast<const GetExecutionResultForBlockIDRequest*>(
               &_GetExecutionResultForBlockIDRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(GetExecutionResultForBlockIDRequest& a, GetExecutionResultForBlockIDRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetExecutionResultForBlockIDRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetExecutionResultForBlockIDRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetExecutionResultForBlockIDRequest* New() const final {
    return new GetExecutionResultForBlockIDRequest();
  }

  GetExecutionResultForBlockIDRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetExecutionResultForBlockIDRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetExecutionResultForBlockIDRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetExecutionResultForBlockIDRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetExecutionResultForBlockIDRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetExecutionResultForBlockIDRequest";
  }
  protected:
  explicit GetExecutionResultForBlockIDRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockIdFieldNumber = 1,
  };
  // bytes block_id = 1;
  void clear_block_id();
  const std::string& block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_block_id();
  void set_allocated_block_id(std::string* block_id);
  private:
  const std::string& _internal_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_id(const std::string& value);
  std::string* _internal_mutable_block_id();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetExecutionResultForBlockIDRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// -------------------------------------------------------------------

class ExecutionResultForBlockIDResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.ExecutionResultForBlockIDResponse) */ {
 public:
  inline ExecutionResultForBlockIDResponse() : ExecutionResultForBlockIDResponse(nullptr) {}
  ~ExecutionResultForBlockIDResponse() override;
  explicit constexpr ExecutionResultForBlockIDResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionResultForBlockIDResponse(const ExecutionResultForBlockIDResponse& from);
  ExecutionResultForBlockIDResponse(ExecutionResultForBlockIDResponse&& from) noexcept
    : ExecutionResultForBlockIDResponse() {
    *this = ::std::move(from);
  }

  inline ExecutionResultForBlockIDResponse& operator=(const ExecutionResultForBlockIDResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionResultForBlockIDResponse& operator=(ExecutionResultForBlockIDResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionResultForBlockIDResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionResultForBlockIDResponse* internal_default_instance() {
    return reinterpret_cast<const ExecutionResultForBlockIDResponse*>(
               &_ExecutionResultForBlockIDResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ExecutionResultForBlockIDResponse& a, ExecutionResultForBlockIDResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionResultForBlockIDResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionResultForBlockIDResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExecutionResultForBlockIDResponse* New() const final {
    return new ExecutionResultForBlockIDResponse();
  }

  ExecutionResultForBlockIDResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExecutionResultForBlockIDResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecutionResultForBlockIDResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExecutionResultForBlockIDResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionResultForBlockIDResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.ExecutionResultForBlockIDResponse";
  }
  protected:
  explicit ExecutionResultForBlockIDResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExecutionResultFieldNumber = 1,
  };
  // .flow.entities.ExecutionResult execution_result = 1;
  bool has_execution_result() const;
  private:
  bool _internal_has_execution_result() const;
  public:
  void clear_execution_result();
  const ::flow::entities::ExecutionResult& execution_result() const;
  PROTOBUF_MUST_USE_RESULT ::flow::entities::ExecutionResult* release_execution_result();
  ::flow::entities::ExecutionResult* mutable_execution_result();
  void set_allocated_execution_result(::flow::entities::ExecutionResult* execution_result);
  private:
  const ::flow::entities::ExecutionResult& _internal_execution_result() const;
  ::flow::entities::ExecutionResult* _internal_mutable_execution_result();
  public:
  void unsafe_arena_set_allocated_execution_result(
      ::flow::entities::ExecutionResult* execution_result);
  ::flow::entities::ExecutionResult* unsafe_arena_release_execution_result();

  // @@protoc_insertion_point(class_scope:flow.access.ExecutionResultForBlockIDResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flow::entities::ExecutionResult* execution_result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2faccess_2faccess_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PingRequest

// -------------------------------------------------------------------

// PingResponse

// -------------------------------------------------------------------

// GetLatestBlockHeaderRequest

// bool is_sealed = 1;
inline void GetLatestBlockHeaderRequest::clear_is_sealed() {
  is_sealed_ = false;
}
inline bool GetLatestBlockHeaderRequest::_internal_is_sealed() const {
  return is_sealed_;
}
inline bool GetLatestBlockHeaderRequest::is_sealed() const {
  // @@protoc_insertion_point(field_get:flow.access.GetLatestBlockHeaderRequest.is_sealed)
  return _internal_is_sealed();
}
inline void GetLatestBlockHeaderRequest::_internal_set_is_sealed(bool value) {
  
  is_sealed_ = value;
}
inline void GetLatestBlockHeaderRequest::set_is_sealed(bool value) {
  _internal_set_is_sealed(value);
  // @@protoc_insertion_point(field_set:flow.access.GetLatestBlockHeaderRequest.is_sealed)
}

// -------------------------------------------------------------------

// GetBlockHeaderByIDRequest

// bytes id = 1;
inline void GetBlockHeaderByIDRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetBlockHeaderByIDRequest::id() const {
  // @@protoc_insertion_point(field_get:flow.access.GetBlockHeaderByIDRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBlockHeaderByIDRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.GetBlockHeaderByIDRequest.id)
}
inline std::string* GetBlockHeaderByIDRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flow.access.GetBlockHeaderByIDRequest.id)
  return _s;
}
inline const std::string& GetBlockHeaderByIDRequest::_internal_id() const {
  return id_.Get();
}
inline void GetBlockHeaderByIDRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetBlockHeaderByIDRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetBlockHeaderByIDRequest::release_id() {
  // @@protoc_insertion_point(field_release:flow.access.GetBlockHeaderByIDRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetBlockHeaderByIDRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetBlockHeaderByIDRequest.id)
}

// -------------------------------------------------------------------

// GetBlockHeaderByHeightRequest

// uint64 height = 1;
inline void GetBlockHeaderByHeightRequest::clear_height() {
  height_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetBlockHeaderByHeightRequest::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetBlockHeaderByHeightRequest::height() const {
  // @@protoc_insertion_point(field_get:flow.access.GetBlockHeaderByHeightRequest.height)
  return _internal_height();
}
inline void GetBlockHeaderByHeightRequest::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  height_ = value;
}
inline void GetBlockHeaderByHeightRequest::set_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:flow.access.GetBlockHeaderByHeightRequest.height)
}

// -------------------------------------------------------------------

// BlockHeaderResponse

// .flow.entities.BlockHeader block = 1;
inline bool BlockHeaderResponse::_internal_has_block() const {
  return this != internal_default_instance() && block_ != nullptr;
}
inline bool BlockHeaderResponse::has_block() const {
  return _internal_has_block();
}
inline const ::flow::entities::BlockHeader& BlockHeaderResponse::_internal_block() const {
  const ::flow::entities::BlockHeader* p = block_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow::entities::BlockHeader&>(
      ::flow::entities::_BlockHeader_default_instance_);
}
inline const ::flow::entities::BlockHeader& BlockHeaderResponse::block() const {
  // @@protoc_insertion_point(field_get:flow.access.BlockHeaderResponse.block)
  return _internal_block();
}
inline void BlockHeaderResponse::unsafe_arena_set_allocated_block(
    ::flow::entities::BlockHeader* block) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_);
  }
  block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow.access.BlockHeaderResponse.block)
}
inline ::flow::entities::BlockHeader* BlockHeaderResponse::release_block() {
  
  ::flow::entities::BlockHeader* temp = block_;
  block_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow::entities::BlockHeader* BlockHeaderResponse::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:flow.access.BlockHeaderResponse.block)
  
  ::flow::entities::BlockHeader* temp = block_;
  block_ = nullptr;
  return temp;
}
inline ::flow::entities::BlockHeader* BlockHeaderResponse::_internal_mutable_block() {
  
  if (block_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow::entities::BlockHeader>(GetArenaForAllocation());
    block_ = p;
  }
  return block_;
}
inline ::flow::entities::BlockHeader* BlockHeaderResponse::mutable_block() {
  ::flow::entities::BlockHeader* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:flow.access.BlockHeaderResponse.block)
  return _msg;
}
inline void BlockHeaderResponse::set_allocated_block(::flow::entities::BlockHeader* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_);
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block));
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:flow.access.BlockHeaderResponse.block)
}

// -------------------------------------------------------------------

// GetLatestBlockRequest

// bool is_sealed = 1;
inline void GetLatestBlockRequest::clear_is_sealed() {
  is_sealed_ = false;
}
inline bool GetLatestBlockRequest::_internal_is_sealed() const {
  return is_sealed_;
}
inline bool GetLatestBlockRequest::is_sealed() const {
  // @@protoc_insertion_point(field_get:flow.access.GetLatestBlockRequest.is_sealed)
  return _internal_is_sealed();
}
inline void GetLatestBlockRequest::_internal_set_is_sealed(bool value) {
  
  is_sealed_ = value;
}
inline void GetLatestBlockRequest::set_is_sealed(bool value) {
  _internal_set_is_sealed(value);
  // @@protoc_insertion_point(field_set:flow.access.GetLatestBlockRequest.is_sealed)
}

// -------------------------------------------------------------------

// GetBlockByIDRequest

// bytes id = 1;
inline void GetBlockByIDRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetBlockByIDRequest::id() const {
  // @@protoc_insertion_point(field_get:flow.access.GetBlockByIDRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBlockByIDRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.GetBlockByIDRequest.id)
}
inline std::string* GetBlockByIDRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flow.access.GetBlockByIDRequest.id)
  return _s;
}
inline const std::string& GetBlockByIDRequest::_internal_id() const {
  return id_.Get();
}
inline void GetBlockByIDRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetBlockByIDRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetBlockByIDRequest::release_id() {
  // @@protoc_insertion_point(field_release:flow.access.GetBlockByIDRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetBlockByIDRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetBlockByIDRequest.id)
}

// -------------------------------------------------------------------

// GetBlockByHeightRequest

// uint64 height = 1;
inline void GetBlockByHeightRequest::clear_height() {
  height_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetBlockByHeightRequest::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetBlockByHeightRequest::height() const {
  // @@protoc_insertion_point(field_get:flow.access.GetBlockByHeightRequest.height)
  return _internal_height();
}
inline void GetBlockByHeightRequest::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  height_ = value;
}
inline void GetBlockByHeightRequest::set_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:flow.access.GetBlockByHeightRequest.height)
}

// -------------------------------------------------------------------

// BlockResponse

// .flow.entities.Block block = 1;
inline bool BlockResponse::_internal_has_block() const {
  return this != internal_default_instance() && block_ != nullptr;
}
inline bool BlockResponse::has_block() const {
  return _internal_has_block();
}
inline const ::flow::entities::Block& BlockResponse::_internal_block() const {
  const ::flow::entities::Block* p = block_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow::entities::Block&>(
      ::flow::entities::_Block_default_instance_);
}
inline const ::flow::entities::Block& BlockResponse::block() const {
  // @@protoc_insertion_point(field_get:flow.access.BlockResponse.block)
  return _internal_block();
}
inline void BlockResponse::unsafe_arena_set_allocated_block(
    ::flow::entities::Block* block) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_);
  }
  block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow.access.BlockResponse.block)
}
inline ::flow::entities::Block* BlockResponse::release_block() {
  
  ::flow::entities::Block* temp = block_;
  block_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow::entities::Block* BlockResponse::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:flow.access.BlockResponse.block)
  
  ::flow::entities::Block* temp = block_;
  block_ = nullptr;
  return temp;
}
inline ::flow::entities::Block* BlockResponse::_internal_mutable_block() {
  
  if (block_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow::entities::Block>(GetArenaForAllocation());
    block_ = p;
  }
  return block_;
}
inline ::flow::entities::Block* BlockResponse::mutable_block() {
  ::flow::entities::Block* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:flow.access.BlockResponse.block)
  return _msg;
}
inline void BlockResponse::set_allocated_block(::flow::entities::Block* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_);
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block));
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:flow.access.BlockResponse.block)
}

// -------------------------------------------------------------------

// GetCollectionByIDRequest

// bytes id = 1;
inline void GetCollectionByIDRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetCollectionByIDRequest::id() const {
  // @@protoc_insertion_point(field_get:flow.access.GetCollectionByIDRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetCollectionByIDRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.GetCollectionByIDRequest.id)
}
inline std::string* GetCollectionByIDRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flow.access.GetCollectionByIDRequest.id)
  return _s;
}
inline const std::string& GetCollectionByIDRequest::_internal_id() const {
  return id_.Get();
}
inline void GetCollectionByIDRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetCollectionByIDRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetCollectionByIDRequest::release_id() {
  // @@protoc_insertion_point(field_release:flow.access.GetCollectionByIDRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetCollectionByIDRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetCollectionByIDRequest.id)
}

// -------------------------------------------------------------------

// CollectionResponse

// .flow.entities.Collection collection = 1;
inline bool CollectionResponse::_internal_has_collection() const {
  return this != internal_default_instance() && collection_ != nullptr;
}
inline bool CollectionResponse::has_collection() const {
  return _internal_has_collection();
}
inline const ::flow::entities::Collection& CollectionResponse::_internal_collection() const {
  const ::flow::entities::Collection* p = collection_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow::entities::Collection&>(
      ::flow::entities::_Collection_default_instance_);
}
inline const ::flow::entities::Collection& CollectionResponse::collection() const {
  // @@protoc_insertion_point(field_get:flow.access.CollectionResponse.collection)
  return _internal_collection();
}
inline void CollectionResponse::unsafe_arena_set_allocated_collection(
    ::flow::entities::Collection* collection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(collection_);
  }
  collection_ = collection;
  if (collection) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow.access.CollectionResponse.collection)
}
inline ::flow::entities::Collection* CollectionResponse::release_collection() {
  
  ::flow::entities::Collection* temp = collection_;
  collection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow::entities::Collection* CollectionResponse::unsafe_arena_release_collection() {
  // @@protoc_insertion_point(field_release:flow.access.CollectionResponse.collection)
  
  ::flow::entities::Collection* temp = collection_;
  collection_ = nullptr;
  return temp;
}
inline ::flow::entities::Collection* CollectionResponse::_internal_mutable_collection() {
  
  if (collection_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow::entities::Collection>(GetArenaForAllocation());
    collection_ = p;
  }
  return collection_;
}
inline ::flow::entities::Collection* CollectionResponse::mutable_collection() {
  ::flow::entities::Collection* _msg = _internal_mutable_collection();
  // @@protoc_insertion_point(field_mutable:flow.access.CollectionResponse.collection)
  return _msg;
}
inline void CollectionResponse::set_allocated_collection(::flow::entities::Collection* collection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(collection_);
  }
  if (collection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(collection));
    if (message_arena != submessage_arena) {
      collection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, collection, submessage_arena);
    }
    
  } else {
    
  }
  collection_ = collection;
  // @@protoc_insertion_point(field_set_allocated:flow.access.CollectionResponse.collection)
}

// -------------------------------------------------------------------

// SendTransactionRequest

// .flow.entities.Transaction transaction = 1;
inline bool SendTransactionRequest::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool SendTransactionRequest::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::flow::entities::Transaction& SendTransactionRequest::_internal_transaction() const {
  const ::flow::entities::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow::entities::Transaction&>(
      ::flow::entities::_Transaction_default_instance_);
}
inline const ::flow::entities::Transaction& SendTransactionRequest::transaction() const {
  // @@protoc_insertion_point(field_get:flow.access.SendTransactionRequest.transaction)
  return _internal_transaction();
}
inline void SendTransactionRequest::unsafe_arena_set_allocated_transaction(
    ::flow::entities::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow.access.SendTransactionRequest.transaction)
}
inline ::flow::entities::Transaction* SendTransactionRequest::release_transaction() {
  
  ::flow::entities::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow::entities::Transaction* SendTransactionRequest::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:flow.access.SendTransactionRequest.transaction)
  
  ::flow::entities::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::flow::entities::Transaction* SendTransactionRequest::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow::entities::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::flow::entities::Transaction* SendTransactionRequest::mutable_transaction() {
  ::flow::entities::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:flow.access.SendTransactionRequest.transaction)
  return _msg;
}
inline void SendTransactionRequest::set_allocated_transaction(::flow::entities::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:flow.access.SendTransactionRequest.transaction)
}

// -------------------------------------------------------------------

// SendTransactionResponse

// bytes id = 1;
inline void SendTransactionResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& SendTransactionResponse::id() const {
  // @@protoc_insertion_point(field_get:flow.access.SendTransactionResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendTransactionResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.SendTransactionResponse.id)
}
inline std::string* SendTransactionResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flow.access.SendTransactionResponse.id)
  return _s;
}
inline const std::string& SendTransactionResponse::_internal_id() const {
  return id_.Get();
}
inline void SendTransactionResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SendTransactionResponse::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SendTransactionResponse::release_id() {
  // @@protoc_insertion_point(field_release:flow.access.SendTransactionResponse.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SendTransactionResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.SendTransactionResponse.id)
}

// -------------------------------------------------------------------

// GetTransactionRequest

// bytes id = 1;
inline void GetTransactionRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetTransactionRequest::id() const {
  // @@protoc_insertion_point(field_get:flow.access.GetTransactionRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTransactionRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.GetTransactionRequest.id)
}
inline std::string* GetTransactionRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flow.access.GetTransactionRequest.id)
  return _s;
}
inline const std::string& GetTransactionRequest::_internal_id() const {
  return id_.Get();
}
inline void GetTransactionRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetTransactionRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetTransactionRequest::release_id() {
  // @@protoc_insertion_point(field_release:flow.access.GetTransactionRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetTransactionRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetTransactionRequest.id)
}

// -------------------------------------------------------------------

// TransactionResponse

// .flow.entities.Transaction transaction = 1;
inline bool TransactionResponse::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool TransactionResponse::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::flow::entities::Transaction& TransactionResponse::_internal_transaction() const {
  const ::flow::entities::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow::entities::Transaction&>(
      ::flow::entities::_Transaction_default_instance_);
}
inline const ::flow::entities::Transaction& TransactionResponse::transaction() const {
  // @@protoc_insertion_point(field_get:flow.access.TransactionResponse.transaction)
  return _internal_transaction();
}
inline void TransactionResponse::unsafe_arena_set_allocated_transaction(
    ::flow::entities::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow.access.TransactionResponse.transaction)
}
inline ::flow::entities::Transaction* TransactionResponse::release_transaction() {
  
  ::flow::entities::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow::entities::Transaction* TransactionResponse::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:flow.access.TransactionResponse.transaction)
  
  ::flow::entities::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::flow::entities::Transaction* TransactionResponse::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow::entities::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::flow::entities::Transaction* TransactionResponse::mutable_transaction() {
  ::flow::entities::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:flow.access.TransactionResponse.transaction)
  return _msg;
}
inline void TransactionResponse::set_allocated_transaction(::flow::entities::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:flow.access.TransactionResponse.transaction)
}

// -------------------------------------------------------------------

// TransactionResultResponse

// .flow.entities.TransactionStatus status = 1;
inline void TransactionResultResponse::clear_status() {
  status_ = 0;
}
inline ::flow::entities::TransactionStatus TransactionResultResponse::_internal_status() const {
  return static_cast< ::flow::entities::TransactionStatus >(status_);
}
inline ::flow::entities::TransactionStatus TransactionResultResponse::status() const {
  // @@protoc_insertion_point(field_get:flow.access.TransactionResultResponse.status)
  return _internal_status();
}
inline void TransactionResultResponse::_internal_set_status(::flow::entities::TransactionStatus value) {
  
  status_ = value;
}
inline void TransactionResultResponse::set_status(::flow::entities::TransactionStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:flow.access.TransactionResultResponse.status)
}

// uint32 status_code = 2;
inline void TransactionResultResponse::clear_status_code() {
  status_code_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransactionResultResponse::_internal_status_code() const {
  return status_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransactionResultResponse::status_code() const {
  // @@protoc_insertion_point(field_get:flow.access.TransactionResultResponse.status_code)
  return _internal_status_code();
}
inline void TransactionResultResponse::_internal_set_status_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  status_code_ = value;
}
inline void TransactionResultResponse::set_status_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_status_code(value);
  // @@protoc_insertion_point(field_set:flow.access.TransactionResultResponse.status_code)
}

// string error_message = 3;
inline void TransactionResultResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& TransactionResultResponse::error_message() const {
  // @@protoc_insertion_point(field_get:flow.access.TransactionResultResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionResultResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.TransactionResultResponse.error_message)
}
inline std::string* TransactionResultResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:flow.access.TransactionResultResponse.error_message)
  return _s;
}
inline const std::string& TransactionResultResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void TransactionResultResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionResultResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionResultResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:flow.access.TransactionResultResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionResultResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.TransactionResultResponse.error_message)
}

// repeated .flow.entities.Event events = 4;
inline int TransactionResultResponse::_internal_events_size() const {
  return events_.size();
}
inline int TransactionResultResponse::events_size() const {
  return _internal_events_size();
}
inline ::flow::entities::Event* TransactionResultResponse::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.TransactionResultResponse.events)
  return events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::entities::Event >*
TransactionResultResponse::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.TransactionResultResponse.events)
  return &events_;
}
inline const ::flow::entities::Event& TransactionResultResponse::_internal_events(int index) const {
  return events_.Get(index);
}
inline const ::flow::entities::Event& TransactionResultResponse::events(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.TransactionResultResponse.events)
  return _internal_events(index);
}
inline ::flow::entities::Event* TransactionResultResponse::_internal_add_events() {
  return events_.Add();
}
inline ::flow::entities::Event* TransactionResultResponse::add_events() {
  ::flow::entities::Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:flow.access.TransactionResultResponse.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::entities::Event >&
TransactionResultResponse::events() const {
  // @@protoc_insertion_point(field_list:flow.access.TransactionResultResponse.events)
  return events_;
}

// bytes block_id = 5;
inline void TransactionResultResponse::clear_block_id() {
  block_id_.ClearToEmpty();
}
inline const std::string& TransactionResultResponse::block_id() const {
  // @@protoc_insertion_point(field_get:flow.access.TransactionResultResponse.block_id)
  return _internal_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionResultResponse::set_block_id(ArgT0&& arg0, ArgT... args) {
 
 block_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.TransactionResultResponse.block_id)
}
inline std::string* TransactionResultResponse::mutable_block_id() {
  std::string* _s = _internal_mutable_block_id();
  // @@protoc_insertion_point(field_mutable:flow.access.TransactionResultResponse.block_id)
  return _s;
}
inline const std::string& TransactionResultResponse::_internal_block_id() const {
  return block_id_.Get();
}
inline void TransactionResultResponse::_internal_set_block_id(const std::string& value) {
  
  block_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionResultResponse::_internal_mutable_block_id() {
  
  return block_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionResultResponse::release_block_id() {
  // @@protoc_insertion_point(field_release:flow.access.TransactionResultResponse.block_id)
  return block_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionResultResponse::set_allocated_block_id(std::string* block_id) {
  if (block_id != nullptr) {
    
  } else {
    
  }
  block_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), block_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.TransactionResultResponse.block_id)
}

// -------------------------------------------------------------------

// GetAccountRequest

// bytes address = 1;
inline void GetAccountRequest::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& GetAccountRequest::address() const {
  // @@protoc_insertion_point(field_get:flow.access.GetAccountRequest.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAccountRequest::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.GetAccountRequest.address)
}
inline std::string* GetAccountRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:flow.access.GetAccountRequest.address)
  return _s;
}
inline const std::string& GetAccountRequest::_internal_address() const {
  return address_.Get();
}
inline void GetAccountRequest::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetAccountRequest::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetAccountRequest::release_address() {
  // @@protoc_insertion_point(field_release:flow.access.GetAccountRequest.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetAccountRequest::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetAccountRequest.address)
}

// -------------------------------------------------------------------

// GetAccountResponse

// .flow.entities.Account account = 1;
inline bool GetAccountResponse::_internal_has_account() const {
  return this != internal_default_instance() && account_ != nullptr;
}
inline bool GetAccountResponse::has_account() const {
  return _internal_has_account();
}
inline const ::flow::entities::Account& GetAccountResponse::_internal_account() const {
  const ::flow::entities::Account* p = account_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow::entities::Account&>(
      ::flow::entities::_Account_default_instance_);
}
inline const ::flow::entities::Account& GetAccountResponse::account() const {
  // @@protoc_insertion_point(field_get:flow.access.GetAccountResponse.account)
  return _internal_account();
}
inline void GetAccountResponse::unsafe_arena_set_allocated_account(
    ::flow::entities::Account* account) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  account_ = account;
  if (account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow.access.GetAccountResponse.account)
}
inline ::flow::entities::Account* GetAccountResponse::release_account() {
  
  ::flow::entities::Account* temp = account_;
  account_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow::entities::Account* GetAccountResponse::unsafe_arena_release_account() {
  // @@protoc_insertion_point(field_release:flow.access.GetAccountResponse.account)
  
  ::flow::entities::Account* temp = account_;
  account_ = nullptr;
  return temp;
}
inline ::flow::entities::Account* GetAccountResponse::_internal_mutable_account() {
  
  if (account_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow::entities::Account>(GetArenaForAllocation());
    account_ = p;
  }
  return account_;
}
inline ::flow::entities::Account* GetAccountResponse::mutable_account() {
  ::flow::entities::Account* _msg = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:flow.access.GetAccountResponse.account)
  return _msg;
}
inline void GetAccountResponse::set_allocated_account(::flow::entities::Account* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(account));
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetAccountResponse.account)
}

// -------------------------------------------------------------------

// GetAccountAtLatestBlockRequest

// bytes address = 1;
inline void GetAccountAtLatestBlockRequest::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& GetAccountAtLatestBlockRequest::address() const {
  // @@protoc_insertion_point(field_get:flow.access.GetAccountAtLatestBlockRequest.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAccountAtLatestBlockRequest::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.GetAccountAtLatestBlockRequest.address)
}
inline std::string* GetAccountAtLatestBlockRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:flow.access.GetAccountAtLatestBlockRequest.address)
  return _s;
}
inline const std::string& GetAccountAtLatestBlockRequest::_internal_address() const {
  return address_.Get();
}
inline void GetAccountAtLatestBlockRequest::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetAccountAtLatestBlockRequest::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetAccountAtLatestBlockRequest::release_address() {
  // @@protoc_insertion_point(field_release:flow.access.GetAccountAtLatestBlockRequest.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetAccountAtLatestBlockRequest::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetAccountAtLatestBlockRequest.address)
}

// -------------------------------------------------------------------

// AccountResponse

// .flow.entities.Account account = 1;
inline bool AccountResponse::_internal_has_account() const {
  return this != internal_default_instance() && account_ != nullptr;
}
inline bool AccountResponse::has_account() const {
  return _internal_has_account();
}
inline const ::flow::entities::Account& AccountResponse::_internal_account() const {
  const ::flow::entities::Account* p = account_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow::entities::Account&>(
      ::flow::entities::_Account_default_instance_);
}
inline const ::flow::entities::Account& AccountResponse::account() const {
  // @@protoc_insertion_point(field_get:flow.access.AccountResponse.account)
  return _internal_account();
}
inline void AccountResponse::unsafe_arena_set_allocated_account(
    ::flow::entities::Account* account) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  account_ = account;
  if (account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow.access.AccountResponse.account)
}
inline ::flow::entities::Account* AccountResponse::release_account() {
  
  ::flow::entities::Account* temp = account_;
  account_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow::entities::Account* AccountResponse::unsafe_arena_release_account() {
  // @@protoc_insertion_point(field_release:flow.access.AccountResponse.account)
  
  ::flow::entities::Account* temp = account_;
  account_ = nullptr;
  return temp;
}
inline ::flow::entities::Account* AccountResponse::_internal_mutable_account() {
  
  if (account_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow::entities::Account>(GetArenaForAllocation());
    account_ = p;
  }
  return account_;
}
inline ::flow::entities::Account* AccountResponse::mutable_account() {
  ::flow::entities::Account* _msg = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:flow.access.AccountResponse.account)
  return _msg;
}
inline void AccountResponse::set_allocated_account(::flow::entities::Account* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(account));
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:flow.access.AccountResponse.account)
}

// -------------------------------------------------------------------

// GetAccountAtBlockHeightRequest

// bytes address = 1;
inline void GetAccountAtBlockHeightRequest::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& GetAccountAtBlockHeightRequest::address() const {
  // @@protoc_insertion_point(field_get:flow.access.GetAccountAtBlockHeightRequest.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAccountAtBlockHeightRequest::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.GetAccountAtBlockHeightRequest.address)
}
inline std::string* GetAccountAtBlockHeightRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:flow.access.GetAccountAtBlockHeightRequest.address)
  return _s;
}
inline const std::string& GetAccountAtBlockHeightRequest::_internal_address() const {
  return address_.Get();
}
inline void GetAccountAtBlockHeightRequest::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetAccountAtBlockHeightRequest::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetAccountAtBlockHeightRequest::release_address() {
  // @@protoc_insertion_point(field_release:flow.access.GetAccountAtBlockHeightRequest.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetAccountAtBlockHeightRequest::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetAccountAtBlockHeightRequest.address)
}

// uint64 block_height = 2;
inline void GetAccountAtBlockHeightRequest::clear_block_height() {
  block_height_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetAccountAtBlockHeightRequest::_internal_block_height() const {
  return block_height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetAccountAtBlockHeightRequest::block_height() const {
  // @@protoc_insertion_point(field_get:flow.access.GetAccountAtBlockHeightRequest.block_height)
  return _internal_block_height();
}
inline void GetAccountAtBlockHeightRequest::_internal_set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  block_height_ = value;
}
inline void GetAccountAtBlockHeightRequest::set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_block_height(value);
  // @@protoc_insertion_point(field_set:flow.access.GetAccountAtBlockHeightRequest.block_height)
}

// -------------------------------------------------------------------

// ExecuteScriptAtLatestBlockRequest

// bytes script = 1;
inline void ExecuteScriptAtLatestBlockRequest::clear_script() {
  script_.ClearToEmpty();
}
inline const std::string& ExecuteScriptAtLatestBlockRequest::script() const {
  // @@protoc_insertion_point(field_get:flow.access.ExecuteScriptAtLatestBlockRequest.script)
  return _internal_script();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteScriptAtLatestBlockRequest::set_script(ArgT0&& arg0, ArgT... args) {
 
 script_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.ExecuteScriptAtLatestBlockRequest.script)
}
inline std::string* ExecuteScriptAtLatestBlockRequest::mutable_script() {
  std::string* _s = _internal_mutable_script();
  // @@protoc_insertion_point(field_mutable:flow.access.ExecuteScriptAtLatestBlockRequest.script)
  return _s;
}
inline const std::string& ExecuteScriptAtLatestBlockRequest::_internal_script() const {
  return script_.Get();
}
inline void ExecuteScriptAtLatestBlockRequest::_internal_set_script(const std::string& value) {
  
  script_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtLatestBlockRequest::_internal_mutable_script() {
  
  return script_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtLatestBlockRequest::release_script() {
  // @@protoc_insertion_point(field_release:flow.access.ExecuteScriptAtLatestBlockRequest.script)
  return script_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecuteScriptAtLatestBlockRequest::set_allocated_script(std::string* script) {
  if (script != nullptr) {
    
  } else {
    
  }
  script_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), script,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.ExecuteScriptAtLatestBlockRequest.script)
}

// repeated bytes arguments = 2;
inline int ExecuteScriptAtLatestBlockRequest::_internal_arguments_size() const {
  return arguments_.size();
}
inline int ExecuteScriptAtLatestBlockRequest::arguments_size() const {
  return _internal_arguments_size();
}
inline void ExecuteScriptAtLatestBlockRequest::clear_arguments() {
  arguments_.Clear();
}
inline std::string* ExecuteScriptAtLatestBlockRequest::add_arguments() {
  std::string* _s = _internal_add_arguments();
  // @@protoc_insertion_point(field_add_mutable:flow.access.ExecuteScriptAtLatestBlockRequest.arguments)
  return _s;
}
inline const std::string& ExecuteScriptAtLatestBlockRequest::_internal_arguments(int index) const {
  return arguments_.Get(index);
}
inline const std::string& ExecuteScriptAtLatestBlockRequest::arguments(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.ExecuteScriptAtLatestBlockRequest.arguments)
  return _internal_arguments(index);
}
inline std::string* ExecuteScriptAtLatestBlockRequest::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.ExecuteScriptAtLatestBlockRequest.arguments)
  return arguments_.Mutable(index);
}
inline void ExecuteScriptAtLatestBlockRequest::set_arguments(int index, const std::string& value) {
  arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:flow.access.ExecuteScriptAtLatestBlockRequest.arguments)
}
inline void ExecuteScriptAtLatestBlockRequest::set_arguments(int index, std::string&& value) {
  arguments_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:flow.access.ExecuteScriptAtLatestBlockRequest.arguments)
}
inline void ExecuteScriptAtLatestBlockRequest::set_arguments(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flow.access.ExecuteScriptAtLatestBlockRequest.arguments)
}
inline void ExecuteScriptAtLatestBlockRequest::set_arguments(int index, const void* value, size_t size) {
  arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flow.access.ExecuteScriptAtLatestBlockRequest.arguments)
}
inline std::string* ExecuteScriptAtLatestBlockRequest::_internal_add_arguments() {
  return arguments_.Add();
}
inline void ExecuteScriptAtLatestBlockRequest::add_arguments(const std::string& value) {
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flow.access.ExecuteScriptAtLatestBlockRequest.arguments)
}
inline void ExecuteScriptAtLatestBlockRequest::add_arguments(std::string&& value) {
  arguments_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flow.access.ExecuteScriptAtLatestBlockRequest.arguments)
}
inline void ExecuteScriptAtLatestBlockRequest::add_arguments(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flow.access.ExecuteScriptAtLatestBlockRequest.arguments)
}
inline void ExecuteScriptAtLatestBlockRequest::add_arguments(const void* value, size_t size) {
  arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flow.access.ExecuteScriptAtLatestBlockRequest.arguments)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ExecuteScriptAtLatestBlockRequest::arguments() const {
  // @@protoc_insertion_point(field_list:flow.access.ExecuteScriptAtLatestBlockRequest.arguments)
  return arguments_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ExecuteScriptAtLatestBlockRequest::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.ExecuteScriptAtLatestBlockRequest.arguments)
  return &arguments_;
}

// -------------------------------------------------------------------

// ExecuteScriptAtBlockIDRequest

// bytes block_id = 1;
inline void ExecuteScriptAtBlockIDRequest::clear_block_id() {
  block_id_.ClearToEmpty();
}
inline const std::string& ExecuteScriptAtBlockIDRequest::block_id() const {
  // @@protoc_insertion_point(field_get:flow.access.ExecuteScriptAtBlockIDRequest.block_id)
  return _internal_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteScriptAtBlockIDRequest::set_block_id(ArgT0&& arg0, ArgT... args) {
 
 block_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.ExecuteScriptAtBlockIDRequest.block_id)
}
inline std::string* ExecuteScriptAtBlockIDRequest::mutable_block_id() {
  std::string* _s = _internal_mutable_block_id();
  // @@protoc_insertion_point(field_mutable:flow.access.ExecuteScriptAtBlockIDRequest.block_id)
  return _s;
}
inline const std::string& ExecuteScriptAtBlockIDRequest::_internal_block_id() const {
  return block_id_.Get();
}
inline void ExecuteScriptAtBlockIDRequest::_internal_set_block_id(const std::string& value) {
  
  block_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtBlockIDRequest::_internal_mutable_block_id() {
  
  return block_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtBlockIDRequest::release_block_id() {
  // @@protoc_insertion_point(field_release:flow.access.ExecuteScriptAtBlockIDRequest.block_id)
  return block_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecuteScriptAtBlockIDRequest::set_allocated_block_id(std::string* block_id) {
  if (block_id != nullptr) {
    
  } else {
    
  }
  block_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), block_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.ExecuteScriptAtBlockIDRequest.block_id)
}

// bytes script = 2;
inline void ExecuteScriptAtBlockIDRequest::clear_script() {
  script_.ClearToEmpty();
}
inline const std::string& ExecuteScriptAtBlockIDRequest::script() const {
  // @@protoc_insertion_point(field_get:flow.access.ExecuteScriptAtBlockIDRequest.script)
  return _internal_script();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteScriptAtBlockIDRequest::set_script(ArgT0&& arg0, ArgT... args) {
 
 script_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.ExecuteScriptAtBlockIDRequest.script)
}
inline std::string* ExecuteScriptAtBlockIDRequest::mutable_script() {
  std::string* _s = _internal_mutable_script();
  // @@protoc_insertion_point(field_mutable:flow.access.ExecuteScriptAtBlockIDRequest.script)
  return _s;
}
inline const std::string& ExecuteScriptAtBlockIDRequest::_internal_script() const {
  return script_.Get();
}
inline void ExecuteScriptAtBlockIDRequest::_internal_set_script(const std::string& value) {
  
  script_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtBlockIDRequest::_internal_mutable_script() {
  
  return script_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtBlockIDRequest::release_script() {
  // @@protoc_insertion_point(field_release:flow.access.ExecuteScriptAtBlockIDRequest.script)
  return script_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecuteScriptAtBlockIDRequest::set_allocated_script(std::string* script) {
  if (script != nullptr) {
    
  } else {
    
  }
  script_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), script,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.ExecuteScriptAtBlockIDRequest.script)
}

// repeated bytes arguments = 3;
inline int ExecuteScriptAtBlockIDRequest::_internal_arguments_size() const {
  return arguments_.size();
}
inline int ExecuteScriptAtBlockIDRequest::arguments_size() const {
  return _internal_arguments_size();
}
inline void ExecuteScriptAtBlockIDRequest::clear_arguments() {
  arguments_.Clear();
}
inline std::string* ExecuteScriptAtBlockIDRequest::add_arguments() {
  std::string* _s = _internal_add_arguments();
  // @@protoc_insertion_point(field_add_mutable:flow.access.ExecuteScriptAtBlockIDRequest.arguments)
  return _s;
}
inline const std::string& ExecuteScriptAtBlockIDRequest::_internal_arguments(int index) const {
  return arguments_.Get(index);
}
inline const std::string& ExecuteScriptAtBlockIDRequest::arguments(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.ExecuteScriptAtBlockIDRequest.arguments)
  return _internal_arguments(index);
}
inline std::string* ExecuteScriptAtBlockIDRequest::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.ExecuteScriptAtBlockIDRequest.arguments)
  return arguments_.Mutable(index);
}
inline void ExecuteScriptAtBlockIDRequest::set_arguments(int index, const std::string& value) {
  arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:flow.access.ExecuteScriptAtBlockIDRequest.arguments)
}
inline void ExecuteScriptAtBlockIDRequest::set_arguments(int index, std::string&& value) {
  arguments_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:flow.access.ExecuteScriptAtBlockIDRequest.arguments)
}
inline void ExecuteScriptAtBlockIDRequest::set_arguments(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flow.access.ExecuteScriptAtBlockIDRequest.arguments)
}
inline void ExecuteScriptAtBlockIDRequest::set_arguments(int index, const void* value, size_t size) {
  arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flow.access.ExecuteScriptAtBlockIDRequest.arguments)
}
inline std::string* ExecuteScriptAtBlockIDRequest::_internal_add_arguments() {
  return arguments_.Add();
}
inline void ExecuteScriptAtBlockIDRequest::add_arguments(const std::string& value) {
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flow.access.ExecuteScriptAtBlockIDRequest.arguments)
}
inline void ExecuteScriptAtBlockIDRequest::add_arguments(std::string&& value) {
  arguments_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flow.access.ExecuteScriptAtBlockIDRequest.arguments)
}
inline void ExecuteScriptAtBlockIDRequest::add_arguments(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flow.access.ExecuteScriptAtBlockIDRequest.arguments)
}
inline void ExecuteScriptAtBlockIDRequest::add_arguments(const void* value, size_t size) {
  arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flow.access.ExecuteScriptAtBlockIDRequest.arguments)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ExecuteScriptAtBlockIDRequest::arguments() const {
  // @@protoc_insertion_point(field_list:flow.access.ExecuteScriptAtBlockIDRequest.arguments)
  return arguments_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ExecuteScriptAtBlockIDRequest::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.ExecuteScriptAtBlockIDRequest.arguments)
  return &arguments_;
}

// -------------------------------------------------------------------

// ExecuteScriptAtBlockHeightRequest

// uint64 block_height = 1;
inline void ExecuteScriptAtBlockHeightRequest::clear_block_height() {
  block_height_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExecuteScriptAtBlockHeightRequest::_internal_block_height() const {
  return block_height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExecuteScriptAtBlockHeightRequest::block_height() const {
  // @@protoc_insertion_point(field_get:flow.access.ExecuteScriptAtBlockHeightRequest.block_height)
  return _internal_block_height();
}
inline void ExecuteScriptAtBlockHeightRequest::_internal_set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  block_height_ = value;
}
inline void ExecuteScriptAtBlockHeightRequest::set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_block_height(value);
  // @@protoc_insertion_point(field_set:flow.access.ExecuteScriptAtBlockHeightRequest.block_height)
}

// bytes script = 2;
inline void ExecuteScriptAtBlockHeightRequest::clear_script() {
  script_.ClearToEmpty();
}
inline const std::string& ExecuteScriptAtBlockHeightRequest::script() const {
  // @@protoc_insertion_point(field_get:flow.access.ExecuteScriptAtBlockHeightRequest.script)
  return _internal_script();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteScriptAtBlockHeightRequest::set_script(ArgT0&& arg0, ArgT... args) {
 
 script_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.ExecuteScriptAtBlockHeightRequest.script)
}
inline std::string* ExecuteScriptAtBlockHeightRequest::mutable_script() {
  std::string* _s = _internal_mutable_script();
  // @@protoc_insertion_point(field_mutable:flow.access.ExecuteScriptAtBlockHeightRequest.script)
  return _s;
}
inline const std::string& ExecuteScriptAtBlockHeightRequest::_internal_script() const {
  return script_.Get();
}
inline void ExecuteScriptAtBlockHeightRequest::_internal_set_script(const std::string& value) {
  
  script_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtBlockHeightRequest::_internal_mutable_script() {
  
  return script_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtBlockHeightRequest::release_script() {
  // @@protoc_insertion_point(field_release:flow.access.ExecuteScriptAtBlockHeightRequest.script)
  return script_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecuteScriptAtBlockHeightRequest::set_allocated_script(std::string* script) {
  if (script != nullptr) {
    
  } else {
    
  }
  script_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), script,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.ExecuteScriptAtBlockHeightRequest.script)
}

// repeated bytes arguments = 3;
inline int ExecuteScriptAtBlockHeightRequest::_internal_arguments_size() const {
  return arguments_.size();
}
inline int ExecuteScriptAtBlockHeightRequest::arguments_size() const {
  return _internal_arguments_size();
}
inline void ExecuteScriptAtBlockHeightRequest::clear_arguments() {
  arguments_.Clear();
}
inline std::string* ExecuteScriptAtBlockHeightRequest::add_arguments() {
  std::string* _s = _internal_add_arguments();
  // @@protoc_insertion_point(field_add_mutable:flow.access.ExecuteScriptAtBlockHeightRequest.arguments)
  return _s;
}
inline const std::string& ExecuteScriptAtBlockHeightRequest::_internal_arguments(int index) const {
  return arguments_.Get(index);
}
inline const std::string& ExecuteScriptAtBlockHeightRequest::arguments(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.ExecuteScriptAtBlockHeightRequest.arguments)
  return _internal_arguments(index);
}
inline std::string* ExecuteScriptAtBlockHeightRequest::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.ExecuteScriptAtBlockHeightRequest.arguments)
  return arguments_.Mutable(index);
}
inline void ExecuteScriptAtBlockHeightRequest::set_arguments(int index, const std::string& value) {
  arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:flow.access.ExecuteScriptAtBlockHeightRequest.arguments)
}
inline void ExecuteScriptAtBlockHeightRequest::set_arguments(int index, std::string&& value) {
  arguments_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:flow.access.ExecuteScriptAtBlockHeightRequest.arguments)
}
inline void ExecuteScriptAtBlockHeightRequest::set_arguments(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flow.access.ExecuteScriptAtBlockHeightRequest.arguments)
}
inline void ExecuteScriptAtBlockHeightRequest::set_arguments(int index, const void* value, size_t size) {
  arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flow.access.ExecuteScriptAtBlockHeightRequest.arguments)
}
inline std::string* ExecuteScriptAtBlockHeightRequest::_internal_add_arguments() {
  return arguments_.Add();
}
inline void ExecuteScriptAtBlockHeightRequest::add_arguments(const std::string& value) {
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flow.access.ExecuteScriptAtBlockHeightRequest.arguments)
}
inline void ExecuteScriptAtBlockHeightRequest::add_arguments(std::string&& value) {
  arguments_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flow.access.ExecuteScriptAtBlockHeightRequest.arguments)
}
inline void ExecuteScriptAtBlockHeightRequest::add_arguments(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flow.access.ExecuteScriptAtBlockHeightRequest.arguments)
}
inline void ExecuteScriptAtBlockHeightRequest::add_arguments(const void* value, size_t size) {
  arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flow.access.ExecuteScriptAtBlockHeightRequest.arguments)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ExecuteScriptAtBlockHeightRequest::arguments() const {
  // @@protoc_insertion_point(field_list:flow.access.ExecuteScriptAtBlockHeightRequest.arguments)
  return arguments_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ExecuteScriptAtBlockHeightRequest::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.ExecuteScriptAtBlockHeightRequest.arguments)
  return &arguments_;
}

// -------------------------------------------------------------------

// ExecuteScriptResponse

// bytes value = 1;
inline void ExecuteScriptResponse::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& ExecuteScriptResponse::value() const {
  // @@protoc_insertion_point(field_get:flow.access.ExecuteScriptResponse.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteScriptResponse::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.ExecuteScriptResponse.value)
}
inline std::string* ExecuteScriptResponse::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:flow.access.ExecuteScriptResponse.value)
  return _s;
}
inline const std::string& ExecuteScriptResponse::_internal_value() const {
  return value_.Get();
}
inline void ExecuteScriptResponse::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecuteScriptResponse::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecuteScriptResponse::release_value() {
  // @@protoc_insertion_point(field_release:flow.access.ExecuteScriptResponse.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecuteScriptResponse::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.ExecuteScriptResponse.value)
}

// -------------------------------------------------------------------

// GetEventsForHeightRangeRequest

// string type = 1;
inline void GetEventsForHeightRangeRequest::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& GetEventsForHeightRangeRequest::type() const {
  // @@protoc_insertion_point(field_get:flow.access.GetEventsForHeightRangeRequest.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetEventsForHeightRangeRequest::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.GetEventsForHeightRangeRequest.type)
}
inline std::string* GetEventsForHeightRangeRequest::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:flow.access.GetEventsForHeightRangeRequest.type)
  return _s;
}
inline const std::string& GetEventsForHeightRangeRequest::_internal_type() const {
  return type_.Get();
}
inline void GetEventsForHeightRangeRequest::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetEventsForHeightRangeRequest::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetEventsForHeightRangeRequest::release_type() {
  // @@protoc_insertion_point(field_release:flow.access.GetEventsForHeightRangeRequest.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetEventsForHeightRangeRequest::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetEventsForHeightRangeRequest.type)
}

// uint64 start_height = 2;
inline void GetEventsForHeightRangeRequest::clear_start_height() {
  start_height_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetEventsForHeightRangeRequest::_internal_start_height() const {
  return start_height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetEventsForHeightRangeRequest::start_height() const {
  // @@protoc_insertion_point(field_get:flow.access.GetEventsForHeightRangeRequest.start_height)
  return _internal_start_height();
}
inline void GetEventsForHeightRangeRequest::_internal_set_start_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  start_height_ = value;
}
inline void GetEventsForHeightRangeRequest::set_start_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_start_height(value);
  // @@protoc_insertion_point(field_set:flow.access.GetEventsForHeightRangeRequest.start_height)
}

// uint64 end_height = 3;
inline void GetEventsForHeightRangeRequest::clear_end_height() {
  end_height_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetEventsForHeightRangeRequest::_internal_end_height() const {
  return end_height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetEventsForHeightRangeRequest::end_height() const {
  // @@protoc_insertion_point(field_get:flow.access.GetEventsForHeightRangeRequest.end_height)
  return _internal_end_height();
}
inline void GetEventsForHeightRangeRequest::_internal_set_end_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  end_height_ = value;
}
inline void GetEventsForHeightRangeRequest::set_end_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_end_height(value);
  // @@protoc_insertion_point(field_set:flow.access.GetEventsForHeightRangeRequest.end_height)
}

// -------------------------------------------------------------------

// GetEventsForBlockIDsRequest

// string type = 1;
inline void GetEventsForBlockIDsRequest::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& GetEventsForBlockIDsRequest::type() const {
  // @@protoc_insertion_point(field_get:flow.access.GetEventsForBlockIDsRequest.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetEventsForBlockIDsRequest::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.GetEventsForBlockIDsRequest.type)
}
inline std::string* GetEventsForBlockIDsRequest::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:flow.access.GetEventsForBlockIDsRequest.type)
  return _s;
}
inline const std::string& GetEventsForBlockIDsRequest::_internal_type() const {
  return type_.Get();
}
inline void GetEventsForBlockIDsRequest::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetEventsForBlockIDsRequest::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetEventsForBlockIDsRequest::release_type() {
  // @@protoc_insertion_point(field_release:flow.access.GetEventsForBlockIDsRequest.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetEventsForBlockIDsRequest::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetEventsForBlockIDsRequest.type)
}

// repeated bytes block_ids = 2;
inline int GetEventsForBlockIDsRequest::_internal_block_ids_size() const {
  return block_ids_.size();
}
inline int GetEventsForBlockIDsRequest::block_ids_size() const {
  return _internal_block_ids_size();
}
inline void GetEventsForBlockIDsRequest::clear_block_ids() {
  block_ids_.Clear();
}
inline std::string* GetEventsForBlockIDsRequest::add_block_ids() {
  std::string* _s = _internal_add_block_ids();
  // @@protoc_insertion_point(field_add_mutable:flow.access.GetEventsForBlockIDsRequest.block_ids)
  return _s;
}
inline const std::string& GetEventsForBlockIDsRequest::_internal_block_ids(int index) const {
  return block_ids_.Get(index);
}
inline const std::string& GetEventsForBlockIDsRequest::block_ids(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.GetEventsForBlockIDsRequest.block_ids)
  return _internal_block_ids(index);
}
inline std::string* GetEventsForBlockIDsRequest::mutable_block_ids(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.GetEventsForBlockIDsRequest.block_ids)
  return block_ids_.Mutable(index);
}
inline void GetEventsForBlockIDsRequest::set_block_ids(int index, const std::string& value) {
  block_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:flow.access.GetEventsForBlockIDsRequest.block_ids)
}
inline void GetEventsForBlockIDsRequest::set_block_ids(int index, std::string&& value) {
  block_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:flow.access.GetEventsForBlockIDsRequest.block_ids)
}
inline void GetEventsForBlockIDsRequest::set_block_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  block_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flow.access.GetEventsForBlockIDsRequest.block_ids)
}
inline void GetEventsForBlockIDsRequest::set_block_ids(int index, const void* value, size_t size) {
  block_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flow.access.GetEventsForBlockIDsRequest.block_ids)
}
inline std::string* GetEventsForBlockIDsRequest::_internal_add_block_ids() {
  return block_ids_.Add();
}
inline void GetEventsForBlockIDsRequest::add_block_ids(const std::string& value) {
  block_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flow.access.GetEventsForBlockIDsRequest.block_ids)
}
inline void GetEventsForBlockIDsRequest::add_block_ids(std::string&& value) {
  block_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flow.access.GetEventsForBlockIDsRequest.block_ids)
}
inline void GetEventsForBlockIDsRequest::add_block_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  block_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flow.access.GetEventsForBlockIDsRequest.block_ids)
}
inline void GetEventsForBlockIDsRequest::add_block_ids(const void* value, size_t size) {
  block_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flow.access.GetEventsForBlockIDsRequest.block_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetEventsForBlockIDsRequest::block_ids() const {
  // @@protoc_insertion_point(field_list:flow.access.GetEventsForBlockIDsRequest.block_ids)
  return block_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetEventsForBlockIDsRequest::mutable_block_ids() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.GetEventsForBlockIDsRequest.block_ids)
  return &block_ids_;
}

// -------------------------------------------------------------------

// EventsResponse_Result

// bytes block_id = 1;
inline void EventsResponse_Result::clear_block_id() {
  block_id_.ClearToEmpty();
}
inline const std::string& EventsResponse_Result::block_id() const {
  // @@protoc_insertion_point(field_get:flow.access.EventsResponse.Result.block_id)
  return _internal_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventsResponse_Result::set_block_id(ArgT0&& arg0, ArgT... args) {
 
 block_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.EventsResponse.Result.block_id)
}
inline std::string* EventsResponse_Result::mutable_block_id() {
  std::string* _s = _internal_mutable_block_id();
  // @@protoc_insertion_point(field_mutable:flow.access.EventsResponse.Result.block_id)
  return _s;
}
inline const std::string& EventsResponse_Result::_internal_block_id() const {
  return block_id_.Get();
}
inline void EventsResponse_Result::_internal_set_block_id(const std::string& value) {
  
  block_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EventsResponse_Result::_internal_mutable_block_id() {
  
  return block_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EventsResponse_Result::release_block_id() {
  // @@protoc_insertion_point(field_release:flow.access.EventsResponse.Result.block_id)
  return block_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EventsResponse_Result::set_allocated_block_id(std::string* block_id) {
  if (block_id != nullptr) {
    
  } else {
    
  }
  block_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), block_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.EventsResponse.Result.block_id)
}

// uint64 block_height = 2;
inline void EventsResponse_Result::clear_block_height() {
  block_height_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EventsResponse_Result::_internal_block_height() const {
  return block_height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EventsResponse_Result::block_height() const {
  // @@protoc_insertion_point(field_get:flow.access.EventsResponse.Result.block_height)
  return _internal_block_height();
}
inline void EventsResponse_Result::_internal_set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  block_height_ = value;
}
inline void EventsResponse_Result::set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_block_height(value);
  // @@protoc_insertion_point(field_set:flow.access.EventsResponse.Result.block_height)
}

// repeated .flow.entities.Event events = 3;
inline int EventsResponse_Result::_internal_events_size() const {
  return events_.size();
}
inline int EventsResponse_Result::events_size() const {
  return _internal_events_size();
}
inline ::flow::entities::Event* EventsResponse_Result::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.EventsResponse.Result.events)
  return events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::entities::Event >*
EventsResponse_Result::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.EventsResponse.Result.events)
  return &events_;
}
inline const ::flow::entities::Event& EventsResponse_Result::_internal_events(int index) const {
  return events_.Get(index);
}
inline const ::flow::entities::Event& EventsResponse_Result::events(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.EventsResponse.Result.events)
  return _internal_events(index);
}
inline ::flow::entities::Event* EventsResponse_Result::_internal_add_events() {
  return events_.Add();
}
inline ::flow::entities::Event* EventsResponse_Result::add_events() {
  ::flow::entities::Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:flow.access.EventsResponse.Result.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::entities::Event >&
EventsResponse_Result::events() const {
  // @@protoc_insertion_point(field_list:flow.access.EventsResponse.Result.events)
  return events_;
}

// .google.protobuf.Timestamp block_timestamp = 4;
inline bool EventsResponse_Result::_internal_has_block_timestamp() const {
  return this != internal_default_instance() && block_timestamp_ != nullptr;
}
inline bool EventsResponse_Result::has_block_timestamp() const {
  return _internal_has_block_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EventsResponse_Result::_internal_block_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = block_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EventsResponse_Result::block_timestamp() const {
  // @@protoc_insertion_point(field_get:flow.access.EventsResponse.Result.block_timestamp)
  return _internal_block_timestamp();
}
inline void EventsResponse_Result::unsafe_arena_set_allocated_block_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* block_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_timestamp_);
  }
  block_timestamp_ = block_timestamp;
  if (block_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow.access.EventsResponse.Result.block_timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventsResponse_Result::release_block_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = block_timestamp_;
  block_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventsResponse_Result::unsafe_arena_release_block_timestamp() {
  // @@protoc_insertion_point(field_release:flow.access.EventsResponse.Result.block_timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = block_timestamp_;
  block_timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventsResponse_Result::_internal_mutable_block_timestamp() {
  
  if (block_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    block_timestamp_ = p;
  }
  return block_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventsResponse_Result::mutable_block_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_block_timestamp();
  // @@protoc_insertion_point(field_mutable:flow.access.EventsResponse.Result.block_timestamp)
  return _msg;
}
inline void EventsResponse_Result::set_allocated_block_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* block_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_timestamp_);
  }
  if (block_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_timestamp));
    if (message_arena != submessage_arena) {
      block_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  block_timestamp_ = block_timestamp;
  // @@protoc_insertion_point(field_set_allocated:flow.access.EventsResponse.Result.block_timestamp)
}

// -------------------------------------------------------------------

// EventsResponse

// repeated .flow.access.EventsResponse.Result results = 1;
inline int EventsResponse::_internal_results_size() const {
  return results_.size();
}
inline int EventsResponse::results_size() const {
  return _internal_results_size();
}
inline void EventsResponse::clear_results() {
  results_.Clear();
}
inline ::flow::access::EventsResponse_Result* EventsResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.EventsResponse.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::EventsResponse_Result >*
EventsResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.EventsResponse.results)
  return &results_;
}
inline const ::flow::access::EventsResponse_Result& EventsResponse::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::flow::access::EventsResponse_Result& EventsResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.EventsResponse.results)
  return _internal_results(index);
}
inline ::flow::access::EventsResponse_Result* EventsResponse::_internal_add_results() {
  return results_.Add();
}
inline ::flow::access::EventsResponse_Result* EventsResponse::add_results() {
  ::flow::access::EventsResponse_Result* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:flow.access.EventsResponse.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::EventsResponse_Result >&
EventsResponse::results() const {
  // @@protoc_insertion_point(field_list:flow.access.EventsResponse.results)
  return results_;
}

// -------------------------------------------------------------------

// GetNetworkParametersRequest

// -------------------------------------------------------------------

// GetNetworkParametersResponse

// string chain_id = 1;
inline void GetNetworkParametersResponse::clear_chain_id() {
  chain_id_.ClearToEmpty();
}
inline const std::string& GetNetworkParametersResponse::chain_id() const {
  // @@protoc_insertion_point(field_get:flow.access.GetNetworkParametersResponse.chain_id)
  return _internal_chain_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNetworkParametersResponse::set_chain_id(ArgT0&& arg0, ArgT... args) {
 
 chain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.GetNetworkParametersResponse.chain_id)
}
inline std::string* GetNetworkParametersResponse::mutable_chain_id() {
  std::string* _s = _internal_mutable_chain_id();
  // @@protoc_insertion_point(field_mutable:flow.access.GetNetworkParametersResponse.chain_id)
  return _s;
}
inline const std::string& GetNetworkParametersResponse::_internal_chain_id() const {
  return chain_id_.Get();
}
inline void GetNetworkParametersResponse::_internal_set_chain_id(const std::string& value) {
  
  chain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetNetworkParametersResponse::_internal_mutable_chain_id() {
  
  return chain_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetNetworkParametersResponse::release_chain_id() {
  // @@protoc_insertion_point(field_release:flow.access.GetNetworkParametersResponse.chain_id)
  return chain_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetNetworkParametersResponse::set_allocated_chain_id(std::string* chain_id) {
  if (chain_id != nullptr) {
    
  } else {
    
  }
  chain_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chain_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetNetworkParametersResponse.chain_id)
}

// -------------------------------------------------------------------

// GetLatestProtocolStateSnapshotRequest

// -------------------------------------------------------------------

// ProtocolStateSnapshotResponse

// bytes serializedSnapshot = 1;
inline void ProtocolStateSnapshotResponse::clear_serializedsnapshot() {
  serializedsnapshot_.ClearToEmpty();
}
inline const std::string& ProtocolStateSnapshotResponse::serializedsnapshot() const {
  // @@protoc_insertion_point(field_get:flow.access.ProtocolStateSnapshotResponse.serializedSnapshot)
  return _internal_serializedsnapshot();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProtocolStateSnapshotResponse::set_serializedsnapshot(ArgT0&& arg0, ArgT... args) {
 
 serializedsnapshot_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.ProtocolStateSnapshotResponse.serializedSnapshot)
}
inline std::string* ProtocolStateSnapshotResponse::mutable_serializedsnapshot() {
  std::string* _s = _internal_mutable_serializedsnapshot();
  // @@protoc_insertion_point(field_mutable:flow.access.ProtocolStateSnapshotResponse.serializedSnapshot)
  return _s;
}
inline const std::string& ProtocolStateSnapshotResponse::_internal_serializedsnapshot() const {
  return serializedsnapshot_.Get();
}
inline void ProtocolStateSnapshotResponse::_internal_set_serializedsnapshot(const std::string& value) {
  
  serializedsnapshot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProtocolStateSnapshotResponse::_internal_mutable_serializedsnapshot() {
  
  return serializedsnapshot_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProtocolStateSnapshotResponse::release_serializedsnapshot() {
  // @@protoc_insertion_point(field_release:flow.access.ProtocolStateSnapshotResponse.serializedSnapshot)
  return serializedsnapshot_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProtocolStateSnapshotResponse::set_allocated_serializedsnapshot(std::string* serializedsnapshot) {
  if (serializedsnapshot != nullptr) {
    
  } else {
    
  }
  serializedsnapshot_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serializedsnapshot,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.ProtocolStateSnapshotResponse.serializedSnapshot)
}

// -------------------------------------------------------------------

// GetExecutionResultForBlockIDRequest

// bytes block_id = 1;
inline void GetExecutionResultForBlockIDRequest::clear_block_id() {
  block_id_.ClearToEmpty();
}
inline const std::string& GetExecutionResultForBlockIDRequest::block_id() const {
  // @@protoc_insertion_point(field_get:flow.access.GetExecutionResultForBlockIDRequest.block_id)
  return _internal_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetExecutionResultForBlockIDRequest::set_block_id(ArgT0&& arg0, ArgT... args) {
 
 block_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.GetExecutionResultForBlockIDRequest.block_id)
}
inline std::string* GetExecutionResultForBlockIDRequest::mutable_block_id() {
  std::string* _s = _internal_mutable_block_id();
  // @@protoc_insertion_point(field_mutable:flow.access.GetExecutionResultForBlockIDRequest.block_id)
  return _s;
}
inline const std::string& GetExecutionResultForBlockIDRequest::_internal_block_id() const {
  return block_id_.Get();
}
inline void GetExecutionResultForBlockIDRequest::_internal_set_block_id(const std::string& value) {
  
  block_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetExecutionResultForBlockIDRequest::_internal_mutable_block_id() {
  
  return block_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetExecutionResultForBlockIDRequest::release_block_id() {
  // @@protoc_insertion_point(field_release:flow.access.GetExecutionResultForBlockIDRequest.block_id)
  return block_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetExecutionResultForBlockIDRequest::set_allocated_block_id(std::string* block_id) {
  if (block_id != nullptr) {
    
  } else {
    
  }
  block_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), block_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetExecutionResultForBlockIDRequest.block_id)
}

// -------------------------------------------------------------------

// ExecutionResultForBlockIDResponse

// .flow.entities.ExecutionResult execution_result = 1;
inline bool ExecutionResultForBlockIDResponse::_internal_has_execution_result() const {
  return this != internal_default_instance() && execution_result_ != nullptr;
}
inline bool ExecutionResultForBlockIDResponse::has_execution_result() const {
  return _internal_has_execution_result();
}
inline const ::flow::entities::ExecutionResult& ExecutionResultForBlockIDResponse::_internal_execution_result() const {
  const ::flow::entities::ExecutionResult* p = execution_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow::entities::ExecutionResult&>(
      ::flow::entities::_ExecutionResult_default_instance_);
}
inline const ::flow::entities::ExecutionResult& ExecutionResultForBlockIDResponse::execution_result() const {
  // @@protoc_insertion_point(field_get:flow.access.ExecutionResultForBlockIDResponse.execution_result)
  return _internal_execution_result();
}
inline void ExecutionResultForBlockIDResponse::unsafe_arena_set_allocated_execution_result(
    ::flow::entities::ExecutionResult* execution_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(execution_result_);
  }
  execution_result_ = execution_result;
  if (execution_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow.access.ExecutionResultForBlockIDResponse.execution_result)
}
inline ::flow::entities::ExecutionResult* ExecutionResultForBlockIDResponse::release_execution_result() {
  
  ::flow::entities::ExecutionResult* temp = execution_result_;
  execution_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow::entities::ExecutionResult* ExecutionResultForBlockIDResponse::unsafe_arena_release_execution_result() {
  // @@protoc_insertion_point(field_release:flow.access.ExecutionResultForBlockIDResponse.execution_result)
  
  ::flow::entities::ExecutionResult* temp = execution_result_;
  execution_result_ = nullptr;
  return temp;
}
inline ::flow::entities::ExecutionResult* ExecutionResultForBlockIDResponse::_internal_mutable_execution_result() {
  
  if (execution_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow::entities::ExecutionResult>(GetArenaForAllocation());
    execution_result_ = p;
  }
  return execution_result_;
}
inline ::flow::entities::ExecutionResult* ExecutionResultForBlockIDResponse::mutable_execution_result() {
  ::flow::entities::ExecutionResult* _msg = _internal_mutable_execution_result();
  // @@protoc_insertion_point(field_mutable:flow.access.ExecutionResultForBlockIDResponse.execution_result)
  return _msg;
}
inline void ExecutionResultForBlockIDResponse::set_allocated_execution_result(::flow::entities::ExecutionResult* execution_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(execution_result_);
  }
  if (execution_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(execution_result));
    if (message_arena != submessage_arena) {
      execution_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, execution_result, submessage_arena);
    }
    
  } else {
    
  }
  execution_result_ = execution_result;
  // @@protoc_insertion_point(field_set_allocated:flow.access.ExecutionResultForBlockIDResponse.execution_result)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace access
}  // namespace flow

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_flow_2faccess_2faccess_2eproto
