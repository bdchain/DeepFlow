// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flow/execution/execution.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_flow_2fexecution_2fexecution_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_flow_2fexecution_2fexecution_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "flow/entities/account.pb.h"
#include "flow/entities/block_header.pb.h"
#include "flow/entities/event.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flow_2fexecution_2fexecution_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_flow_2fexecution_2fexecution_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[16]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_flow_2fexecution_2fexecution_2eproto;
namespace flow {
namespace execution {
class BlockHeaderResponse;
struct BlockHeaderResponseDefaultTypeInternal;
extern BlockHeaderResponseDefaultTypeInternal _BlockHeaderResponse_default_instance_;
class ExecuteScriptAtBlockIDRequest;
struct ExecuteScriptAtBlockIDRequestDefaultTypeInternal;
extern ExecuteScriptAtBlockIDRequestDefaultTypeInternal _ExecuteScriptAtBlockIDRequest_default_instance_;
class ExecuteScriptAtBlockIDResponse;
struct ExecuteScriptAtBlockIDResponseDefaultTypeInternal;
extern ExecuteScriptAtBlockIDResponseDefaultTypeInternal _ExecuteScriptAtBlockIDResponse_default_instance_;
class GetAccountAtBlockIDRequest;
struct GetAccountAtBlockIDRequestDefaultTypeInternal;
extern GetAccountAtBlockIDRequestDefaultTypeInternal _GetAccountAtBlockIDRequest_default_instance_;
class GetAccountAtBlockIDResponse;
struct GetAccountAtBlockIDResponseDefaultTypeInternal;
extern GetAccountAtBlockIDResponseDefaultTypeInternal _GetAccountAtBlockIDResponse_default_instance_;
class GetBlockHeaderByIDRequest;
struct GetBlockHeaderByIDRequestDefaultTypeInternal;
extern GetBlockHeaderByIDRequestDefaultTypeInternal _GetBlockHeaderByIDRequest_default_instance_;
class GetEventsForBlockIDsRequest;
struct GetEventsForBlockIDsRequestDefaultTypeInternal;
extern GetEventsForBlockIDsRequestDefaultTypeInternal _GetEventsForBlockIDsRequest_default_instance_;
class GetEventsForBlockIDsResponse;
struct GetEventsForBlockIDsResponseDefaultTypeInternal;
extern GetEventsForBlockIDsResponseDefaultTypeInternal _GetEventsForBlockIDsResponse_default_instance_;
class GetEventsForBlockIDsResponse_Result;
struct GetEventsForBlockIDsResponse_ResultDefaultTypeInternal;
extern GetEventsForBlockIDsResponse_ResultDefaultTypeInternal _GetEventsForBlockIDsResponse_Result_default_instance_;
class GetLatestBlockHeaderRequest;
struct GetLatestBlockHeaderRequestDefaultTypeInternal;
extern GetLatestBlockHeaderRequestDefaultTypeInternal _GetLatestBlockHeaderRequest_default_instance_;
class GetRegisterAtBlockIDRequest;
struct GetRegisterAtBlockIDRequestDefaultTypeInternal;
extern GetRegisterAtBlockIDRequestDefaultTypeInternal _GetRegisterAtBlockIDRequest_default_instance_;
class GetRegisterAtBlockIDResponse;
struct GetRegisterAtBlockIDResponseDefaultTypeInternal;
extern GetRegisterAtBlockIDResponseDefaultTypeInternal _GetRegisterAtBlockIDResponse_default_instance_;
class GetTransactionResultRequest;
struct GetTransactionResultRequestDefaultTypeInternal;
extern GetTransactionResultRequestDefaultTypeInternal _GetTransactionResultRequest_default_instance_;
class GetTransactionResultResponse;
struct GetTransactionResultResponseDefaultTypeInternal;
extern GetTransactionResultResponseDefaultTypeInternal _GetTransactionResultResponse_default_instance_;
class PingRequest;
struct PingRequestDefaultTypeInternal;
extern PingRequestDefaultTypeInternal _PingRequest_default_instance_;
class PingResponse;
struct PingResponseDefaultTypeInternal;
extern PingResponseDefaultTypeInternal _PingResponse_default_instance_;
}  // namespace execution
}  // namespace flow
PROTOBUF_NAMESPACE_OPEN
template<> ::flow::execution::BlockHeaderResponse* Arena::CreateMaybeMessage<::flow::execution::BlockHeaderResponse>(Arena*);
template<> ::flow::execution::ExecuteScriptAtBlockIDRequest* Arena::CreateMaybeMessage<::flow::execution::ExecuteScriptAtBlockIDRequest>(Arena*);
template<> ::flow::execution::ExecuteScriptAtBlockIDResponse* Arena::CreateMaybeMessage<::flow::execution::ExecuteScriptAtBlockIDResponse>(Arena*);
template<> ::flow::execution::GetAccountAtBlockIDRequest* Arena::CreateMaybeMessage<::flow::execution::GetAccountAtBlockIDRequest>(Arena*);
template<> ::flow::execution::GetAccountAtBlockIDResponse* Arena::CreateMaybeMessage<::flow::execution::GetAccountAtBlockIDResponse>(Arena*);
template<> ::flow::execution::GetBlockHeaderByIDRequest* Arena::CreateMaybeMessage<::flow::execution::GetBlockHeaderByIDRequest>(Arena*);
template<> ::flow::execution::GetEventsForBlockIDsRequest* Arena::CreateMaybeMessage<::flow::execution::GetEventsForBlockIDsRequest>(Arena*);
template<> ::flow::execution::GetEventsForBlockIDsResponse* Arena::CreateMaybeMessage<::flow::execution::GetEventsForBlockIDsResponse>(Arena*);
template<> ::flow::execution::GetEventsForBlockIDsResponse_Result* Arena::CreateMaybeMessage<::flow::execution::GetEventsForBlockIDsResponse_Result>(Arena*);
template<> ::flow::execution::GetLatestBlockHeaderRequest* Arena::CreateMaybeMessage<::flow::execution::GetLatestBlockHeaderRequest>(Arena*);
template<> ::flow::execution::GetRegisterAtBlockIDRequest* Arena::CreateMaybeMessage<::flow::execution::GetRegisterAtBlockIDRequest>(Arena*);
template<> ::flow::execution::GetRegisterAtBlockIDResponse* Arena::CreateMaybeMessage<::flow::execution::GetRegisterAtBlockIDResponse>(Arena*);
template<> ::flow::execution::GetTransactionResultRequest* Arena::CreateMaybeMessage<::flow::execution::GetTransactionResultRequest>(Arena*);
template<> ::flow::execution::GetTransactionResultResponse* Arena::CreateMaybeMessage<::flow::execution::GetTransactionResultResponse>(Arena*);
template<> ::flow::execution::PingRequest* Arena::CreateMaybeMessage<::flow::execution::PingRequest>(Arena*);
template<> ::flow::execution::PingResponse* Arena::CreateMaybeMessage<::flow::execution::PingResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace flow {
namespace execution {

// ===================================================================

class PingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:flow.execution.PingRequest) */ {
 public:
  inline PingRequest() : PingRequest(nullptr) {}
  explicit constexpr PingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingRequest(const PingRequest& from);
  PingRequest(PingRequest&& from) noexcept
    : PingRequest() {
    *this = ::std::move(from);
  }

  inline PingRequest& operator=(const PingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingRequest& operator=(PingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingRequest* internal_default_instance() {
    return reinterpret_cast<const PingRequest*>(
               &_PingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PingRequest& a, PingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PingRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PingRequest* New() const final {
    return new PingRequest();
  }

  PingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PingRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PingRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.execution.PingRequest";
  }
  protected:
  explicit PingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flow.execution.PingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2fexecution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class PingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:flow.execution.PingResponse) */ {
 public:
  inline PingResponse() : PingResponse(nullptr) {}
  explicit constexpr PingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingResponse(const PingResponse& from);
  PingResponse(PingResponse&& from) noexcept
    : PingResponse() {
    *this = ::std::move(from);
  }

  inline PingResponse& operator=(const PingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingResponse& operator=(PingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingResponse* internal_default_instance() {
    return reinterpret_cast<const PingResponse*>(
               &_PingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PingResponse& a, PingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PingResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PingResponse* New() const final {
    return new PingResponse();
  }

  PingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PingResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PingResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.execution.PingResponse";
  }
  protected:
  explicit PingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flow.execution.PingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2fexecution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetAccountAtBlockIDRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.execution.GetAccountAtBlockIDRequest) */ {
 public:
  inline GetAccountAtBlockIDRequest() : GetAccountAtBlockIDRequest(nullptr) {}
  ~GetAccountAtBlockIDRequest() override;
  explicit constexpr GetAccountAtBlockIDRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAccountAtBlockIDRequest(const GetAccountAtBlockIDRequest& from);
  GetAccountAtBlockIDRequest(GetAccountAtBlockIDRequest&& from) noexcept
    : GetAccountAtBlockIDRequest() {
    *this = ::std::move(from);
  }

  inline GetAccountAtBlockIDRequest& operator=(const GetAccountAtBlockIDRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountAtBlockIDRequest& operator=(GetAccountAtBlockIDRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAccountAtBlockIDRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAccountAtBlockIDRequest* internal_default_instance() {
    return reinterpret_cast<const GetAccountAtBlockIDRequest*>(
               &_GetAccountAtBlockIDRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetAccountAtBlockIDRequest& a, GetAccountAtBlockIDRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAccountAtBlockIDRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAccountAtBlockIDRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetAccountAtBlockIDRequest* New() const final {
    return new GetAccountAtBlockIDRequest();
  }

  GetAccountAtBlockIDRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetAccountAtBlockIDRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAccountAtBlockIDRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetAccountAtBlockIDRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccountAtBlockIDRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.execution.GetAccountAtBlockIDRequest";
  }
  protected:
  explicit GetAccountAtBlockIDRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockIdFieldNumber = 1,
    kAddressFieldNumber = 2,
  };
  // bytes block_id = 1;
  void clear_block_id();
  const std::string& block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_block_id();
  void set_allocated_block_id(std::string* block_id);
  private:
  const std::string& _internal_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_id(const std::string& value);
  std::string* _internal_mutable_block_id();
  public:

  // bytes address = 2;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:flow.execution.GetAccountAtBlockIDRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2fexecution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetAccountAtBlockIDResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.execution.GetAccountAtBlockIDResponse) */ {
 public:
  inline GetAccountAtBlockIDResponse() : GetAccountAtBlockIDResponse(nullptr) {}
  ~GetAccountAtBlockIDResponse() override;
  explicit constexpr GetAccountAtBlockIDResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAccountAtBlockIDResponse(const GetAccountAtBlockIDResponse& from);
  GetAccountAtBlockIDResponse(GetAccountAtBlockIDResponse&& from) noexcept
    : GetAccountAtBlockIDResponse() {
    *this = ::std::move(from);
  }

  inline GetAccountAtBlockIDResponse& operator=(const GetAccountAtBlockIDResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountAtBlockIDResponse& operator=(GetAccountAtBlockIDResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAccountAtBlockIDResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAccountAtBlockIDResponse* internal_default_instance() {
    return reinterpret_cast<const GetAccountAtBlockIDResponse*>(
               &_GetAccountAtBlockIDResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetAccountAtBlockIDResponse& a, GetAccountAtBlockIDResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAccountAtBlockIDResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAccountAtBlockIDResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetAccountAtBlockIDResponse* New() const final {
    return new GetAccountAtBlockIDResponse();
  }

  GetAccountAtBlockIDResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetAccountAtBlockIDResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAccountAtBlockIDResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetAccountAtBlockIDResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccountAtBlockIDResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.execution.GetAccountAtBlockIDResponse";
  }
  protected:
  explicit GetAccountAtBlockIDResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
  };
  // .flow.entities.Account account = 1;
  bool has_account() const;
  private:
  bool _internal_has_account() const;
  public:
  void clear_account();
  const ::flow::entities::Account& account() const;
  PROTOBUF_MUST_USE_RESULT ::flow::entities::Account* release_account();
  ::flow::entities::Account* mutable_account();
  void set_allocated_account(::flow::entities::Account* account);
  private:
  const ::flow::entities::Account& _internal_account() const;
  ::flow::entities::Account* _internal_mutable_account();
  public:
  void unsafe_arena_set_allocated_account(
      ::flow::entities::Account* account);
  ::flow::entities::Account* unsafe_arena_release_account();

  // @@protoc_insertion_point(class_scope:flow.execution.GetAccountAtBlockIDResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flow::entities::Account* account_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2fexecution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class ExecuteScriptAtBlockIDRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.execution.ExecuteScriptAtBlockIDRequest) */ {
 public:
  inline ExecuteScriptAtBlockIDRequest() : ExecuteScriptAtBlockIDRequest(nullptr) {}
  ~ExecuteScriptAtBlockIDRequest() override;
  explicit constexpr ExecuteScriptAtBlockIDRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteScriptAtBlockIDRequest(const ExecuteScriptAtBlockIDRequest& from);
  ExecuteScriptAtBlockIDRequest(ExecuteScriptAtBlockIDRequest&& from) noexcept
    : ExecuteScriptAtBlockIDRequest() {
    *this = ::std::move(from);
  }

  inline ExecuteScriptAtBlockIDRequest& operator=(const ExecuteScriptAtBlockIDRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteScriptAtBlockIDRequest& operator=(ExecuteScriptAtBlockIDRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteScriptAtBlockIDRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteScriptAtBlockIDRequest* internal_default_instance() {
    return reinterpret_cast<const ExecuteScriptAtBlockIDRequest*>(
               &_ExecuteScriptAtBlockIDRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ExecuteScriptAtBlockIDRequest& a, ExecuteScriptAtBlockIDRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteScriptAtBlockIDRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteScriptAtBlockIDRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExecuteScriptAtBlockIDRequest* New() const final {
    return new ExecuteScriptAtBlockIDRequest();
  }

  ExecuteScriptAtBlockIDRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExecuteScriptAtBlockIDRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteScriptAtBlockIDRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExecuteScriptAtBlockIDRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteScriptAtBlockIDRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.execution.ExecuteScriptAtBlockIDRequest";
  }
  protected:
  explicit ExecuteScriptAtBlockIDRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgumentsFieldNumber = 3,
    kBlockIdFieldNumber = 1,
    kScriptFieldNumber = 2,
  };
  // repeated bytes arguments = 3;
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;
  public:
  void clear_arguments();
  const std::string& arguments(int index) const;
  std::string* mutable_arguments(int index);
  void set_arguments(int index, const std::string& value);
  void set_arguments(int index, std::string&& value);
  void set_arguments(int index, const char* value);
  void set_arguments(int index, const void* value, size_t size);
  std::string* add_arguments();
  void add_arguments(const std::string& value);
  void add_arguments(std::string&& value);
  void add_arguments(const char* value);
  void add_arguments(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& arguments() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_arguments();
  private:
  const std::string& _internal_arguments(int index) const;
  std::string* _internal_add_arguments();
  public:

  // bytes block_id = 1;
  void clear_block_id();
  const std::string& block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_block_id();
  void set_allocated_block_id(std::string* block_id);
  private:
  const std::string& _internal_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_id(const std::string& value);
  std::string* _internal_mutable_block_id();
  public:

  // bytes script = 2;
  void clear_script();
  const std::string& script() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_script(ArgT0&& arg0, ArgT... args);
  std::string* mutable_script();
  PROTOBUF_MUST_USE_RESULT std::string* release_script();
  void set_allocated_script(std::string* script);
  private:
  const std::string& _internal_script() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_script(const std::string& value);
  std::string* _internal_mutable_script();
  public:

  // @@protoc_insertion_point(class_scope:flow.execution.ExecuteScriptAtBlockIDRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> arguments_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr script_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2fexecution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class ExecuteScriptAtBlockIDResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.execution.ExecuteScriptAtBlockIDResponse) */ {
 public:
  inline ExecuteScriptAtBlockIDResponse() : ExecuteScriptAtBlockIDResponse(nullptr) {}
  ~ExecuteScriptAtBlockIDResponse() override;
  explicit constexpr ExecuteScriptAtBlockIDResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteScriptAtBlockIDResponse(const ExecuteScriptAtBlockIDResponse& from);
  ExecuteScriptAtBlockIDResponse(ExecuteScriptAtBlockIDResponse&& from) noexcept
    : ExecuteScriptAtBlockIDResponse() {
    *this = ::std::move(from);
  }

  inline ExecuteScriptAtBlockIDResponse& operator=(const ExecuteScriptAtBlockIDResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteScriptAtBlockIDResponse& operator=(ExecuteScriptAtBlockIDResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteScriptAtBlockIDResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteScriptAtBlockIDResponse* internal_default_instance() {
    return reinterpret_cast<const ExecuteScriptAtBlockIDResponse*>(
               &_ExecuteScriptAtBlockIDResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ExecuteScriptAtBlockIDResponse& a, ExecuteScriptAtBlockIDResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteScriptAtBlockIDResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteScriptAtBlockIDResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExecuteScriptAtBlockIDResponse* New() const final {
    return new ExecuteScriptAtBlockIDResponse();
  }

  ExecuteScriptAtBlockIDResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExecuteScriptAtBlockIDResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteScriptAtBlockIDResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExecuteScriptAtBlockIDResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteScriptAtBlockIDResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.execution.ExecuteScriptAtBlockIDResponse";
  }
  protected:
  explicit ExecuteScriptAtBlockIDResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:flow.execution.ExecuteScriptAtBlockIDResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2fexecution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetEventsForBlockIDsResponse_Result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.execution.GetEventsForBlockIDsResponse.Result) */ {
 public:
  inline GetEventsForBlockIDsResponse_Result() : GetEventsForBlockIDsResponse_Result(nullptr) {}
  ~GetEventsForBlockIDsResponse_Result() override;
  explicit constexpr GetEventsForBlockIDsResponse_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEventsForBlockIDsResponse_Result(const GetEventsForBlockIDsResponse_Result& from);
  GetEventsForBlockIDsResponse_Result(GetEventsForBlockIDsResponse_Result&& from) noexcept
    : GetEventsForBlockIDsResponse_Result() {
    *this = ::std::move(from);
  }

  inline GetEventsForBlockIDsResponse_Result& operator=(const GetEventsForBlockIDsResponse_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEventsForBlockIDsResponse_Result& operator=(GetEventsForBlockIDsResponse_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEventsForBlockIDsResponse_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEventsForBlockIDsResponse_Result* internal_default_instance() {
    return reinterpret_cast<const GetEventsForBlockIDsResponse_Result*>(
               &_GetEventsForBlockIDsResponse_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetEventsForBlockIDsResponse_Result& a, GetEventsForBlockIDsResponse_Result& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEventsForBlockIDsResponse_Result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEventsForBlockIDsResponse_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetEventsForBlockIDsResponse_Result* New() const final {
    return new GetEventsForBlockIDsResponse_Result();
  }

  GetEventsForBlockIDsResponse_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetEventsForBlockIDsResponse_Result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEventsForBlockIDsResponse_Result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetEventsForBlockIDsResponse_Result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEventsForBlockIDsResponse_Result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.execution.GetEventsForBlockIDsResponse.Result";
  }
  protected:
  explicit GetEventsForBlockIDsResponse_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 3,
    kBlockIdFieldNumber = 1,
    kBlockHeightFieldNumber = 2,
  };
  // repeated .flow.entities.Event events = 3;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::flow::entities::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::entities::Event >*
      mutable_events();
  private:
  const ::flow::entities::Event& _internal_events(int index) const;
  ::flow::entities::Event* _internal_add_events();
  public:
  const ::flow::entities::Event& events(int index) const;
  ::flow::entities::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::entities::Event >&
      events() const;

  // bytes block_id = 1;
  void clear_block_id();
  const std::string& block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_block_id();
  void set_allocated_block_id(std::string* block_id);
  private:
  const std::string& _internal_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_id(const std::string& value);
  std::string* _internal_mutable_block_id();
  public:

  // uint64 block_height = 2;
  void clear_block_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 block_height() const;
  void set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_block_height() const;
  void _internal_set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.execution.GetEventsForBlockIDsResponse.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::entities::Event > events_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 block_height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2fexecution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetEventsForBlockIDsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.execution.GetEventsForBlockIDsResponse) */ {
 public:
  inline GetEventsForBlockIDsResponse() : GetEventsForBlockIDsResponse(nullptr) {}
  ~GetEventsForBlockIDsResponse() override;
  explicit constexpr GetEventsForBlockIDsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEventsForBlockIDsResponse(const GetEventsForBlockIDsResponse& from);
  GetEventsForBlockIDsResponse(GetEventsForBlockIDsResponse&& from) noexcept
    : GetEventsForBlockIDsResponse() {
    *this = ::std::move(from);
  }

  inline GetEventsForBlockIDsResponse& operator=(const GetEventsForBlockIDsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEventsForBlockIDsResponse& operator=(GetEventsForBlockIDsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEventsForBlockIDsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEventsForBlockIDsResponse* internal_default_instance() {
    return reinterpret_cast<const GetEventsForBlockIDsResponse*>(
               &_GetEventsForBlockIDsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetEventsForBlockIDsResponse& a, GetEventsForBlockIDsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEventsForBlockIDsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEventsForBlockIDsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetEventsForBlockIDsResponse* New() const final {
    return new GetEventsForBlockIDsResponse();
  }

  GetEventsForBlockIDsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetEventsForBlockIDsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEventsForBlockIDsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetEventsForBlockIDsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEventsForBlockIDsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.execution.GetEventsForBlockIDsResponse";
  }
  protected:
  explicit GetEventsForBlockIDsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetEventsForBlockIDsResponse_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .flow.execution.GetEventsForBlockIDsResponse.Result results = 1;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::flow::execution::GetEventsForBlockIDsResponse_Result* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::execution::GetEventsForBlockIDsResponse_Result >*
      mutable_results();
  private:
  const ::flow::execution::GetEventsForBlockIDsResponse_Result& _internal_results(int index) const;
  ::flow::execution::GetEventsForBlockIDsResponse_Result* _internal_add_results();
  public:
  const ::flow::execution::GetEventsForBlockIDsResponse_Result& results(int index) const;
  ::flow::execution::GetEventsForBlockIDsResponse_Result* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::execution::GetEventsForBlockIDsResponse_Result >&
      results() const;

  // @@protoc_insertion_point(class_scope:flow.execution.GetEventsForBlockIDsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::execution::GetEventsForBlockIDsResponse_Result > results_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2fexecution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetEventsForBlockIDsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.execution.GetEventsForBlockIDsRequest) */ {
 public:
  inline GetEventsForBlockIDsRequest() : GetEventsForBlockIDsRequest(nullptr) {}
  ~GetEventsForBlockIDsRequest() override;
  explicit constexpr GetEventsForBlockIDsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEventsForBlockIDsRequest(const GetEventsForBlockIDsRequest& from);
  GetEventsForBlockIDsRequest(GetEventsForBlockIDsRequest&& from) noexcept
    : GetEventsForBlockIDsRequest() {
    *this = ::std::move(from);
  }

  inline GetEventsForBlockIDsRequest& operator=(const GetEventsForBlockIDsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEventsForBlockIDsRequest& operator=(GetEventsForBlockIDsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEventsForBlockIDsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEventsForBlockIDsRequest* internal_default_instance() {
    return reinterpret_cast<const GetEventsForBlockIDsRequest*>(
               &_GetEventsForBlockIDsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetEventsForBlockIDsRequest& a, GetEventsForBlockIDsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEventsForBlockIDsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEventsForBlockIDsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetEventsForBlockIDsRequest* New() const final {
    return new GetEventsForBlockIDsRequest();
  }

  GetEventsForBlockIDsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetEventsForBlockIDsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEventsForBlockIDsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetEventsForBlockIDsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEventsForBlockIDsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.execution.GetEventsForBlockIDsRequest";
  }
  protected:
  explicit GetEventsForBlockIDsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockIdsFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated bytes block_ids = 2;
  int block_ids_size() const;
  private:
  int _internal_block_ids_size() const;
  public:
  void clear_block_ids();
  const std::string& block_ids(int index) const;
  std::string* mutable_block_ids(int index);
  void set_block_ids(int index, const std::string& value);
  void set_block_ids(int index, std::string&& value);
  void set_block_ids(int index, const char* value);
  void set_block_ids(int index, const void* value, size_t size);
  std::string* add_block_ids();
  void add_block_ids(const std::string& value);
  void add_block_ids(std::string&& value);
  void add_block_ids(const char* value);
  void add_block_ids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& block_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_block_ids();
  private:
  const std::string& _internal_block_ids(int index) const;
  std::string* _internal_add_block_ids();
  public:

  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:flow.execution.GetEventsForBlockIDsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> block_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2fexecution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetTransactionResultRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.execution.GetTransactionResultRequest) */ {
 public:
  inline GetTransactionResultRequest() : GetTransactionResultRequest(nullptr) {}
  ~GetTransactionResultRequest() override;
  explicit constexpr GetTransactionResultRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTransactionResultRequest(const GetTransactionResultRequest& from);
  GetTransactionResultRequest(GetTransactionResultRequest&& from) noexcept
    : GetTransactionResultRequest() {
    *this = ::std::move(from);
  }

  inline GetTransactionResultRequest& operator=(const GetTransactionResultRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTransactionResultRequest& operator=(GetTransactionResultRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTransactionResultRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTransactionResultRequest* internal_default_instance() {
    return reinterpret_cast<const GetTransactionResultRequest*>(
               &_GetTransactionResultRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetTransactionResultRequest& a, GetTransactionResultRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTransactionResultRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTransactionResultRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTransactionResultRequest* New() const final {
    return new GetTransactionResultRequest();
  }

  GetTransactionResultRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTransactionResultRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTransactionResultRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTransactionResultRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTransactionResultRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.execution.GetTransactionResultRequest";
  }
  protected:
  explicit GetTransactionResultRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockIdFieldNumber = 1,
    kTransactionIdFieldNumber = 2,
  };
  // bytes block_id = 1;
  void clear_block_id();
  const std::string& block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_block_id();
  void set_allocated_block_id(std::string* block_id);
  private:
  const std::string& _internal_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_id(const std::string& value);
  std::string* _internal_mutable_block_id();
  public:

  // bytes transaction_id = 2;
  void clear_transaction_id();
  const std::string& transaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transaction_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* transaction_id);
  private:
  const std::string& _internal_transaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();
  public:

  // @@protoc_insertion_point(class_scope:flow.execution.GetTransactionResultRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transaction_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2fexecution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetTransactionResultResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.execution.GetTransactionResultResponse) */ {
 public:
  inline GetTransactionResultResponse() : GetTransactionResultResponse(nullptr) {}
  ~GetTransactionResultResponse() override;
  explicit constexpr GetTransactionResultResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTransactionResultResponse(const GetTransactionResultResponse& from);
  GetTransactionResultResponse(GetTransactionResultResponse&& from) noexcept
    : GetTransactionResultResponse() {
    *this = ::std::move(from);
  }

  inline GetTransactionResultResponse& operator=(const GetTransactionResultResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTransactionResultResponse& operator=(GetTransactionResultResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTransactionResultResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTransactionResultResponse* internal_default_instance() {
    return reinterpret_cast<const GetTransactionResultResponse*>(
               &_GetTransactionResultResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetTransactionResultResponse& a, GetTransactionResultResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTransactionResultResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTransactionResultResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTransactionResultResponse* New() const final {
    return new GetTransactionResultResponse();
  }

  GetTransactionResultResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTransactionResultResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTransactionResultResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTransactionResultResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTransactionResultResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.execution.GetTransactionResultResponse";
  }
  protected:
  explicit GetTransactionResultResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 3,
    kErrorMessageFieldNumber = 2,
    kStatusCodeFieldNumber = 1,
  };
  // repeated .flow.entities.Event events = 3;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::flow::entities::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::entities::Event >*
      mutable_events();
  private:
  const ::flow::entities::Event& _internal_events(int index) const;
  ::flow::entities::Event* _internal_add_events();
  public:
  const ::flow::entities::Event& events(int index) const;
  ::flow::entities::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::entities::Event >&
      events() const;

  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // uint32 status_code = 1;
  void clear_status_code();
  ::PROTOBUF_NAMESPACE_ID::uint32 status_code() const;
  void set_status_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_status_code() const;
  void _internal_set_status_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.execution.GetTransactionResultResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::entities::Event > events_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::PROTOBUF_NAMESPACE_ID::uint32 status_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2fexecution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetRegisterAtBlockIDRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.execution.GetRegisterAtBlockIDRequest) */ {
 public:
  inline GetRegisterAtBlockIDRequest() : GetRegisterAtBlockIDRequest(nullptr) {}
  ~GetRegisterAtBlockIDRequest() override;
  explicit constexpr GetRegisterAtBlockIDRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRegisterAtBlockIDRequest(const GetRegisterAtBlockIDRequest& from);
  GetRegisterAtBlockIDRequest(GetRegisterAtBlockIDRequest&& from) noexcept
    : GetRegisterAtBlockIDRequest() {
    *this = ::std::move(from);
  }

  inline GetRegisterAtBlockIDRequest& operator=(const GetRegisterAtBlockIDRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRegisterAtBlockIDRequest& operator=(GetRegisterAtBlockIDRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRegisterAtBlockIDRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRegisterAtBlockIDRequest* internal_default_instance() {
    return reinterpret_cast<const GetRegisterAtBlockIDRequest*>(
               &_GetRegisterAtBlockIDRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetRegisterAtBlockIDRequest& a, GetRegisterAtBlockIDRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRegisterAtBlockIDRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRegisterAtBlockIDRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetRegisterAtBlockIDRequest* New() const final {
    return new GetRegisterAtBlockIDRequest();
  }

  GetRegisterAtBlockIDRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRegisterAtBlockIDRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRegisterAtBlockIDRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRegisterAtBlockIDRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRegisterAtBlockIDRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.execution.GetRegisterAtBlockIDRequest";
  }
  protected:
  explicit GetRegisterAtBlockIDRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockIdFieldNumber = 1,
    kRegisterOwnerFieldNumber = 2,
    kRegisterControllerFieldNumber = 3,
    kRegisterKeyFieldNumber = 4,
  };
  // bytes block_id = 1;
  void clear_block_id();
  const std::string& block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_block_id();
  void set_allocated_block_id(std::string* block_id);
  private:
  const std::string& _internal_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_id(const std::string& value);
  std::string* _internal_mutable_block_id();
  public:

  // bytes register_owner = 2;
  void clear_register_owner();
  const std::string& register_owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_register_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_register_owner();
  PROTOBUF_MUST_USE_RESULT std::string* release_register_owner();
  void set_allocated_register_owner(std::string* register_owner);
  private:
  const std::string& _internal_register_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_register_owner(const std::string& value);
  std::string* _internal_mutable_register_owner();
  public:

  // bytes register_controller = 3;
  void clear_register_controller();
  const std::string& register_controller() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_register_controller(ArgT0&& arg0, ArgT... args);
  std::string* mutable_register_controller();
  PROTOBUF_MUST_USE_RESULT std::string* release_register_controller();
  void set_allocated_register_controller(std::string* register_controller);
  private:
  const std::string& _internal_register_controller() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_register_controller(const std::string& value);
  std::string* _internal_mutable_register_controller();
  public:

  // bytes register_key = 4;
  void clear_register_key();
  const std::string& register_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_register_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_register_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_register_key();
  void set_allocated_register_key(std::string* register_key);
  private:
  const std::string& _internal_register_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_register_key(const std::string& value);
  std::string* _internal_mutable_register_key();
  public:

  // @@protoc_insertion_point(class_scope:flow.execution.GetRegisterAtBlockIDRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr register_owner_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr register_controller_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr register_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2fexecution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetRegisterAtBlockIDResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.execution.GetRegisterAtBlockIDResponse) */ {
 public:
  inline GetRegisterAtBlockIDResponse() : GetRegisterAtBlockIDResponse(nullptr) {}
  ~GetRegisterAtBlockIDResponse() override;
  explicit constexpr GetRegisterAtBlockIDResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRegisterAtBlockIDResponse(const GetRegisterAtBlockIDResponse& from);
  GetRegisterAtBlockIDResponse(GetRegisterAtBlockIDResponse&& from) noexcept
    : GetRegisterAtBlockIDResponse() {
    *this = ::std::move(from);
  }

  inline GetRegisterAtBlockIDResponse& operator=(const GetRegisterAtBlockIDResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRegisterAtBlockIDResponse& operator=(GetRegisterAtBlockIDResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRegisterAtBlockIDResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRegisterAtBlockIDResponse* internal_default_instance() {
    return reinterpret_cast<const GetRegisterAtBlockIDResponse*>(
               &_GetRegisterAtBlockIDResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetRegisterAtBlockIDResponse& a, GetRegisterAtBlockIDResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRegisterAtBlockIDResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRegisterAtBlockIDResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetRegisterAtBlockIDResponse* New() const final {
    return new GetRegisterAtBlockIDResponse();
  }

  GetRegisterAtBlockIDResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRegisterAtBlockIDResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRegisterAtBlockIDResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRegisterAtBlockIDResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRegisterAtBlockIDResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.execution.GetRegisterAtBlockIDResponse";
  }
  protected:
  explicit GetRegisterAtBlockIDResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:flow.execution.GetRegisterAtBlockIDResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2fexecution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetLatestBlockHeaderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.execution.GetLatestBlockHeaderRequest) */ {
 public:
  inline GetLatestBlockHeaderRequest() : GetLatestBlockHeaderRequest(nullptr) {}
  ~GetLatestBlockHeaderRequest() override;
  explicit constexpr GetLatestBlockHeaderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLatestBlockHeaderRequest(const GetLatestBlockHeaderRequest& from);
  GetLatestBlockHeaderRequest(GetLatestBlockHeaderRequest&& from) noexcept
    : GetLatestBlockHeaderRequest() {
    *this = ::std::move(from);
  }

  inline GetLatestBlockHeaderRequest& operator=(const GetLatestBlockHeaderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLatestBlockHeaderRequest& operator=(GetLatestBlockHeaderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLatestBlockHeaderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLatestBlockHeaderRequest* internal_default_instance() {
    return reinterpret_cast<const GetLatestBlockHeaderRequest*>(
               &_GetLatestBlockHeaderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetLatestBlockHeaderRequest& a, GetLatestBlockHeaderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLatestBlockHeaderRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLatestBlockHeaderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetLatestBlockHeaderRequest* New() const final {
    return new GetLatestBlockHeaderRequest();
  }

  GetLatestBlockHeaderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetLatestBlockHeaderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLatestBlockHeaderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetLatestBlockHeaderRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLatestBlockHeaderRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.execution.GetLatestBlockHeaderRequest";
  }
  protected:
  explicit GetLatestBlockHeaderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsSealedFieldNumber = 1,
  };
  // bool is_sealed = 1;
  void clear_is_sealed();
  bool is_sealed() const;
  void set_is_sealed(bool value);
  private:
  bool _internal_is_sealed() const;
  void _internal_set_is_sealed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:flow.execution.GetLatestBlockHeaderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_sealed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2fexecution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetBlockHeaderByIDRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.execution.GetBlockHeaderByIDRequest) */ {
 public:
  inline GetBlockHeaderByIDRequest() : GetBlockHeaderByIDRequest(nullptr) {}
  ~GetBlockHeaderByIDRequest() override;
  explicit constexpr GetBlockHeaderByIDRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlockHeaderByIDRequest(const GetBlockHeaderByIDRequest& from);
  GetBlockHeaderByIDRequest(GetBlockHeaderByIDRequest&& from) noexcept
    : GetBlockHeaderByIDRequest() {
    *this = ::std::move(from);
  }

  inline GetBlockHeaderByIDRequest& operator=(const GetBlockHeaderByIDRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlockHeaderByIDRequest& operator=(GetBlockHeaderByIDRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlockHeaderByIDRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlockHeaderByIDRequest* internal_default_instance() {
    return reinterpret_cast<const GetBlockHeaderByIDRequest*>(
               &_GetBlockHeaderByIDRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetBlockHeaderByIDRequest& a, GetBlockHeaderByIDRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlockHeaderByIDRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlockHeaderByIDRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetBlockHeaderByIDRequest* New() const final {
    return new GetBlockHeaderByIDRequest();
  }

  GetBlockHeaderByIDRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetBlockHeaderByIDRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlockHeaderByIDRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBlockHeaderByIDRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockHeaderByIDRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.execution.GetBlockHeaderByIDRequest";
  }
  protected:
  explicit GetBlockHeaderByIDRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:flow.execution.GetBlockHeaderByIDRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2fexecution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class BlockHeaderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.execution.BlockHeaderResponse) */ {
 public:
  inline BlockHeaderResponse() : BlockHeaderResponse(nullptr) {}
  ~BlockHeaderResponse() override;
  explicit constexpr BlockHeaderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockHeaderResponse(const BlockHeaderResponse& from);
  BlockHeaderResponse(BlockHeaderResponse&& from) noexcept
    : BlockHeaderResponse() {
    *this = ::std::move(from);
  }

  inline BlockHeaderResponse& operator=(const BlockHeaderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockHeaderResponse& operator=(BlockHeaderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockHeaderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockHeaderResponse* internal_default_instance() {
    return reinterpret_cast<const BlockHeaderResponse*>(
               &_BlockHeaderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(BlockHeaderResponse& a, BlockHeaderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockHeaderResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockHeaderResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockHeaderResponse* New() const final {
    return new BlockHeaderResponse();
  }

  BlockHeaderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockHeaderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockHeaderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockHeaderResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockHeaderResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.execution.BlockHeaderResponse";
  }
  protected:
  explicit BlockHeaderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockFieldNumber = 1,
  };
  // .flow.entities.BlockHeader block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::flow::entities::BlockHeader& block() const;
  PROTOBUF_MUST_USE_RESULT ::flow::entities::BlockHeader* release_block();
  ::flow::entities::BlockHeader* mutable_block();
  void set_allocated_block(::flow::entities::BlockHeader* block);
  private:
  const ::flow::entities::BlockHeader& _internal_block() const;
  ::flow::entities::BlockHeader* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::flow::entities::BlockHeader* block);
  ::flow::entities::BlockHeader* unsafe_arena_release_block();

  // @@protoc_insertion_point(class_scope:flow.execution.BlockHeaderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flow::entities::BlockHeader* block_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2fexecution_2fexecution_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PingRequest

// -------------------------------------------------------------------

// PingResponse

// -------------------------------------------------------------------

// GetAccountAtBlockIDRequest

// bytes block_id = 1;
inline void GetAccountAtBlockIDRequest::clear_block_id() {
  block_id_.ClearToEmpty();
}
inline const std::string& GetAccountAtBlockIDRequest::block_id() const {
  // @@protoc_insertion_point(field_get:flow.execution.GetAccountAtBlockIDRequest.block_id)
  return _internal_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAccountAtBlockIDRequest::set_block_id(ArgT0&& arg0, ArgT... args) {
 
 block_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.execution.GetAccountAtBlockIDRequest.block_id)
}
inline std::string* GetAccountAtBlockIDRequest::mutable_block_id() {
  std::string* _s = _internal_mutable_block_id();
  // @@protoc_insertion_point(field_mutable:flow.execution.GetAccountAtBlockIDRequest.block_id)
  return _s;
}
inline const std::string& GetAccountAtBlockIDRequest::_internal_block_id() const {
  return block_id_.Get();
}
inline void GetAccountAtBlockIDRequest::_internal_set_block_id(const std::string& value) {
  
  block_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetAccountAtBlockIDRequest::_internal_mutable_block_id() {
  
  return block_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetAccountAtBlockIDRequest::release_block_id() {
  // @@protoc_insertion_point(field_release:flow.execution.GetAccountAtBlockIDRequest.block_id)
  return block_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetAccountAtBlockIDRequest::set_allocated_block_id(std::string* block_id) {
  if (block_id != nullptr) {
    
  } else {
    
  }
  block_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), block_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.execution.GetAccountAtBlockIDRequest.block_id)
}

// bytes address = 2;
inline void GetAccountAtBlockIDRequest::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& GetAccountAtBlockIDRequest::address() const {
  // @@protoc_insertion_point(field_get:flow.execution.GetAccountAtBlockIDRequest.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAccountAtBlockIDRequest::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.execution.GetAccountAtBlockIDRequest.address)
}
inline std::string* GetAccountAtBlockIDRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:flow.execution.GetAccountAtBlockIDRequest.address)
  return _s;
}
inline const std::string& GetAccountAtBlockIDRequest::_internal_address() const {
  return address_.Get();
}
inline void GetAccountAtBlockIDRequest::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetAccountAtBlockIDRequest::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetAccountAtBlockIDRequest::release_address() {
  // @@protoc_insertion_point(field_release:flow.execution.GetAccountAtBlockIDRequest.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetAccountAtBlockIDRequest::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.execution.GetAccountAtBlockIDRequest.address)
}

// -------------------------------------------------------------------

// GetAccountAtBlockIDResponse

// .flow.entities.Account account = 1;
inline bool GetAccountAtBlockIDResponse::_internal_has_account() const {
  return this != internal_default_instance() && account_ != nullptr;
}
inline bool GetAccountAtBlockIDResponse::has_account() const {
  return _internal_has_account();
}
inline const ::flow::entities::Account& GetAccountAtBlockIDResponse::_internal_account() const {
  const ::flow::entities::Account* p = account_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow::entities::Account&>(
      ::flow::entities::_Account_default_instance_);
}
inline const ::flow::entities::Account& GetAccountAtBlockIDResponse::account() const {
  // @@protoc_insertion_point(field_get:flow.execution.GetAccountAtBlockIDResponse.account)
  return _internal_account();
}
inline void GetAccountAtBlockIDResponse::unsafe_arena_set_allocated_account(
    ::flow::entities::Account* account) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  account_ = account;
  if (account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow.execution.GetAccountAtBlockIDResponse.account)
}
inline ::flow::entities::Account* GetAccountAtBlockIDResponse::release_account() {
  
  ::flow::entities::Account* temp = account_;
  account_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow::entities::Account* GetAccountAtBlockIDResponse::unsafe_arena_release_account() {
  // @@protoc_insertion_point(field_release:flow.execution.GetAccountAtBlockIDResponse.account)
  
  ::flow::entities::Account* temp = account_;
  account_ = nullptr;
  return temp;
}
inline ::flow::entities::Account* GetAccountAtBlockIDResponse::_internal_mutable_account() {
  
  if (account_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow::entities::Account>(GetArenaForAllocation());
    account_ = p;
  }
  return account_;
}
inline ::flow::entities::Account* GetAccountAtBlockIDResponse::mutable_account() {
  ::flow::entities::Account* _msg = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:flow.execution.GetAccountAtBlockIDResponse.account)
  return _msg;
}
inline void GetAccountAtBlockIDResponse::set_allocated_account(::flow::entities::Account* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(account));
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:flow.execution.GetAccountAtBlockIDResponse.account)
}

// -------------------------------------------------------------------

// ExecuteScriptAtBlockIDRequest

// bytes block_id = 1;
inline void ExecuteScriptAtBlockIDRequest::clear_block_id() {
  block_id_.ClearToEmpty();
}
inline const std::string& ExecuteScriptAtBlockIDRequest::block_id() const {
  // @@protoc_insertion_point(field_get:flow.execution.ExecuteScriptAtBlockIDRequest.block_id)
  return _internal_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteScriptAtBlockIDRequest::set_block_id(ArgT0&& arg0, ArgT... args) {
 
 block_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.execution.ExecuteScriptAtBlockIDRequest.block_id)
}
inline std::string* ExecuteScriptAtBlockIDRequest::mutable_block_id() {
  std::string* _s = _internal_mutable_block_id();
  // @@protoc_insertion_point(field_mutable:flow.execution.ExecuteScriptAtBlockIDRequest.block_id)
  return _s;
}
inline const std::string& ExecuteScriptAtBlockIDRequest::_internal_block_id() const {
  return block_id_.Get();
}
inline void ExecuteScriptAtBlockIDRequest::_internal_set_block_id(const std::string& value) {
  
  block_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtBlockIDRequest::_internal_mutable_block_id() {
  
  return block_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtBlockIDRequest::release_block_id() {
  // @@protoc_insertion_point(field_release:flow.execution.ExecuteScriptAtBlockIDRequest.block_id)
  return block_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecuteScriptAtBlockIDRequest::set_allocated_block_id(std::string* block_id) {
  if (block_id != nullptr) {
    
  } else {
    
  }
  block_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), block_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.execution.ExecuteScriptAtBlockIDRequest.block_id)
}

// bytes script = 2;
inline void ExecuteScriptAtBlockIDRequest::clear_script() {
  script_.ClearToEmpty();
}
inline const std::string& ExecuteScriptAtBlockIDRequest::script() const {
  // @@protoc_insertion_point(field_get:flow.execution.ExecuteScriptAtBlockIDRequest.script)
  return _internal_script();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteScriptAtBlockIDRequest::set_script(ArgT0&& arg0, ArgT... args) {
 
 script_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.execution.ExecuteScriptAtBlockIDRequest.script)
}
inline std::string* ExecuteScriptAtBlockIDRequest::mutable_script() {
  std::string* _s = _internal_mutable_script();
  // @@protoc_insertion_point(field_mutable:flow.execution.ExecuteScriptAtBlockIDRequest.script)
  return _s;
}
inline const std::string& ExecuteScriptAtBlockIDRequest::_internal_script() const {
  return script_.Get();
}
inline void ExecuteScriptAtBlockIDRequest::_internal_set_script(const std::string& value) {
  
  script_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtBlockIDRequest::_internal_mutable_script() {
  
  return script_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtBlockIDRequest::release_script() {
  // @@protoc_insertion_point(field_release:flow.execution.ExecuteScriptAtBlockIDRequest.script)
  return script_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecuteScriptAtBlockIDRequest::set_allocated_script(std::string* script) {
  if (script != nullptr) {
    
  } else {
    
  }
  script_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), script,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.execution.ExecuteScriptAtBlockIDRequest.script)
}

// repeated bytes arguments = 3;
inline int ExecuteScriptAtBlockIDRequest::_internal_arguments_size() const {
  return arguments_.size();
}
inline int ExecuteScriptAtBlockIDRequest::arguments_size() const {
  return _internal_arguments_size();
}
inline void ExecuteScriptAtBlockIDRequest::clear_arguments() {
  arguments_.Clear();
}
inline std::string* ExecuteScriptAtBlockIDRequest::add_arguments() {
  std::string* _s = _internal_add_arguments();
  // @@protoc_insertion_point(field_add_mutable:flow.execution.ExecuteScriptAtBlockIDRequest.arguments)
  return _s;
}
inline const std::string& ExecuteScriptAtBlockIDRequest::_internal_arguments(int index) const {
  return arguments_.Get(index);
}
inline const std::string& ExecuteScriptAtBlockIDRequest::arguments(int index) const {
  // @@protoc_insertion_point(field_get:flow.execution.ExecuteScriptAtBlockIDRequest.arguments)
  return _internal_arguments(index);
}
inline std::string* ExecuteScriptAtBlockIDRequest::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:flow.execution.ExecuteScriptAtBlockIDRequest.arguments)
  return arguments_.Mutable(index);
}
inline void ExecuteScriptAtBlockIDRequest::set_arguments(int index, const std::string& value) {
  arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:flow.execution.ExecuteScriptAtBlockIDRequest.arguments)
}
inline void ExecuteScriptAtBlockIDRequest::set_arguments(int index, std::string&& value) {
  arguments_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:flow.execution.ExecuteScriptAtBlockIDRequest.arguments)
}
inline void ExecuteScriptAtBlockIDRequest::set_arguments(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flow.execution.ExecuteScriptAtBlockIDRequest.arguments)
}
inline void ExecuteScriptAtBlockIDRequest::set_arguments(int index, const void* value, size_t size) {
  arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flow.execution.ExecuteScriptAtBlockIDRequest.arguments)
}
inline std::string* ExecuteScriptAtBlockIDRequest::_internal_add_arguments() {
  return arguments_.Add();
}
inline void ExecuteScriptAtBlockIDRequest::add_arguments(const std::string& value) {
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flow.execution.ExecuteScriptAtBlockIDRequest.arguments)
}
inline void ExecuteScriptAtBlockIDRequest::add_arguments(std::string&& value) {
  arguments_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flow.execution.ExecuteScriptAtBlockIDRequest.arguments)
}
inline void ExecuteScriptAtBlockIDRequest::add_arguments(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flow.execution.ExecuteScriptAtBlockIDRequest.arguments)
}
inline void ExecuteScriptAtBlockIDRequest::add_arguments(const void* value, size_t size) {
  arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flow.execution.ExecuteScriptAtBlockIDRequest.arguments)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ExecuteScriptAtBlockIDRequest::arguments() const {
  // @@protoc_insertion_point(field_list:flow.execution.ExecuteScriptAtBlockIDRequest.arguments)
  return arguments_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ExecuteScriptAtBlockIDRequest::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:flow.execution.ExecuteScriptAtBlockIDRequest.arguments)
  return &arguments_;
}

// -------------------------------------------------------------------

// ExecuteScriptAtBlockIDResponse

// bytes value = 1;
inline void ExecuteScriptAtBlockIDResponse::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& ExecuteScriptAtBlockIDResponse::value() const {
  // @@protoc_insertion_point(field_get:flow.execution.ExecuteScriptAtBlockIDResponse.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteScriptAtBlockIDResponse::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.execution.ExecuteScriptAtBlockIDResponse.value)
}
inline std::string* ExecuteScriptAtBlockIDResponse::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:flow.execution.ExecuteScriptAtBlockIDResponse.value)
  return _s;
}
inline const std::string& ExecuteScriptAtBlockIDResponse::_internal_value() const {
  return value_.Get();
}
inline void ExecuteScriptAtBlockIDResponse::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtBlockIDResponse::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtBlockIDResponse::release_value() {
  // @@protoc_insertion_point(field_release:flow.execution.ExecuteScriptAtBlockIDResponse.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecuteScriptAtBlockIDResponse::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.execution.ExecuteScriptAtBlockIDResponse.value)
}

// -------------------------------------------------------------------

// GetEventsForBlockIDsResponse_Result

// bytes block_id = 1;
inline void GetEventsForBlockIDsResponse_Result::clear_block_id() {
  block_id_.ClearToEmpty();
}
inline const std::string& GetEventsForBlockIDsResponse_Result::block_id() const {
  // @@protoc_insertion_point(field_get:flow.execution.GetEventsForBlockIDsResponse.Result.block_id)
  return _internal_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetEventsForBlockIDsResponse_Result::set_block_id(ArgT0&& arg0, ArgT... args) {
 
 block_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.execution.GetEventsForBlockIDsResponse.Result.block_id)
}
inline std::string* GetEventsForBlockIDsResponse_Result::mutable_block_id() {
  std::string* _s = _internal_mutable_block_id();
  // @@protoc_insertion_point(field_mutable:flow.execution.GetEventsForBlockIDsResponse.Result.block_id)
  return _s;
}
inline const std::string& GetEventsForBlockIDsResponse_Result::_internal_block_id() const {
  return block_id_.Get();
}
inline void GetEventsForBlockIDsResponse_Result::_internal_set_block_id(const std::string& value) {
  
  block_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetEventsForBlockIDsResponse_Result::_internal_mutable_block_id() {
  
  return block_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetEventsForBlockIDsResponse_Result::release_block_id() {
  // @@protoc_insertion_point(field_release:flow.execution.GetEventsForBlockIDsResponse.Result.block_id)
  return block_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetEventsForBlockIDsResponse_Result::set_allocated_block_id(std::string* block_id) {
  if (block_id != nullptr) {
    
  } else {
    
  }
  block_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), block_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.execution.GetEventsForBlockIDsResponse.Result.block_id)
}

// uint64 block_height = 2;
inline void GetEventsForBlockIDsResponse_Result::clear_block_height() {
  block_height_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetEventsForBlockIDsResponse_Result::_internal_block_height() const {
  return block_height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetEventsForBlockIDsResponse_Result::block_height() const {
  // @@protoc_insertion_point(field_get:flow.execution.GetEventsForBlockIDsResponse.Result.block_height)
  return _internal_block_height();
}
inline void GetEventsForBlockIDsResponse_Result::_internal_set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  block_height_ = value;
}
inline void GetEventsForBlockIDsResponse_Result::set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_block_height(value);
  // @@protoc_insertion_point(field_set:flow.execution.GetEventsForBlockIDsResponse.Result.block_height)
}

// repeated .flow.entities.Event events = 3;
inline int GetEventsForBlockIDsResponse_Result::_internal_events_size() const {
  return events_.size();
}
inline int GetEventsForBlockIDsResponse_Result::events_size() const {
  return _internal_events_size();
}
inline ::flow::entities::Event* GetEventsForBlockIDsResponse_Result::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:flow.execution.GetEventsForBlockIDsResponse.Result.events)
  return events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::entities::Event >*
GetEventsForBlockIDsResponse_Result::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:flow.execution.GetEventsForBlockIDsResponse.Result.events)
  return &events_;
}
inline const ::flow::entities::Event& GetEventsForBlockIDsResponse_Result::_internal_events(int index) const {
  return events_.Get(index);
}
inline const ::flow::entities::Event& GetEventsForBlockIDsResponse_Result::events(int index) const {
  // @@protoc_insertion_point(field_get:flow.execution.GetEventsForBlockIDsResponse.Result.events)
  return _internal_events(index);
}
inline ::flow::entities::Event* GetEventsForBlockIDsResponse_Result::_internal_add_events() {
  return events_.Add();
}
inline ::flow::entities::Event* GetEventsForBlockIDsResponse_Result::add_events() {
  ::flow::entities::Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:flow.execution.GetEventsForBlockIDsResponse.Result.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::entities::Event >&
GetEventsForBlockIDsResponse_Result::events() const {
  // @@protoc_insertion_point(field_list:flow.execution.GetEventsForBlockIDsResponse.Result.events)
  return events_;
}

// -------------------------------------------------------------------

// GetEventsForBlockIDsResponse

// repeated .flow.execution.GetEventsForBlockIDsResponse.Result results = 1;
inline int GetEventsForBlockIDsResponse::_internal_results_size() const {
  return results_.size();
}
inline int GetEventsForBlockIDsResponse::results_size() const {
  return _internal_results_size();
}
inline void GetEventsForBlockIDsResponse::clear_results() {
  results_.Clear();
}
inline ::flow::execution::GetEventsForBlockIDsResponse_Result* GetEventsForBlockIDsResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:flow.execution.GetEventsForBlockIDsResponse.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::execution::GetEventsForBlockIDsResponse_Result >*
GetEventsForBlockIDsResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:flow.execution.GetEventsForBlockIDsResponse.results)
  return &results_;
}
inline const ::flow::execution::GetEventsForBlockIDsResponse_Result& GetEventsForBlockIDsResponse::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::flow::execution::GetEventsForBlockIDsResponse_Result& GetEventsForBlockIDsResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:flow.execution.GetEventsForBlockIDsResponse.results)
  return _internal_results(index);
}
inline ::flow::execution::GetEventsForBlockIDsResponse_Result* GetEventsForBlockIDsResponse::_internal_add_results() {
  return results_.Add();
}
inline ::flow::execution::GetEventsForBlockIDsResponse_Result* GetEventsForBlockIDsResponse::add_results() {
  ::flow::execution::GetEventsForBlockIDsResponse_Result* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:flow.execution.GetEventsForBlockIDsResponse.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::execution::GetEventsForBlockIDsResponse_Result >&
GetEventsForBlockIDsResponse::results() const {
  // @@protoc_insertion_point(field_list:flow.execution.GetEventsForBlockIDsResponse.results)
  return results_;
}

// -------------------------------------------------------------------

// GetEventsForBlockIDsRequest

// string type = 1;
inline void GetEventsForBlockIDsRequest::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& GetEventsForBlockIDsRequest::type() const {
  // @@protoc_insertion_point(field_get:flow.execution.GetEventsForBlockIDsRequest.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetEventsForBlockIDsRequest::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.execution.GetEventsForBlockIDsRequest.type)
}
inline std::string* GetEventsForBlockIDsRequest::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:flow.execution.GetEventsForBlockIDsRequest.type)
  return _s;
}
inline const std::string& GetEventsForBlockIDsRequest::_internal_type() const {
  return type_.Get();
}
inline void GetEventsForBlockIDsRequest::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetEventsForBlockIDsRequest::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetEventsForBlockIDsRequest::release_type() {
  // @@protoc_insertion_point(field_release:flow.execution.GetEventsForBlockIDsRequest.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetEventsForBlockIDsRequest::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.execution.GetEventsForBlockIDsRequest.type)
}

// repeated bytes block_ids = 2;
inline int GetEventsForBlockIDsRequest::_internal_block_ids_size() const {
  return block_ids_.size();
}
inline int GetEventsForBlockIDsRequest::block_ids_size() const {
  return _internal_block_ids_size();
}
inline void GetEventsForBlockIDsRequest::clear_block_ids() {
  block_ids_.Clear();
}
inline std::string* GetEventsForBlockIDsRequest::add_block_ids() {
  std::string* _s = _internal_add_block_ids();
  // @@protoc_insertion_point(field_add_mutable:flow.execution.GetEventsForBlockIDsRequest.block_ids)
  return _s;
}
inline const std::string& GetEventsForBlockIDsRequest::_internal_block_ids(int index) const {
  return block_ids_.Get(index);
}
inline const std::string& GetEventsForBlockIDsRequest::block_ids(int index) const {
  // @@protoc_insertion_point(field_get:flow.execution.GetEventsForBlockIDsRequest.block_ids)
  return _internal_block_ids(index);
}
inline std::string* GetEventsForBlockIDsRequest::mutable_block_ids(int index) {
  // @@protoc_insertion_point(field_mutable:flow.execution.GetEventsForBlockIDsRequest.block_ids)
  return block_ids_.Mutable(index);
}
inline void GetEventsForBlockIDsRequest::set_block_ids(int index, const std::string& value) {
  block_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:flow.execution.GetEventsForBlockIDsRequest.block_ids)
}
inline void GetEventsForBlockIDsRequest::set_block_ids(int index, std::string&& value) {
  block_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:flow.execution.GetEventsForBlockIDsRequest.block_ids)
}
inline void GetEventsForBlockIDsRequest::set_block_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  block_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flow.execution.GetEventsForBlockIDsRequest.block_ids)
}
inline void GetEventsForBlockIDsRequest::set_block_ids(int index, const void* value, size_t size) {
  block_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flow.execution.GetEventsForBlockIDsRequest.block_ids)
}
inline std::string* GetEventsForBlockIDsRequest::_internal_add_block_ids() {
  return block_ids_.Add();
}
inline void GetEventsForBlockIDsRequest::add_block_ids(const std::string& value) {
  block_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flow.execution.GetEventsForBlockIDsRequest.block_ids)
}
inline void GetEventsForBlockIDsRequest::add_block_ids(std::string&& value) {
  block_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flow.execution.GetEventsForBlockIDsRequest.block_ids)
}
inline void GetEventsForBlockIDsRequest::add_block_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  block_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flow.execution.GetEventsForBlockIDsRequest.block_ids)
}
inline void GetEventsForBlockIDsRequest::add_block_ids(const void* value, size_t size) {
  block_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flow.execution.GetEventsForBlockIDsRequest.block_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetEventsForBlockIDsRequest::block_ids() const {
  // @@protoc_insertion_point(field_list:flow.execution.GetEventsForBlockIDsRequest.block_ids)
  return block_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetEventsForBlockIDsRequest::mutable_block_ids() {
  // @@protoc_insertion_point(field_mutable_list:flow.execution.GetEventsForBlockIDsRequest.block_ids)
  return &block_ids_;
}

// -------------------------------------------------------------------

// GetTransactionResultRequest

// bytes block_id = 1;
inline void GetTransactionResultRequest::clear_block_id() {
  block_id_.ClearToEmpty();
}
inline const std::string& GetTransactionResultRequest::block_id() const {
  // @@protoc_insertion_point(field_get:flow.execution.GetTransactionResultRequest.block_id)
  return _internal_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTransactionResultRequest::set_block_id(ArgT0&& arg0, ArgT... args) {
 
 block_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.execution.GetTransactionResultRequest.block_id)
}
inline std::string* GetTransactionResultRequest::mutable_block_id() {
  std::string* _s = _internal_mutable_block_id();
  // @@protoc_insertion_point(field_mutable:flow.execution.GetTransactionResultRequest.block_id)
  return _s;
}
inline const std::string& GetTransactionResultRequest::_internal_block_id() const {
  return block_id_.Get();
}
inline void GetTransactionResultRequest::_internal_set_block_id(const std::string& value) {
  
  block_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetTransactionResultRequest::_internal_mutable_block_id() {
  
  return block_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetTransactionResultRequest::release_block_id() {
  // @@protoc_insertion_point(field_release:flow.execution.GetTransactionResultRequest.block_id)
  return block_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetTransactionResultRequest::set_allocated_block_id(std::string* block_id) {
  if (block_id != nullptr) {
    
  } else {
    
  }
  block_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), block_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.execution.GetTransactionResultRequest.block_id)
}

// bytes transaction_id = 2;
inline void GetTransactionResultRequest::clear_transaction_id() {
  transaction_id_.ClearToEmpty();
}
inline const std::string& GetTransactionResultRequest::transaction_id() const {
  // @@protoc_insertion_point(field_get:flow.execution.GetTransactionResultRequest.transaction_id)
  return _internal_transaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTransactionResultRequest::set_transaction_id(ArgT0&& arg0, ArgT... args) {
 
 transaction_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.execution.GetTransactionResultRequest.transaction_id)
}
inline std::string* GetTransactionResultRequest::mutable_transaction_id() {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:flow.execution.GetTransactionResultRequest.transaction_id)
  return _s;
}
inline const std::string& GetTransactionResultRequest::_internal_transaction_id() const {
  return transaction_id_.Get();
}
inline void GetTransactionResultRequest::_internal_set_transaction_id(const std::string& value) {
  
  transaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetTransactionResultRequest::_internal_mutable_transaction_id() {
  
  return transaction_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetTransactionResultRequest::release_transaction_id() {
  // @@protoc_insertion_point(field_release:flow.execution.GetTransactionResultRequest.transaction_id)
  return transaction_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetTransactionResultRequest::set_allocated_transaction_id(std::string* transaction_id) {
  if (transaction_id != nullptr) {
    
  } else {
    
  }
  transaction_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transaction_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.execution.GetTransactionResultRequest.transaction_id)
}

// -------------------------------------------------------------------

// GetTransactionResultResponse

// uint32 status_code = 1;
inline void GetTransactionResultResponse::clear_status_code() {
  status_code_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetTransactionResultResponse::_internal_status_code() const {
  return status_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetTransactionResultResponse::status_code() const {
  // @@protoc_insertion_point(field_get:flow.execution.GetTransactionResultResponse.status_code)
  return _internal_status_code();
}
inline void GetTransactionResultResponse::_internal_set_status_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  status_code_ = value;
}
inline void GetTransactionResultResponse::set_status_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_status_code(value);
  // @@protoc_insertion_point(field_set:flow.execution.GetTransactionResultResponse.status_code)
}

// string error_message = 2;
inline void GetTransactionResultResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& GetTransactionResultResponse::error_message() const {
  // @@protoc_insertion_point(field_get:flow.execution.GetTransactionResultResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTransactionResultResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.execution.GetTransactionResultResponse.error_message)
}
inline std::string* GetTransactionResultResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:flow.execution.GetTransactionResultResponse.error_message)
  return _s;
}
inline const std::string& GetTransactionResultResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void GetTransactionResultResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetTransactionResultResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetTransactionResultResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:flow.execution.GetTransactionResultResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetTransactionResultResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.execution.GetTransactionResultResponse.error_message)
}

// repeated .flow.entities.Event events = 3;
inline int GetTransactionResultResponse::_internal_events_size() const {
  return events_.size();
}
inline int GetTransactionResultResponse::events_size() const {
  return _internal_events_size();
}
inline ::flow::entities::Event* GetTransactionResultResponse::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:flow.execution.GetTransactionResultResponse.events)
  return events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::entities::Event >*
GetTransactionResultResponse::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:flow.execution.GetTransactionResultResponse.events)
  return &events_;
}
inline const ::flow::entities::Event& GetTransactionResultResponse::_internal_events(int index) const {
  return events_.Get(index);
}
inline const ::flow::entities::Event& GetTransactionResultResponse::events(int index) const {
  // @@protoc_insertion_point(field_get:flow.execution.GetTransactionResultResponse.events)
  return _internal_events(index);
}
inline ::flow::entities::Event* GetTransactionResultResponse::_internal_add_events() {
  return events_.Add();
}
inline ::flow::entities::Event* GetTransactionResultResponse::add_events() {
  ::flow::entities::Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:flow.execution.GetTransactionResultResponse.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::entities::Event >&
GetTransactionResultResponse::events() const {
  // @@protoc_insertion_point(field_list:flow.execution.GetTransactionResultResponse.events)
  return events_;
}

// -------------------------------------------------------------------

// GetRegisterAtBlockIDRequest

// bytes block_id = 1;
inline void GetRegisterAtBlockIDRequest::clear_block_id() {
  block_id_.ClearToEmpty();
}
inline const std::string& GetRegisterAtBlockIDRequest::block_id() const {
  // @@protoc_insertion_point(field_get:flow.execution.GetRegisterAtBlockIDRequest.block_id)
  return _internal_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRegisterAtBlockIDRequest::set_block_id(ArgT0&& arg0, ArgT... args) {
 
 block_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.execution.GetRegisterAtBlockIDRequest.block_id)
}
inline std::string* GetRegisterAtBlockIDRequest::mutable_block_id() {
  std::string* _s = _internal_mutable_block_id();
  // @@protoc_insertion_point(field_mutable:flow.execution.GetRegisterAtBlockIDRequest.block_id)
  return _s;
}
inline const std::string& GetRegisterAtBlockIDRequest::_internal_block_id() const {
  return block_id_.Get();
}
inline void GetRegisterAtBlockIDRequest::_internal_set_block_id(const std::string& value) {
  
  block_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetRegisterAtBlockIDRequest::_internal_mutable_block_id() {
  
  return block_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetRegisterAtBlockIDRequest::release_block_id() {
  // @@protoc_insertion_point(field_release:flow.execution.GetRegisterAtBlockIDRequest.block_id)
  return block_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetRegisterAtBlockIDRequest::set_allocated_block_id(std::string* block_id) {
  if (block_id != nullptr) {
    
  } else {
    
  }
  block_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), block_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.execution.GetRegisterAtBlockIDRequest.block_id)
}

// bytes register_owner = 2;
inline void GetRegisterAtBlockIDRequest::clear_register_owner() {
  register_owner_.ClearToEmpty();
}
inline const std::string& GetRegisterAtBlockIDRequest::register_owner() const {
  // @@protoc_insertion_point(field_get:flow.execution.GetRegisterAtBlockIDRequest.register_owner)
  return _internal_register_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRegisterAtBlockIDRequest::set_register_owner(ArgT0&& arg0, ArgT... args) {
 
 register_owner_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.execution.GetRegisterAtBlockIDRequest.register_owner)
}
inline std::string* GetRegisterAtBlockIDRequest::mutable_register_owner() {
  std::string* _s = _internal_mutable_register_owner();
  // @@protoc_insertion_point(field_mutable:flow.execution.GetRegisterAtBlockIDRequest.register_owner)
  return _s;
}
inline const std::string& GetRegisterAtBlockIDRequest::_internal_register_owner() const {
  return register_owner_.Get();
}
inline void GetRegisterAtBlockIDRequest::_internal_set_register_owner(const std::string& value) {
  
  register_owner_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetRegisterAtBlockIDRequest::_internal_mutable_register_owner() {
  
  return register_owner_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetRegisterAtBlockIDRequest::release_register_owner() {
  // @@protoc_insertion_point(field_release:flow.execution.GetRegisterAtBlockIDRequest.register_owner)
  return register_owner_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetRegisterAtBlockIDRequest::set_allocated_register_owner(std::string* register_owner) {
  if (register_owner != nullptr) {
    
  } else {
    
  }
  register_owner_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), register_owner,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.execution.GetRegisterAtBlockIDRequest.register_owner)
}

// bytes register_controller = 3;
inline void GetRegisterAtBlockIDRequest::clear_register_controller() {
  register_controller_.ClearToEmpty();
}
inline const std::string& GetRegisterAtBlockIDRequest::register_controller() const {
  // @@protoc_insertion_point(field_get:flow.execution.GetRegisterAtBlockIDRequest.register_controller)
  return _internal_register_controller();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRegisterAtBlockIDRequest::set_register_controller(ArgT0&& arg0, ArgT... args) {
 
 register_controller_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.execution.GetRegisterAtBlockIDRequest.register_controller)
}
inline std::string* GetRegisterAtBlockIDRequest::mutable_register_controller() {
  std::string* _s = _internal_mutable_register_controller();
  // @@protoc_insertion_point(field_mutable:flow.execution.GetRegisterAtBlockIDRequest.register_controller)
  return _s;
}
inline const std::string& GetRegisterAtBlockIDRequest::_internal_register_controller() const {
  return register_controller_.Get();
}
inline void GetRegisterAtBlockIDRequest::_internal_set_register_controller(const std::string& value) {
  
  register_controller_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetRegisterAtBlockIDRequest::_internal_mutable_register_controller() {
  
  return register_controller_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetRegisterAtBlockIDRequest::release_register_controller() {
  // @@protoc_insertion_point(field_release:flow.execution.GetRegisterAtBlockIDRequest.register_controller)
  return register_controller_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetRegisterAtBlockIDRequest::set_allocated_register_controller(std::string* register_controller) {
  if (register_controller != nullptr) {
    
  } else {
    
  }
  register_controller_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), register_controller,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.execution.GetRegisterAtBlockIDRequest.register_controller)
}

// bytes register_key = 4;
inline void GetRegisterAtBlockIDRequest::clear_register_key() {
  register_key_.ClearToEmpty();
}
inline const std::string& GetRegisterAtBlockIDRequest::register_key() const {
  // @@protoc_insertion_point(field_get:flow.execution.GetRegisterAtBlockIDRequest.register_key)
  return _internal_register_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRegisterAtBlockIDRequest::set_register_key(ArgT0&& arg0, ArgT... args) {
 
 register_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.execution.GetRegisterAtBlockIDRequest.register_key)
}
inline std::string* GetRegisterAtBlockIDRequest::mutable_register_key() {
  std::string* _s = _internal_mutable_register_key();
  // @@protoc_insertion_point(field_mutable:flow.execution.GetRegisterAtBlockIDRequest.register_key)
  return _s;
}
inline const std::string& GetRegisterAtBlockIDRequest::_internal_register_key() const {
  return register_key_.Get();
}
inline void GetRegisterAtBlockIDRequest::_internal_set_register_key(const std::string& value) {
  
  register_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetRegisterAtBlockIDRequest::_internal_mutable_register_key() {
  
  return register_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetRegisterAtBlockIDRequest::release_register_key() {
  // @@protoc_insertion_point(field_release:flow.execution.GetRegisterAtBlockIDRequest.register_key)
  return register_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetRegisterAtBlockIDRequest::set_allocated_register_key(std::string* register_key) {
  if (register_key != nullptr) {
    
  } else {
    
  }
  register_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), register_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.execution.GetRegisterAtBlockIDRequest.register_key)
}

// -------------------------------------------------------------------

// GetRegisterAtBlockIDResponse

// bytes value = 1;
inline void GetRegisterAtBlockIDResponse::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& GetRegisterAtBlockIDResponse::value() const {
  // @@protoc_insertion_point(field_get:flow.execution.GetRegisterAtBlockIDResponse.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRegisterAtBlockIDResponse::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.execution.GetRegisterAtBlockIDResponse.value)
}
inline std::string* GetRegisterAtBlockIDResponse::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:flow.execution.GetRegisterAtBlockIDResponse.value)
  return _s;
}
inline const std::string& GetRegisterAtBlockIDResponse::_internal_value() const {
  return value_.Get();
}
inline void GetRegisterAtBlockIDResponse::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetRegisterAtBlockIDResponse::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetRegisterAtBlockIDResponse::release_value() {
  // @@protoc_insertion_point(field_release:flow.execution.GetRegisterAtBlockIDResponse.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetRegisterAtBlockIDResponse::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.execution.GetRegisterAtBlockIDResponse.value)
}

// -------------------------------------------------------------------

// GetLatestBlockHeaderRequest

// bool is_sealed = 1;
inline void GetLatestBlockHeaderRequest::clear_is_sealed() {
  is_sealed_ = false;
}
inline bool GetLatestBlockHeaderRequest::_internal_is_sealed() const {
  return is_sealed_;
}
inline bool GetLatestBlockHeaderRequest::is_sealed() const {
  // @@protoc_insertion_point(field_get:flow.execution.GetLatestBlockHeaderRequest.is_sealed)
  return _internal_is_sealed();
}
inline void GetLatestBlockHeaderRequest::_internal_set_is_sealed(bool value) {
  
  is_sealed_ = value;
}
inline void GetLatestBlockHeaderRequest::set_is_sealed(bool value) {
  _internal_set_is_sealed(value);
  // @@protoc_insertion_point(field_set:flow.execution.GetLatestBlockHeaderRequest.is_sealed)
}

// -------------------------------------------------------------------

// GetBlockHeaderByIDRequest

// bytes id = 1;
inline void GetBlockHeaderByIDRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetBlockHeaderByIDRequest::id() const {
  // @@protoc_insertion_point(field_get:flow.execution.GetBlockHeaderByIDRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBlockHeaderByIDRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.execution.GetBlockHeaderByIDRequest.id)
}
inline std::string* GetBlockHeaderByIDRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flow.execution.GetBlockHeaderByIDRequest.id)
  return _s;
}
inline const std::string& GetBlockHeaderByIDRequest::_internal_id() const {
  return id_.Get();
}
inline void GetBlockHeaderByIDRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetBlockHeaderByIDRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetBlockHeaderByIDRequest::release_id() {
  // @@protoc_insertion_point(field_release:flow.execution.GetBlockHeaderByIDRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetBlockHeaderByIDRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.execution.GetBlockHeaderByIDRequest.id)
}

// -------------------------------------------------------------------

// BlockHeaderResponse

// .flow.entities.BlockHeader block = 1;
inline bool BlockHeaderResponse::_internal_has_block() const {
  return this != internal_default_instance() && block_ != nullptr;
}
inline bool BlockHeaderResponse::has_block() const {
  return _internal_has_block();
}
inline const ::flow::entities::BlockHeader& BlockHeaderResponse::_internal_block() const {
  const ::flow::entities::BlockHeader* p = block_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow::entities::BlockHeader&>(
      ::flow::entities::_BlockHeader_default_instance_);
}
inline const ::flow::entities::BlockHeader& BlockHeaderResponse::block() const {
  // @@protoc_insertion_point(field_get:flow.execution.BlockHeaderResponse.block)
  return _internal_block();
}
inline void BlockHeaderResponse::unsafe_arena_set_allocated_block(
    ::flow::entities::BlockHeader* block) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_);
  }
  block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow.execution.BlockHeaderResponse.block)
}
inline ::flow::entities::BlockHeader* BlockHeaderResponse::release_block() {
  
  ::flow::entities::BlockHeader* temp = block_;
  block_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow::entities::BlockHeader* BlockHeaderResponse::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:flow.execution.BlockHeaderResponse.block)
  
  ::flow::entities::BlockHeader* temp = block_;
  block_ = nullptr;
  return temp;
}
inline ::flow::entities::BlockHeader* BlockHeaderResponse::_internal_mutable_block() {
  
  if (block_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow::entities::BlockHeader>(GetArenaForAllocation());
    block_ = p;
  }
  return block_;
}
inline ::flow::entities::BlockHeader* BlockHeaderResponse::mutable_block() {
  ::flow::entities::BlockHeader* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:flow.execution.BlockHeaderResponse.block)
  return _msg;
}
inline void BlockHeaderResponse::set_allocated_block(::flow::entities::BlockHeader* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_);
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block));
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:flow.execution.BlockHeaderResponse.block)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace execution
}  // namespace flow

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_flow_2fexecution_2fexecution_2eproto
