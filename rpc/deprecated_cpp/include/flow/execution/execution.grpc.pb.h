// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: flow/execution/execution.proto
#ifndef GRPC_flow_2fexecution_2fexecution_2eproto__INCLUDED
#define GRPC_flow_2fexecution_2fexecution_2eproto__INCLUDED

#include "flow/execution/execution.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace flow {
namespace execution {

// ExecutionAPI is the API provided by the execution nodes.
class ExecutionAPI final {
 public:
  static constexpr char const* service_full_name() {
    return "flow.execution.ExecutionAPI";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Ping is used to check if the access node is alive and healthy.
    virtual ::grpc::Status Ping(::grpc::ClientContext* context, const ::flow::execution::PingRequest& request, ::flow::execution::PingResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::PingResponse>> AsyncPing(::grpc::ClientContext* context, const ::flow::execution::PingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::PingResponse>>(AsyncPingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::PingResponse>> PrepareAsyncPing(::grpc::ClientContext* context, const ::flow::execution::PingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::PingResponse>>(PrepareAsyncPingRaw(context, request, cq));
    }
    // Accounts
    //
    // GetAccountAtBlockID gets an account by address at the given block ID
    virtual ::grpc::Status GetAccountAtBlockID(::grpc::ClientContext* context, const ::flow::execution::GetAccountAtBlockIDRequest& request, ::flow::execution::GetAccountAtBlockIDResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetAccountAtBlockIDResponse>> AsyncGetAccountAtBlockID(::grpc::ClientContext* context, const ::flow::execution::GetAccountAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetAccountAtBlockIDResponse>>(AsyncGetAccountAtBlockIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetAccountAtBlockIDResponse>> PrepareAsyncGetAccountAtBlockID(::grpc::ClientContext* context, const ::flow::execution::GetAccountAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetAccountAtBlockIDResponse>>(PrepareAsyncGetAccountAtBlockIDRaw(context, request, cq));
    }
    // Scripts
    //
    // ExecuteScriptAtBlockID executes a ready-only Cadence script against the
    // execution state at the block with the given ID.
    virtual ::grpc::Status ExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::execution::ExecuteScriptAtBlockIDRequest& request, ::flow::execution::ExecuteScriptAtBlockIDResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::ExecuteScriptAtBlockIDResponse>> AsyncExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::execution::ExecuteScriptAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::ExecuteScriptAtBlockIDResponse>>(AsyncExecuteScriptAtBlockIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::ExecuteScriptAtBlockIDResponse>> PrepareAsyncExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::execution::ExecuteScriptAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::ExecuteScriptAtBlockIDResponse>>(PrepareAsyncExecuteScriptAtBlockIDRaw(context, request, cq));
    }
    // Events
    //
    // GetEventsForBlockIDs retrieves events for all the specified block IDs that
    // have the given type
    virtual ::grpc::Status GetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::execution::GetEventsForBlockIDsRequest& request, ::flow::execution::GetEventsForBlockIDsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetEventsForBlockIDsResponse>> AsyncGetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::execution::GetEventsForBlockIDsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetEventsForBlockIDsResponse>>(AsyncGetEventsForBlockIDsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetEventsForBlockIDsResponse>> PrepareAsyncGetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::execution::GetEventsForBlockIDsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetEventsForBlockIDsResponse>>(PrepareAsyncGetEventsForBlockIDsRaw(context, request, cq));
    }
    // Transaction
    //
    // GetTransactionResult gets the result of a transaction.
    virtual ::grpc::Status GetTransactionResult(::grpc::ClientContext* context, const ::flow::execution::GetTransactionResultRequest& request, ::flow::execution::GetTransactionResultResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetTransactionResultResponse>> AsyncGetTransactionResult(::grpc::ClientContext* context, const ::flow::execution::GetTransactionResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetTransactionResultResponse>>(AsyncGetTransactionResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetTransactionResultResponse>> PrepareAsyncGetTransactionResult(::grpc::ClientContext* context, const ::flow::execution::GetTransactionResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetTransactionResultResponse>>(PrepareAsyncGetTransactionResultRaw(context, request, cq));
    }
    // Registers
    //
    // GetRegisterAtBlockID collects a register at the block with the given ID (if available).
    virtual ::grpc::Status GetRegisterAtBlockID(::grpc::ClientContext* context, const ::flow::execution::GetRegisterAtBlockIDRequest& request, ::flow::execution::GetRegisterAtBlockIDResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetRegisterAtBlockIDResponse>> AsyncGetRegisterAtBlockID(::grpc::ClientContext* context, const ::flow::execution::GetRegisterAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetRegisterAtBlockIDResponse>>(AsyncGetRegisterAtBlockIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetRegisterAtBlockIDResponse>> PrepareAsyncGetRegisterAtBlockID(::grpc::ClientContext* context, const ::flow::execution::GetRegisterAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetRegisterAtBlockIDResponse>>(PrepareAsyncGetRegisterAtBlockIDRaw(context, request, cq));
    }
    // Block headers
    //
    // GetLatestBlockHeader gets the latest sealed or unsealed block header.
    virtual ::grpc::Status GetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::execution::GetLatestBlockHeaderRequest& request, ::flow::execution::BlockHeaderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::BlockHeaderResponse>> AsyncGetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::execution::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::BlockHeaderResponse>>(AsyncGetLatestBlockHeaderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::BlockHeaderResponse>> PrepareAsyncGetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::execution::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::BlockHeaderResponse>>(PrepareAsyncGetLatestBlockHeaderRaw(context, request, cq));
    }
    // GetBlockHeaderByID gets a block header by ID.
    virtual ::grpc::Status GetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::execution::GetBlockHeaderByIDRequest& request, ::flow::execution::BlockHeaderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::BlockHeaderResponse>> AsyncGetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::execution::GetBlockHeaderByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::BlockHeaderResponse>>(AsyncGetBlockHeaderByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::BlockHeaderResponse>> PrepareAsyncGetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::execution::GetBlockHeaderByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::BlockHeaderResponse>>(PrepareAsyncGetBlockHeaderByIDRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Ping is used to check if the access node is alive and healthy.
      virtual void Ping(::grpc::ClientContext* context, const ::flow::execution::PingRequest* request, ::flow::execution::PingResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Ping(::grpc::ClientContext* context, const ::flow::execution::PingRequest* request, ::flow::execution::PingResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Accounts
      //
      // GetAccountAtBlockID gets an account by address at the given block ID
      virtual void GetAccountAtBlockID(::grpc::ClientContext* context, const ::flow::execution::GetAccountAtBlockIDRequest* request, ::flow::execution::GetAccountAtBlockIDResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAccountAtBlockID(::grpc::ClientContext* context, const ::flow::execution::GetAccountAtBlockIDRequest* request, ::flow::execution::GetAccountAtBlockIDResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Scripts
      //
      // ExecuteScriptAtBlockID executes a ready-only Cadence script against the
      // execution state at the block with the given ID.
      virtual void ExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::execution::ExecuteScriptAtBlockIDRequest* request, ::flow::execution::ExecuteScriptAtBlockIDResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::execution::ExecuteScriptAtBlockIDRequest* request, ::flow::execution::ExecuteScriptAtBlockIDResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Events
      //
      // GetEventsForBlockIDs retrieves events for all the specified block IDs that
      // have the given type
      virtual void GetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::execution::GetEventsForBlockIDsRequest* request, ::flow::execution::GetEventsForBlockIDsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::execution::GetEventsForBlockIDsRequest* request, ::flow::execution::GetEventsForBlockIDsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Transaction
      //
      // GetTransactionResult gets the result of a transaction.
      virtual void GetTransactionResult(::grpc::ClientContext* context, const ::flow::execution::GetTransactionResultRequest* request, ::flow::execution::GetTransactionResultResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTransactionResult(::grpc::ClientContext* context, const ::flow::execution::GetTransactionResultRequest* request, ::flow::execution::GetTransactionResultResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Registers
      //
      // GetRegisterAtBlockID collects a register at the block with the given ID (if available).
      virtual void GetRegisterAtBlockID(::grpc::ClientContext* context, const ::flow::execution::GetRegisterAtBlockIDRequest* request, ::flow::execution::GetRegisterAtBlockIDResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRegisterAtBlockID(::grpc::ClientContext* context, const ::flow::execution::GetRegisterAtBlockIDRequest* request, ::flow::execution::GetRegisterAtBlockIDResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Block headers
      //
      // GetLatestBlockHeader gets the latest sealed or unsealed block header.
      virtual void GetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::execution::GetLatestBlockHeaderRequest* request, ::flow::execution::BlockHeaderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::execution::GetLatestBlockHeaderRequest* request, ::flow::execution::BlockHeaderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // GetBlockHeaderByID gets a block header by ID.
      virtual void GetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::execution::GetBlockHeaderByIDRequest* request, ::flow::execution::BlockHeaderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::execution::GetBlockHeaderByIDRequest* request, ::flow::execution::BlockHeaderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::PingResponse>* AsyncPingRaw(::grpc::ClientContext* context, const ::flow::execution::PingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::PingResponse>* PrepareAsyncPingRaw(::grpc::ClientContext* context, const ::flow::execution::PingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetAccountAtBlockIDResponse>* AsyncGetAccountAtBlockIDRaw(::grpc::ClientContext* context, const ::flow::execution::GetAccountAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetAccountAtBlockIDResponse>* PrepareAsyncGetAccountAtBlockIDRaw(::grpc::ClientContext* context, const ::flow::execution::GetAccountAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::ExecuteScriptAtBlockIDResponse>* AsyncExecuteScriptAtBlockIDRaw(::grpc::ClientContext* context, const ::flow::execution::ExecuteScriptAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::ExecuteScriptAtBlockIDResponse>* PrepareAsyncExecuteScriptAtBlockIDRaw(::grpc::ClientContext* context, const ::flow::execution::ExecuteScriptAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetEventsForBlockIDsResponse>* AsyncGetEventsForBlockIDsRaw(::grpc::ClientContext* context, const ::flow::execution::GetEventsForBlockIDsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetEventsForBlockIDsResponse>* PrepareAsyncGetEventsForBlockIDsRaw(::grpc::ClientContext* context, const ::flow::execution::GetEventsForBlockIDsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetTransactionResultResponse>* AsyncGetTransactionResultRaw(::grpc::ClientContext* context, const ::flow::execution::GetTransactionResultRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetTransactionResultResponse>* PrepareAsyncGetTransactionResultRaw(::grpc::ClientContext* context, const ::flow::execution::GetTransactionResultRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetRegisterAtBlockIDResponse>* AsyncGetRegisterAtBlockIDRaw(::grpc::ClientContext* context, const ::flow::execution::GetRegisterAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::GetRegisterAtBlockIDResponse>* PrepareAsyncGetRegisterAtBlockIDRaw(::grpc::ClientContext* context, const ::flow::execution::GetRegisterAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::BlockHeaderResponse>* AsyncGetLatestBlockHeaderRaw(::grpc::ClientContext* context, const ::flow::execution::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::BlockHeaderResponse>* PrepareAsyncGetLatestBlockHeaderRaw(::grpc::ClientContext* context, const ::flow::execution::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::BlockHeaderResponse>* AsyncGetBlockHeaderByIDRaw(::grpc::ClientContext* context, const ::flow::execution::GetBlockHeaderByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::execution::BlockHeaderResponse>* PrepareAsyncGetBlockHeaderByIDRaw(::grpc::ClientContext* context, const ::flow::execution::GetBlockHeaderByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Ping(::grpc::ClientContext* context, const ::flow::execution::PingRequest& request, ::flow::execution::PingResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::PingResponse>> AsyncPing(::grpc::ClientContext* context, const ::flow::execution::PingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::PingResponse>>(AsyncPingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::PingResponse>> PrepareAsyncPing(::grpc::ClientContext* context, const ::flow::execution::PingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::PingResponse>>(PrepareAsyncPingRaw(context, request, cq));
    }
    ::grpc::Status GetAccountAtBlockID(::grpc::ClientContext* context, const ::flow::execution::GetAccountAtBlockIDRequest& request, ::flow::execution::GetAccountAtBlockIDResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::GetAccountAtBlockIDResponse>> AsyncGetAccountAtBlockID(::grpc::ClientContext* context, const ::flow::execution::GetAccountAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::GetAccountAtBlockIDResponse>>(AsyncGetAccountAtBlockIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::GetAccountAtBlockIDResponse>> PrepareAsyncGetAccountAtBlockID(::grpc::ClientContext* context, const ::flow::execution::GetAccountAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::GetAccountAtBlockIDResponse>>(PrepareAsyncGetAccountAtBlockIDRaw(context, request, cq));
    }
    ::grpc::Status ExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::execution::ExecuteScriptAtBlockIDRequest& request, ::flow::execution::ExecuteScriptAtBlockIDResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::ExecuteScriptAtBlockIDResponse>> AsyncExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::execution::ExecuteScriptAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::ExecuteScriptAtBlockIDResponse>>(AsyncExecuteScriptAtBlockIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::ExecuteScriptAtBlockIDResponse>> PrepareAsyncExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::execution::ExecuteScriptAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::ExecuteScriptAtBlockIDResponse>>(PrepareAsyncExecuteScriptAtBlockIDRaw(context, request, cq));
    }
    ::grpc::Status GetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::execution::GetEventsForBlockIDsRequest& request, ::flow::execution::GetEventsForBlockIDsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::GetEventsForBlockIDsResponse>> AsyncGetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::execution::GetEventsForBlockIDsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::GetEventsForBlockIDsResponse>>(AsyncGetEventsForBlockIDsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::GetEventsForBlockIDsResponse>> PrepareAsyncGetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::execution::GetEventsForBlockIDsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::GetEventsForBlockIDsResponse>>(PrepareAsyncGetEventsForBlockIDsRaw(context, request, cq));
    }
    ::grpc::Status GetTransactionResult(::grpc::ClientContext* context, const ::flow::execution::GetTransactionResultRequest& request, ::flow::execution::GetTransactionResultResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::GetTransactionResultResponse>> AsyncGetTransactionResult(::grpc::ClientContext* context, const ::flow::execution::GetTransactionResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::GetTransactionResultResponse>>(AsyncGetTransactionResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::GetTransactionResultResponse>> PrepareAsyncGetTransactionResult(::grpc::ClientContext* context, const ::flow::execution::GetTransactionResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::GetTransactionResultResponse>>(PrepareAsyncGetTransactionResultRaw(context, request, cq));
    }
    ::grpc::Status GetRegisterAtBlockID(::grpc::ClientContext* context, const ::flow::execution::GetRegisterAtBlockIDRequest& request, ::flow::execution::GetRegisterAtBlockIDResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::GetRegisterAtBlockIDResponse>> AsyncGetRegisterAtBlockID(::grpc::ClientContext* context, const ::flow::execution::GetRegisterAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::GetRegisterAtBlockIDResponse>>(AsyncGetRegisterAtBlockIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::GetRegisterAtBlockIDResponse>> PrepareAsyncGetRegisterAtBlockID(::grpc::ClientContext* context, const ::flow::execution::GetRegisterAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::GetRegisterAtBlockIDResponse>>(PrepareAsyncGetRegisterAtBlockIDRaw(context, request, cq));
    }
    ::grpc::Status GetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::execution::GetLatestBlockHeaderRequest& request, ::flow::execution::BlockHeaderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::BlockHeaderResponse>> AsyncGetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::execution::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::BlockHeaderResponse>>(AsyncGetLatestBlockHeaderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::BlockHeaderResponse>> PrepareAsyncGetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::execution::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::BlockHeaderResponse>>(PrepareAsyncGetLatestBlockHeaderRaw(context, request, cq));
    }
    ::grpc::Status GetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::execution::GetBlockHeaderByIDRequest& request, ::flow::execution::BlockHeaderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::BlockHeaderResponse>> AsyncGetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::execution::GetBlockHeaderByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::BlockHeaderResponse>>(AsyncGetBlockHeaderByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::BlockHeaderResponse>> PrepareAsyncGetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::execution::GetBlockHeaderByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::execution::BlockHeaderResponse>>(PrepareAsyncGetBlockHeaderByIDRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Ping(::grpc::ClientContext* context, const ::flow::execution::PingRequest* request, ::flow::execution::PingResponse* response, std::function<void(::grpc::Status)>) override;
      void Ping(::grpc::ClientContext* context, const ::flow::execution::PingRequest* request, ::flow::execution::PingResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetAccountAtBlockID(::grpc::ClientContext* context, const ::flow::execution::GetAccountAtBlockIDRequest* request, ::flow::execution::GetAccountAtBlockIDResponse* response, std::function<void(::grpc::Status)>) override;
      void GetAccountAtBlockID(::grpc::ClientContext* context, const ::flow::execution::GetAccountAtBlockIDRequest* request, ::flow::execution::GetAccountAtBlockIDResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::execution::ExecuteScriptAtBlockIDRequest* request, ::flow::execution::ExecuteScriptAtBlockIDResponse* response, std::function<void(::grpc::Status)>) override;
      void ExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::execution::ExecuteScriptAtBlockIDRequest* request, ::flow::execution::ExecuteScriptAtBlockIDResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::execution::GetEventsForBlockIDsRequest* request, ::flow::execution::GetEventsForBlockIDsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::execution::GetEventsForBlockIDsRequest* request, ::flow::execution::GetEventsForBlockIDsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTransactionResult(::grpc::ClientContext* context, const ::flow::execution::GetTransactionResultRequest* request, ::flow::execution::GetTransactionResultResponse* response, std::function<void(::grpc::Status)>) override;
      void GetTransactionResult(::grpc::ClientContext* context, const ::flow::execution::GetTransactionResultRequest* request, ::flow::execution::GetTransactionResultResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetRegisterAtBlockID(::grpc::ClientContext* context, const ::flow::execution::GetRegisterAtBlockIDRequest* request, ::flow::execution::GetRegisterAtBlockIDResponse* response, std::function<void(::grpc::Status)>) override;
      void GetRegisterAtBlockID(::grpc::ClientContext* context, const ::flow::execution::GetRegisterAtBlockIDRequest* request, ::flow::execution::GetRegisterAtBlockIDResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::execution::GetLatestBlockHeaderRequest* request, ::flow::execution::BlockHeaderResponse* response, std::function<void(::grpc::Status)>) override;
      void GetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::execution::GetLatestBlockHeaderRequest* request, ::flow::execution::BlockHeaderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::execution::GetBlockHeaderByIDRequest* request, ::flow::execution::BlockHeaderResponse* response, std::function<void(::grpc::Status)>) override;
      void GetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::execution::GetBlockHeaderByIDRequest* request, ::flow::execution::BlockHeaderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::flow::execution::PingResponse>* AsyncPingRaw(::grpc::ClientContext* context, const ::flow::execution::PingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::execution::PingResponse>* PrepareAsyncPingRaw(::grpc::ClientContext* context, const ::flow::execution::PingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::execution::GetAccountAtBlockIDResponse>* AsyncGetAccountAtBlockIDRaw(::grpc::ClientContext* context, const ::flow::execution::GetAccountAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::execution::GetAccountAtBlockIDResponse>* PrepareAsyncGetAccountAtBlockIDRaw(::grpc::ClientContext* context, const ::flow::execution::GetAccountAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::execution::ExecuteScriptAtBlockIDResponse>* AsyncExecuteScriptAtBlockIDRaw(::grpc::ClientContext* context, const ::flow::execution::ExecuteScriptAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::execution::ExecuteScriptAtBlockIDResponse>* PrepareAsyncExecuteScriptAtBlockIDRaw(::grpc::ClientContext* context, const ::flow::execution::ExecuteScriptAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::execution::GetEventsForBlockIDsResponse>* AsyncGetEventsForBlockIDsRaw(::grpc::ClientContext* context, const ::flow::execution::GetEventsForBlockIDsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::execution::GetEventsForBlockIDsResponse>* PrepareAsyncGetEventsForBlockIDsRaw(::grpc::ClientContext* context, const ::flow::execution::GetEventsForBlockIDsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::execution::GetTransactionResultResponse>* AsyncGetTransactionResultRaw(::grpc::ClientContext* context, const ::flow::execution::GetTransactionResultRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::execution::GetTransactionResultResponse>* PrepareAsyncGetTransactionResultRaw(::grpc::ClientContext* context, const ::flow::execution::GetTransactionResultRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::execution::GetRegisterAtBlockIDResponse>* AsyncGetRegisterAtBlockIDRaw(::grpc::ClientContext* context, const ::flow::execution::GetRegisterAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::execution::GetRegisterAtBlockIDResponse>* PrepareAsyncGetRegisterAtBlockIDRaw(::grpc::ClientContext* context, const ::flow::execution::GetRegisterAtBlockIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::execution::BlockHeaderResponse>* AsyncGetLatestBlockHeaderRaw(::grpc::ClientContext* context, const ::flow::execution::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::execution::BlockHeaderResponse>* PrepareAsyncGetLatestBlockHeaderRaw(::grpc::ClientContext* context, const ::flow::execution::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::execution::BlockHeaderResponse>* AsyncGetBlockHeaderByIDRaw(::grpc::ClientContext* context, const ::flow::execution::GetBlockHeaderByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::execution::BlockHeaderResponse>* PrepareAsyncGetBlockHeaderByIDRaw(::grpc::ClientContext* context, const ::flow::execution::GetBlockHeaderByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Ping_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAccountAtBlockID_;
    const ::grpc::internal::RpcMethod rpcmethod_ExecuteScriptAtBlockID_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEventsForBlockIDs_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTransactionResult_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRegisterAtBlockID_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLatestBlockHeader_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlockHeaderByID_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Ping is used to check if the access node is alive and healthy.
    virtual ::grpc::Status Ping(::grpc::ServerContext* context, const ::flow::execution::PingRequest* request, ::flow::execution::PingResponse* response);
    // Accounts
    //
    // GetAccountAtBlockID gets an account by address at the given block ID
    virtual ::grpc::Status GetAccountAtBlockID(::grpc::ServerContext* context, const ::flow::execution::GetAccountAtBlockIDRequest* request, ::flow::execution::GetAccountAtBlockIDResponse* response);
    // Scripts
    //
    // ExecuteScriptAtBlockID executes a ready-only Cadence script against the
    // execution state at the block with the given ID.
    virtual ::grpc::Status ExecuteScriptAtBlockID(::grpc::ServerContext* context, const ::flow::execution::ExecuteScriptAtBlockIDRequest* request, ::flow::execution::ExecuteScriptAtBlockIDResponse* response);
    // Events
    //
    // GetEventsForBlockIDs retrieves events for all the specified block IDs that
    // have the given type
    virtual ::grpc::Status GetEventsForBlockIDs(::grpc::ServerContext* context, const ::flow::execution::GetEventsForBlockIDsRequest* request, ::flow::execution::GetEventsForBlockIDsResponse* response);
    // Transaction
    //
    // GetTransactionResult gets the result of a transaction.
    virtual ::grpc::Status GetTransactionResult(::grpc::ServerContext* context, const ::flow::execution::GetTransactionResultRequest* request, ::flow::execution::GetTransactionResultResponse* response);
    // Registers
    //
    // GetRegisterAtBlockID collects a register at the block with the given ID (if available).
    virtual ::grpc::Status GetRegisterAtBlockID(::grpc::ServerContext* context, const ::flow::execution::GetRegisterAtBlockIDRequest* request, ::flow::execution::GetRegisterAtBlockIDResponse* response);
    // Block headers
    //
    // GetLatestBlockHeader gets the latest sealed or unsealed block header.
    virtual ::grpc::Status GetLatestBlockHeader(::grpc::ServerContext* context, const ::flow::execution::GetLatestBlockHeaderRequest* request, ::flow::execution::BlockHeaderResponse* response);
    // GetBlockHeaderByID gets a block header by ID.
    virtual ::grpc::Status GetBlockHeaderByID(::grpc::ServerContext* context, const ::flow::execution::GetBlockHeaderByIDRequest* request, ::flow::execution::BlockHeaderResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Ping() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::flow::execution::PingRequest* /*request*/, ::flow::execution::PingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPing(::grpc::ServerContext* context, ::flow::execution::PingRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::execution::PingResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAccountAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAccountAtBlockID() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetAccountAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::execution::GetAccountAtBlockIDRequest* /*request*/, ::flow::execution::GetAccountAtBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAccountAtBlockID(::grpc::ServerContext* context, ::flow::execution::GetAccountAtBlockIDRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::execution::GetAccountAtBlockIDResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExecuteScriptAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExecuteScriptAtBlockID() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ExecuteScriptAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::execution::ExecuteScriptAtBlockIDRequest* /*request*/, ::flow::execution::ExecuteScriptAtBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteScriptAtBlockID(::grpc::ServerContext* context, ::flow::execution::ExecuteScriptAtBlockIDRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::execution::ExecuteScriptAtBlockIDResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEventsForBlockIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEventsForBlockIDs() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetEventsForBlockIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForBlockIDs(::grpc::ServerContext* /*context*/, const ::flow::execution::GetEventsForBlockIDsRequest* /*request*/, ::flow::execution::GetEventsForBlockIDsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEventsForBlockIDs(::grpc::ServerContext* context, ::flow::execution::GetEventsForBlockIDsRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::execution::GetEventsForBlockIDsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTransactionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTransactionResult() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetTransactionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransactionResult(::grpc::ServerContext* /*context*/, const ::flow::execution::GetTransactionResultRequest* /*request*/, ::flow::execution::GetTransactionResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTransactionResult(::grpc::ServerContext* context, ::flow::execution::GetTransactionResultRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::execution::GetTransactionResultResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRegisterAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRegisterAtBlockID() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetRegisterAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRegisterAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::execution::GetRegisterAtBlockIDRequest* /*request*/, ::flow::execution::GetRegisterAtBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRegisterAtBlockID(::grpc::ServerContext* context, ::flow::execution::GetRegisterAtBlockIDRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::execution::GetRegisterAtBlockIDResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLatestBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLatestBlockHeader() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetLatestBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlockHeader(::grpc::ServerContext* /*context*/, const ::flow::execution::GetLatestBlockHeaderRequest* /*request*/, ::flow::execution::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLatestBlockHeader(::grpc::ServerContext* context, ::flow::execution::GetLatestBlockHeaderRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::execution::BlockHeaderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlockHeaderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBlockHeaderByID() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetBlockHeaderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByID(::grpc::ServerContext* /*context*/, const ::flow::execution::GetBlockHeaderByIDRequest* /*request*/, ::flow::execution::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHeaderByID(::grpc::ServerContext* context, ::flow::execution::GetBlockHeaderByIDRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::execution::BlockHeaderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Ping<WithAsyncMethod_GetAccountAtBlockID<WithAsyncMethod_ExecuteScriptAtBlockID<WithAsyncMethod_GetEventsForBlockIDs<WithAsyncMethod_GetTransactionResult<WithAsyncMethod_GetRegisterAtBlockID<WithAsyncMethod_GetLatestBlockHeader<WithAsyncMethod_GetBlockHeaderByID<Service > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Ping() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::execution::PingRequest, ::flow::execution::PingResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::execution::PingRequest* request, ::flow::execution::PingResponse* response) { return this->Ping(context, request, response); }));}
    void SetMessageAllocatorFor_Ping(
        ::grpc::MessageAllocator< ::flow::execution::PingRequest, ::flow::execution::PingResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::execution::PingRequest, ::flow::execution::PingResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::flow::execution::PingRequest* /*request*/, ::flow::execution::PingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Ping(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::execution::PingRequest* /*request*/, ::flow::execution::PingResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetAccountAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetAccountAtBlockID() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::execution::GetAccountAtBlockIDRequest, ::flow::execution::GetAccountAtBlockIDResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::execution::GetAccountAtBlockIDRequest* request, ::flow::execution::GetAccountAtBlockIDResponse* response) { return this->GetAccountAtBlockID(context, request, response); }));}
    void SetMessageAllocatorFor_GetAccountAtBlockID(
        ::grpc::MessageAllocator< ::flow::execution::GetAccountAtBlockIDRequest, ::flow::execution::GetAccountAtBlockIDResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::execution::GetAccountAtBlockIDRequest, ::flow::execution::GetAccountAtBlockIDResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetAccountAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::execution::GetAccountAtBlockIDRequest* /*request*/, ::flow::execution::GetAccountAtBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAccountAtBlockID(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::execution::GetAccountAtBlockIDRequest* /*request*/, ::flow::execution::GetAccountAtBlockIDResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ExecuteScriptAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ExecuteScriptAtBlockID() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::execution::ExecuteScriptAtBlockIDRequest, ::flow::execution::ExecuteScriptAtBlockIDResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::execution::ExecuteScriptAtBlockIDRequest* request, ::flow::execution::ExecuteScriptAtBlockIDResponse* response) { return this->ExecuteScriptAtBlockID(context, request, response); }));}
    void SetMessageAllocatorFor_ExecuteScriptAtBlockID(
        ::grpc::MessageAllocator< ::flow::execution::ExecuteScriptAtBlockIDRequest, ::flow::execution::ExecuteScriptAtBlockIDResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::execution::ExecuteScriptAtBlockIDRequest, ::flow::execution::ExecuteScriptAtBlockIDResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ExecuteScriptAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::execution::ExecuteScriptAtBlockIDRequest* /*request*/, ::flow::execution::ExecuteScriptAtBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExecuteScriptAtBlockID(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::execution::ExecuteScriptAtBlockIDRequest* /*request*/, ::flow::execution::ExecuteScriptAtBlockIDResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetEventsForBlockIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetEventsForBlockIDs() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::execution::GetEventsForBlockIDsRequest, ::flow::execution::GetEventsForBlockIDsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::execution::GetEventsForBlockIDsRequest* request, ::flow::execution::GetEventsForBlockIDsResponse* response) { return this->GetEventsForBlockIDs(context, request, response); }));}
    void SetMessageAllocatorFor_GetEventsForBlockIDs(
        ::grpc::MessageAllocator< ::flow::execution::GetEventsForBlockIDsRequest, ::flow::execution::GetEventsForBlockIDsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::execution::GetEventsForBlockIDsRequest, ::flow::execution::GetEventsForBlockIDsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetEventsForBlockIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForBlockIDs(::grpc::ServerContext* /*context*/, const ::flow::execution::GetEventsForBlockIDsRequest* /*request*/, ::flow::execution::GetEventsForBlockIDsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEventsForBlockIDs(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::execution::GetEventsForBlockIDsRequest* /*request*/, ::flow::execution::GetEventsForBlockIDsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTransactionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTransactionResult() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::execution::GetTransactionResultRequest, ::flow::execution::GetTransactionResultResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::execution::GetTransactionResultRequest* request, ::flow::execution::GetTransactionResultResponse* response) { return this->GetTransactionResult(context, request, response); }));}
    void SetMessageAllocatorFor_GetTransactionResult(
        ::grpc::MessageAllocator< ::flow::execution::GetTransactionResultRequest, ::flow::execution::GetTransactionResultResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::execution::GetTransactionResultRequest, ::flow::execution::GetTransactionResultResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTransactionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransactionResult(::grpc::ServerContext* /*context*/, const ::flow::execution::GetTransactionResultRequest* /*request*/, ::flow::execution::GetTransactionResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTransactionResult(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::execution::GetTransactionResultRequest* /*request*/, ::flow::execution::GetTransactionResultResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetRegisterAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetRegisterAtBlockID() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::execution::GetRegisterAtBlockIDRequest, ::flow::execution::GetRegisterAtBlockIDResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::execution::GetRegisterAtBlockIDRequest* request, ::flow::execution::GetRegisterAtBlockIDResponse* response) { return this->GetRegisterAtBlockID(context, request, response); }));}
    void SetMessageAllocatorFor_GetRegisterAtBlockID(
        ::grpc::MessageAllocator< ::flow::execution::GetRegisterAtBlockIDRequest, ::flow::execution::GetRegisterAtBlockIDResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::execution::GetRegisterAtBlockIDRequest, ::flow::execution::GetRegisterAtBlockIDResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetRegisterAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRegisterAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::execution::GetRegisterAtBlockIDRequest* /*request*/, ::flow::execution::GetRegisterAtBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRegisterAtBlockID(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::execution::GetRegisterAtBlockIDRequest* /*request*/, ::flow::execution::GetRegisterAtBlockIDResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetLatestBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetLatestBlockHeader() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::execution::GetLatestBlockHeaderRequest, ::flow::execution::BlockHeaderResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::execution::GetLatestBlockHeaderRequest* request, ::flow::execution::BlockHeaderResponse* response) { return this->GetLatestBlockHeader(context, request, response); }));}
    void SetMessageAllocatorFor_GetLatestBlockHeader(
        ::grpc::MessageAllocator< ::flow::execution::GetLatestBlockHeaderRequest, ::flow::execution::BlockHeaderResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::execution::GetLatestBlockHeaderRequest, ::flow::execution::BlockHeaderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetLatestBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlockHeader(::grpc::ServerContext* /*context*/, const ::flow::execution::GetLatestBlockHeaderRequest* /*request*/, ::flow::execution::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLatestBlockHeader(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::execution::GetLatestBlockHeaderRequest* /*request*/, ::flow::execution::BlockHeaderResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetBlockHeaderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetBlockHeaderByID() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::execution::GetBlockHeaderByIDRequest, ::flow::execution::BlockHeaderResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow::execution::GetBlockHeaderByIDRequest* request, ::flow::execution::BlockHeaderResponse* response) { return this->GetBlockHeaderByID(context, request, response); }));}
    void SetMessageAllocatorFor_GetBlockHeaderByID(
        ::grpc::MessageAllocator< ::flow::execution::GetBlockHeaderByIDRequest, ::flow::execution::BlockHeaderResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::execution::GetBlockHeaderByIDRequest, ::flow::execution::BlockHeaderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetBlockHeaderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByID(::grpc::ServerContext* /*context*/, const ::flow::execution::GetBlockHeaderByIDRequest* /*request*/, ::flow::execution::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBlockHeaderByID(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::execution::GetBlockHeaderByIDRequest* /*request*/, ::flow::execution::BlockHeaderResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Ping<WithCallbackMethod_GetAccountAtBlockID<WithCallbackMethod_ExecuteScriptAtBlockID<WithCallbackMethod_GetEventsForBlockIDs<WithCallbackMethod_GetTransactionResult<WithCallbackMethod_GetRegisterAtBlockID<WithCallbackMethod_GetLatestBlockHeader<WithCallbackMethod_GetBlockHeaderByID<Service > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Ping() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::flow::execution::PingRequest* /*request*/, ::flow::execution::PingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAccountAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAccountAtBlockID() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetAccountAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::execution::GetAccountAtBlockIDRequest* /*request*/, ::flow::execution::GetAccountAtBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExecuteScriptAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExecuteScriptAtBlockID() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ExecuteScriptAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::execution::ExecuteScriptAtBlockIDRequest* /*request*/, ::flow::execution::ExecuteScriptAtBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEventsForBlockIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEventsForBlockIDs() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetEventsForBlockIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForBlockIDs(::grpc::ServerContext* /*context*/, const ::flow::execution::GetEventsForBlockIDsRequest* /*request*/, ::flow::execution::GetEventsForBlockIDsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTransactionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTransactionResult() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetTransactionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransactionResult(::grpc::ServerContext* /*context*/, const ::flow::execution::GetTransactionResultRequest* /*request*/, ::flow::execution::GetTransactionResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRegisterAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRegisterAtBlockID() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetRegisterAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRegisterAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::execution::GetRegisterAtBlockIDRequest* /*request*/, ::flow::execution::GetRegisterAtBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLatestBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLatestBlockHeader() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetLatestBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlockHeader(::grpc::ServerContext* /*context*/, const ::flow::execution::GetLatestBlockHeaderRequest* /*request*/, ::flow::execution::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBlockHeaderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBlockHeaderByID() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetBlockHeaderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByID(::grpc::ServerContext* /*context*/, const ::flow::execution::GetBlockHeaderByIDRequest* /*request*/, ::flow::execution::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Ping() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::flow::execution::PingRequest* /*request*/, ::flow::execution::PingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPing(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAccountAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAccountAtBlockID() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetAccountAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::execution::GetAccountAtBlockIDRequest* /*request*/, ::flow::execution::GetAccountAtBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAccountAtBlockID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExecuteScriptAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExecuteScriptAtBlockID() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_ExecuteScriptAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::execution::ExecuteScriptAtBlockIDRequest* /*request*/, ::flow::execution::ExecuteScriptAtBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteScriptAtBlockID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEventsForBlockIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEventsForBlockIDs() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetEventsForBlockIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForBlockIDs(::grpc::ServerContext* /*context*/, const ::flow::execution::GetEventsForBlockIDsRequest* /*request*/, ::flow::execution::GetEventsForBlockIDsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEventsForBlockIDs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTransactionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTransactionResult() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetTransactionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransactionResult(::grpc::ServerContext* /*context*/, const ::flow::execution::GetTransactionResultRequest* /*request*/, ::flow::execution::GetTransactionResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTransactionResult(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRegisterAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRegisterAtBlockID() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetRegisterAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRegisterAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::execution::GetRegisterAtBlockIDRequest* /*request*/, ::flow::execution::GetRegisterAtBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRegisterAtBlockID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLatestBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLatestBlockHeader() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetLatestBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlockHeader(::grpc::ServerContext* /*context*/, const ::flow::execution::GetLatestBlockHeaderRequest* /*request*/, ::flow::execution::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLatestBlockHeader(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlockHeaderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBlockHeaderByID() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetBlockHeaderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByID(::grpc::ServerContext* /*context*/, const ::flow::execution::GetBlockHeaderByIDRequest* /*request*/, ::flow::execution::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHeaderByID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Ping() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Ping(context, request, response); }));
    }
    ~WithRawCallbackMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::flow::execution::PingRequest* /*request*/, ::flow::execution::PingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Ping(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetAccountAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetAccountAtBlockID() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAccountAtBlockID(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetAccountAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::execution::GetAccountAtBlockIDRequest* /*request*/, ::flow::execution::GetAccountAtBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAccountAtBlockID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ExecuteScriptAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ExecuteScriptAtBlockID() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExecuteScriptAtBlockID(context, request, response); }));
    }
    ~WithRawCallbackMethod_ExecuteScriptAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::execution::ExecuteScriptAtBlockIDRequest* /*request*/, ::flow::execution::ExecuteScriptAtBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExecuteScriptAtBlockID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetEventsForBlockIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetEventsForBlockIDs() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEventsForBlockIDs(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetEventsForBlockIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForBlockIDs(::grpc::ServerContext* /*context*/, const ::flow::execution::GetEventsForBlockIDsRequest* /*request*/, ::flow::execution::GetEventsForBlockIDsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEventsForBlockIDs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTransactionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTransactionResult() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTransactionResult(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTransactionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransactionResult(::grpc::ServerContext* /*context*/, const ::flow::execution::GetTransactionResultRequest* /*request*/, ::flow::execution::GetTransactionResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTransactionResult(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetRegisterAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetRegisterAtBlockID() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRegisterAtBlockID(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetRegisterAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRegisterAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::execution::GetRegisterAtBlockIDRequest* /*request*/, ::flow::execution::GetRegisterAtBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRegisterAtBlockID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetLatestBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetLatestBlockHeader() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLatestBlockHeader(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetLatestBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlockHeader(::grpc::ServerContext* /*context*/, const ::flow::execution::GetLatestBlockHeaderRequest* /*request*/, ::flow::execution::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLatestBlockHeader(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetBlockHeaderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetBlockHeaderByID() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBlockHeaderByID(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetBlockHeaderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByID(::grpc::ServerContext* /*context*/, const ::flow::execution::GetBlockHeaderByIDRequest* /*request*/, ::flow::execution::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBlockHeaderByID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Ping() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::execution::PingRequest, ::flow::execution::PingResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::execution::PingRequest, ::flow::execution::PingResponse>* streamer) {
                       return this->StreamedPing(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::flow::execution::PingRequest* /*request*/, ::flow::execution::PingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPing(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::execution::PingRequest,::flow::execution::PingResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAccountAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAccountAtBlockID() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::execution::GetAccountAtBlockIDRequest, ::flow::execution::GetAccountAtBlockIDResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::execution::GetAccountAtBlockIDRequest, ::flow::execution::GetAccountAtBlockIDResponse>* streamer) {
                       return this->StreamedGetAccountAtBlockID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAccountAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAccountAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::execution::GetAccountAtBlockIDRequest* /*request*/, ::flow::execution::GetAccountAtBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAccountAtBlockID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::execution::GetAccountAtBlockIDRequest,::flow::execution::GetAccountAtBlockIDResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExecuteScriptAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ExecuteScriptAtBlockID() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::execution::ExecuteScriptAtBlockIDRequest, ::flow::execution::ExecuteScriptAtBlockIDResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::execution::ExecuteScriptAtBlockIDRequest, ::flow::execution::ExecuteScriptAtBlockIDResponse>* streamer) {
                       return this->StreamedExecuteScriptAtBlockID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ExecuteScriptAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExecuteScriptAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::execution::ExecuteScriptAtBlockIDRequest* /*request*/, ::flow::execution::ExecuteScriptAtBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExecuteScriptAtBlockID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::execution::ExecuteScriptAtBlockIDRequest,::flow::execution::ExecuteScriptAtBlockIDResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEventsForBlockIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEventsForBlockIDs() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::execution::GetEventsForBlockIDsRequest, ::flow::execution::GetEventsForBlockIDsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::execution::GetEventsForBlockIDsRequest, ::flow::execution::GetEventsForBlockIDsResponse>* streamer) {
                       return this->StreamedGetEventsForBlockIDs(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetEventsForBlockIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEventsForBlockIDs(::grpc::ServerContext* /*context*/, const ::flow::execution::GetEventsForBlockIDsRequest* /*request*/, ::flow::execution::GetEventsForBlockIDsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEventsForBlockIDs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::execution::GetEventsForBlockIDsRequest,::flow::execution::GetEventsForBlockIDsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTransactionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTransactionResult() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::execution::GetTransactionResultRequest, ::flow::execution::GetTransactionResultResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::execution::GetTransactionResultRequest, ::flow::execution::GetTransactionResultResponse>* streamer) {
                       return this->StreamedGetTransactionResult(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTransactionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTransactionResult(::grpc::ServerContext* /*context*/, const ::flow::execution::GetTransactionResultRequest* /*request*/, ::flow::execution::GetTransactionResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTransactionResult(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::execution::GetTransactionResultRequest,::flow::execution::GetTransactionResultResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRegisterAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRegisterAtBlockID() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::execution::GetRegisterAtBlockIDRequest, ::flow::execution::GetRegisterAtBlockIDResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::execution::GetRegisterAtBlockIDRequest, ::flow::execution::GetRegisterAtBlockIDResponse>* streamer) {
                       return this->StreamedGetRegisterAtBlockID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetRegisterAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRegisterAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::execution::GetRegisterAtBlockIDRequest* /*request*/, ::flow::execution::GetRegisterAtBlockIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRegisterAtBlockID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::execution::GetRegisterAtBlockIDRequest,::flow::execution::GetRegisterAtBlockIDResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLatestBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLatestBlockHeader() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::execution::GetLatestBlockHeaderRequest, ::flow::execution::BlockHeaderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::execution::GetLatestBlockHeaderRequest, ::flow::execution::BlockHeaderResponse>* streamer) {
                       return this->StreamedGetLatestBlockHeader(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetLatestBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLatestBlockHeader(::grpc::ServerContext* /*context*/, const ::flow::execution::GetLatestBlockHeaderRequest* /*request*/, ::flow::execution::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLatestBlockHeader(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::execution::GetLatestBlockHeaderRequest,::flow::execution::BlockHeaderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlockHeaderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBlockHeaderByID() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::execution::GetBlockHeaderByIDRequest, ::flow::execution::BlockHeaderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::execution::GetBlockHeaderByIDRequest, ::flow::execution::BlockHeaderResponse>* streamer) {
                       return this->StreamedGetBlockHeaderByID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBlockHeaderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlockHeaderByID(::grpc::ServerContext* /*context*/, const ::flow::execution::GetBlockHeaderByIDRequest* /*request*/, ::flow::execution::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlockHeaderByID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::execution::GetBlockHeaderByIDRequest,::flow::execution::BlockHeaderResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Ping<WithStreamedUnaryMethod_GetAccountAtBlockID<WithStreamedUnaryMethod_ExecuteScriptAtBlockID<WithStreamedUnaryMethod_GetEventsForBlockIDs<WithStreamedUnaryMethod_GetTransactionResult<WithStreamedUnaryMethod_GetRegisterAtBlockID<WithStreamedUnaryMethod_GetLatestBlockHeader<WithStreamedUnaryMethod_GetBlockHeaderByID<Service > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Ping<WithStreamedUnaryMethod_GetAccountAtBlockID<WithStreamedUnaryMethod_ExecuteScriptAtBlockID<WithStreamedUnaryMethod_GetEventsForBlockIDs<WithStreamedUnaryMethod_GetTransactionResult<WithStreamedUnaryMethod_GetRegisterAtBlockID<WithStreamedUnaryMethod_GetLatestBlockHeader<WithStreamedUnaryMethod_GetBlockHeaderByID<Service > > > > > > > > StreamedService;
};

}  // namespace execution
}  // namespace flow


#endif  // GRPC_flow_2fexecution_2fexecution_2eproto__INCLUDED
